function _L(n, e) {
    for (var t = 0; t < e.length; t++) {
        const i = e[t];
        if (typeof i != "string" && !Array.isArray(i)) {
            for (const r in i)
                if (r !== "default" && !(r in n)) {
                    const s = Object.getOwnPropertyDescriptor(i, r);
                    s && Object.defineProperty(n, r, s.get ? s : {
                        enumerable: !0,
                        get: () => i[r]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
        value: "Module"
    }))
}(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
    new MutationObserver(r => {
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function i(r) {
        if (r.ep) return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
})();

function xT(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}

function wL(n) {
    if (n.__esModule) return n;
    var e = n.default;
    if (typeof e == "function") {
        var t = function i() {
            if (this instanceof i) {
                var r = [null];
                r.push.apply(r, arguments);
                var s = Function.bind.apply(e, r);
                return new s
            }
            return e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }), Object.keys(n).forEach(function(i) {
        var r = Object.getOwnPropertyDescriptor(n, i);
        Object.defineProperty(t, i, r.get ? r : {
            enumerable: !0,
            get: function() {
                return n[i]
            }
        })
    }), t
}
var Mf = {},
    SL = {
        get exports() {
            return Mf
        },
        set exports(n) {
            Mf = n
        }
    },
    sg = {},
    U = {},
    ML = {
        get exports() {
            return U
        },
        set exports(n) {
            U = n
        }
    },
    wt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cd = Symbol.for("react.element"),
    CL = Symbol.for("react.portal"),
    EL = Symbol.for("react.fragment"),
    bL = Symbol.for("react.strict_mode"),
    TL = Symbol.for("react.profiler"),
    BL = Symbol.for("react.provider"),
    PL = Symbol.for("react.context"),
    RL = Symbol.for("react.forward_ref"),
    IL = Symbol.for("react.suspense"),
    LL = Symbol.for("react.memo"),
    DL = Symbol.for("react.lazy"),
    eM = Symbol.iterator;

function FL(n) {
    return n === null || typeof n != "object" ? null : (n = eM && n[eM] || n["@@iterator"], typeof n == "function" ? n : null)
}
var _T = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    wT = Object.assign,
    ST = {};

function Vu(n, e, t) {
    this.props = n, this.context = e, this.refs = ST, this.updater = t || _T
}
Vu.prototype.isReactComponent = {};
Vu.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
};
Vu.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
};

function MT() {}
MT.prototype = Vu.prototype;

function Yx(n, e, t) {
    this.props = n, this.context = e, this.refs = ST, this.updater = t || _T
}
var Zx = Yx.prototype = new MT;
Zx.constructor = Yx;
wT(Zx, Vu.prototype);
Zx.isPureReactComponent = !0;
var tM = Array.isArray,
    CT = Object.prototype.hasOwnProperty,
    qx = {
        current: null
    },
    ET = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function bT(n, e, t) {
    var i, r = {},
        s = null,
        o = null;
    if (e != null)
        for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) CT.call(e, i) && !ET.hasOwnProperty(i) && (r[i] = e[i]);
    var a = arguments.length - 2;
    if (a === 1) r.children = t;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
        r.children = l
    }
    if (n && n.defaultProps)
        for (i in a = n.defaultProps, a) r[i] === void 0 && (r[i] = a[i]);
    return {
        $$typeof: cd,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: qx.current
    }
}

function kL(n, e) {
    return {
        $$typeof: cd,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}

function $x(n) {
    return typeof n == "object" && n !== null && n.$$typeof === cd
}

function NL(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var nM = /\/+/g;

function ny(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? NL("" + n.key) : e.toString(36)
}

function Xp(n, e, t, i, r) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null) o = !0;
    else switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
                case cd:
                case CL:
                    o = !0
            }
    }
    if (o) return o = n, r = r(o), n = i === "" ? "." + ny(o, 0) : i, tM(r) ? (t = "", n != null && (t = n.replace(nM, "$&/") + "/"), Xp(r, e, t, "", function(c) {
        return c
    })) : r != null && ($x(r) && (r = kL(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(nM, "$&/") + "/") + n)), e.push(r)), 1;
    if (o = 0, i = i === "" ? "." : i + ":", tM(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var l = i + ny(s, a);
            o += Xp(s, e, t, l, r)
        } else if (l = FL(n), typeof l == "function")
            for (n = l.call(n), a = 0; !(s = n.next()).done;) s = s.value, l = i + ny(s, a++), o += Xp(s, e, t, l, r);
        else if (s === "object") throw e = String(n), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}

function kh(n, e, t) {
    if (n == null) return n;
    var i = [],
        r = 0;
    return Xp(n, i, "", "", function(s) {
        return e.call(t, s, r++)
    }), i
}

function OL(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(), e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t)
        }), n._status === -1 && (n._status = 0, n._result = e)
    }
    if (n._status === 1) return n._result.default;
    throw n._result
}
var fi = {
        current: null
    },
    Qp = {
        transition: null
    },
    UL = {
        ReactCurrentDispatcher: fi,
        ReactCurrentBatchConfig: Qp,
        ReactCurrentOwner: qx
    };
wt.Children = {
    map: kh,
    forEach: function(n, e, t) {
        kh(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return kh(n, function() {
            e++
        }), e
    },
    toArray: function(n) {
        return kh(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!$x(n)) throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
wt.Component = Vu;
wt.Fragment = EL;
wt.Profiler = TL;
wt.PureComponent = Yx;
wt.StrictMode = bL;
wt.Suspense = IL;
wt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = UL;
wt.cloneElement = function(n, e, t) {
    if (n == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var i = wT({}, n.props),
        r = n.key,
        s = n.ref,
        o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref, o = qx.current), e.key !== void 0 && (r = "" + e.key), n.type && n.type.defaultProps) var a = n.type.defaultProps;
        for (l in e) CT.call(e, l) && !ET.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1) i.children = t;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
        i.children = a
    }
    return {
        $$typeof: cd,
        type: n.type,
        key: r,
        ref: s,
        props: i,
        _owner: o
    }
};
wt.createContext = function(n) {
    return n = {
        $$typeof: PL,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, n.Provider = {
        $$typeof: BL,
        _context: n
    }, n.Consumer = n
};
wt.createElement = bT;
wt.createFactory = function(n) {
    var e = bT.bind(null, n);
    return e.type = n, e
};
wt.createRef = function() {
    return {
        current: null
    }
};
wt.forwardRef = function(n) {
    return {
        $$typeof: RL,
        render: n
    }
};
wt.isValidElement = $x;
wt.lazy = function(n) {
    return {
        $$typeof: DL,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: OL
    }
};
wt.memo = function(n, e) {
    return {
        $$typeof: LL,
        type: n,
        compare: e === void 0 ? null : e
    }
};
wt.startTransition = function(n) {
    var e = Qp.transition;
    Qp.transition = {};
    try {
        n()
    } finally {
        Qp.transition = e
    }
};
wt.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
};
wt.useCallback = function(n, e) {
    return fi.current.useCallback(n, e)
};
wt.useContext = function(n) {
    return fi.current.useContext(n)
};
wt.useDebugValue = function() {};
wt.useDeferredValue = function(n) {
    return fi.current.useDeferredValue(n)
};
wt.useEffect = function(n, e) {
    return fi.current.useEffect(n, e)
};
wt.useId = function() {
    return fi.current.useId()
};
wt.useImperativeHandle = function(n, e, t) {
    return fi.current.useImperativeHandle(n, e, t)
};
wt.useInsertionEffect = function(n, e) {
    return fi.current.useInsertionEffect(n, e)
};
wt.useLayoutEffect = function(n, e) {
    return fi.current.useLayoutEffect(n, e)
};
wt.useMemo = function(n, e) {
    return fi.current.useMemo(n, e)
};
wt.useReducer = function(n, e, t) {
    return fi.current.useReducer(n, e, t)
};
wt.useRef = function(n) {
    return fi.current.useRef(n)
};
wt.useState = function(n) {
    return fi.current.useState(n)
};
wt.useSyncExternalStore = function(n, e, t) {
    return fi.current.useSyncExternalStore(n, e, t)
};
wt.useTransition = function() {
    return fi.current.useTransition()
};
wt.version = "18.2.0";
(function(n) {
    n.exports = wt
})(ML);
const ar = xT(U),
    Lv = _L({
        __proto__: null,
        default: ar
    }, [U]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zL = U,
    GL = Symbol.for("react.element"),
    HL = Symbol.for("react.fragment"),
    VL = Object.prototype.hasOwnProperty,
    WL = zL.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    jL = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function TT(n, e, t) {
    var i, r = {},
        s = null,
        o = null;
    t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
    for (i in e) VL.call(e, i) && !jL.hasOwnProperty(i) && (r[i] = e[i]);
    if (n && n.defaultProps)
        for (i in e = n.defaultProps, e) r[i] === void 0 && (r[i] = e[i]);
    return {
        $$typeof: GL,
        type: n,
        key: s,
        ref: o,
        props: r,
        _owner: WL.current
    }
}
sg.Fragment = HL;
sg.jsx = TT;
sg.jsxs = TT;
(function(n) {
    n.exports = sg
})(SL);
const og = Mf.Fragment,
    le = Mf.jsx,
    it = Mf.jsxs;
var Dv = {},
    gm = {},
    JL = {
        get exports() {
            return gm
        },
        set exports(n) {
            gm = n
        }
    },
    Vi = {},
    Fv = {},
    XL = {
        get exports() {
            return Fv
        },
        set exports(n) {
            Fv = n
        }
    },
    BT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(k, V) {
        var J = k.length;
        k.push(V);
        e: for (; 0 < J;) {
            var ie = J - 1 >>> 1,
                j = k[ie];
            if (0 < r(j, V)) k[ie] = V, k[J] = j, J = ie;
            else break e
        }
    }

    function t(k) {
        return k.length === 0 ? null : k[0]
    }

    function i(k) {
        if (k.length === 0) return null;
        var V = k[0],
            J = k.pop();
        if (J !== V) {
            k[0] = J;
            e: for (var ie = 0, j = k.length, re = j >>> 1; ie < re;) {
                var ve = 2 * (ie + 1) - 1,
                    xe = k[ve],
                    q = ve + 1,
                    Ne = k[q];
                if (0 > r(xe, J)) q < j && 0 > r(Ne, xe) ? (k[ie] = Ne, k[q] = J, ie = q) : (k[ie] = xe, k[ve] = J, ie = ve);
                else if (q < j && 0 > r(Ne, J)) k[ie] = Ne, k[q] = J, ie = q;
                else break e
            }
        }
        return V
    }

    function r(k, V) {
        var J = k.sortIndex - V.sortIndex;
        return J !== 0 ? J : k.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        c = [],
        d = 1,
        h = null,
        p = 3,
        m = !1,
        v = !1,
        y = !1,
        A = typeof setTimeout == "function" ? setTimeout : null,
        x = typeof clearTimeout == "function" ? clearTimeout : null,
        _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function S(k) {
        for (var V = t(c); V !== null;) {
            if (V.callback === null) i(c);
            else if (V.startTime <= k) i(c), V.sortIndex = V.expirationTime, e(l, V);
            else break;
            V = t(c)
        }
    }

    function M(k) {
        if (y = !1, S(k), !v)
            if (t(l) !== null) v = !0, te(b);
            else {
                var V = t(c);
                V !== null && se(M, V.startTime - k)
            }
    }

    function b(k, V) {
        v = !1, y && (y = !1, x(E), E = -1), m = !0;
        var J = p;
        try {
            for (S(V), h = t(l); h !== null && (!(h.expirationTime > V) || k && !z());) {
                var ie = h.callback;
                if (typeof ie == "function") {
                    h.callback = null, p = h.priorityLevel;
                    var j = ie(h.expirationTime <= V);
                    V = n.unstable_now(), typeof j == "function" ? h.callback = j : h === t(l) && i(l), S(V)
                } else i(l);
                h = t(l)
            }
            if (h !== null) var re = !0;
            else {
                var ve = t(c);
                ve !== null && se(M, ve.startTime - V), re = !1
            }
            return re
        } finally {
            h = null, p = J, m = !1
        }
    }
    var B = !1,
        R = null,
        E = -1,
        P = 5,
        I = -1;

    function z() {
        return !(n.unstable_now() - I < P)
    }

    function Z() {
        if (R !== null) {
            var k = n.unstable_now();
            I = k;
            var V = !0;
            try {
                V = R(!0, k)
            } finally {
                V ? W() : (B = !1, R = null)
            }
        } else B = !1
    }
    var W;
    if (typeof _ == "function") W = function() {
        _(Z)
    };
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel,
            K = G.port2;
        G.port1.onmessage = Z, W = function() {
            K.postMessage(null)
        }
    } else W = function() {
        A(Z, 0)
    };

    function te(k) {
        R = k, B || (B = !0, W())
    }

    function se(k, V) {
        E = A(function() {
            k(n.unstable_now())
        }, V)
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(k) {
        k.callback = null
    }, n.unstable_continueExecution = function() {
        v || m || (v = !0, te(b))
    }, n.unstable_forceFrameRate = function(k) {
        0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < k ? Math.floor(1e3 / k) : 5
    }, n.unstable_getCurrentPriorityLevel = function() {
        return p
    }, n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }, n.unstable_next = function(k) {
        switch (p) {
            case 1:
            case 2:
            case 3:
                var V = 3;
                break;
            default:
                V = p
        }
        var J = p;
        p = V;
        try {
            return k()
        } finally {
            p = J
        }
    }, n.unstable_pauseExecution = function() {}, n.unstable_requestPaint = function() {}, n.unstable_runWithPriority = function(k, V) {
        switch (k) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                k = 3
        }
        var J = p;
        p = k;
        try {
            return V()
        } finally {
            p = J
        }
    }, n.unstable_scheduleCallback = function(k, V, J) {
        var ie = n.unstable_now();
        switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? ie + J : ie) : J = ie, k) {
            case 1:
                var j = -1;
                break;
            case 2:
                j = 250;
                break;
            case 5:
                j = 1073741823;
                break;
            case 4:
                j = 1e4;
                break;
            default:
                j = 5e3
        }
        return j = J + j, k = {
            id: d++,
            callback: V,
            priorityLevel: k,
            startTime: J,
            expirationTime: j,
            sortIndex: -1
        }, J > ie ? (k.sortIndex = J, e(c, k), t(l) === null && k === t(c) && (y ? (x(E), E = -1) : y = !0, se(M, J - ie))) : (k.sortIndex = j, e(l, k), v || m || (v = !0, te(b))), k
    }, n.unstable_shouldYield = z, n.unstable_wrapCallback = function(k) {
        var V = p;
        return function() {
            var J = p;
            p = V;
            try {
                return k.apply(this, arguments)
            } finally {
                p = J
            }
        }
    }
})(BT);
(function(n) {
    n.exports = BT
})(XL);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PT = U,
    zi = Fv;

function Me(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++) e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var RT = new Set,
    Cf = {};

function ol(n, e) {
    Mu(n, e), Mu(n + "Capture", e)
}

function Mu(n, e) {
    for (Cf[n] = e, n = 0; n < e.length; n++) RT.add(e[n])
}
var Us = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    kv = Object.prototype.hasOwnProperty,
    QL = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    iM = {},
    rM = {};

function KL(n) {
    return kv.call(rM, n) ? !0 : kv.call(iM, n) ? !1 : QL.test(n) ? rM[n] = !0 : (iM[n] = !0, !1)
}

function YL(n, e, t, i) {
    if (t !== null && t.type === 0) return !1;
    switch (typeof e) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-");
        default:
            return !1
    }
}

function ZL(n, e, t, i) {
    if (e === null || typeof e > "u" || YL(n, e, t, i)) return !0;
    if (i) return !1;
    if (t !== null) switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
    }
    return !1
}

function di(n, e, t, i, r, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o
}
var Vn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    Vn[n] = new di(n, 0, !1, n, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(n) {
    var e = n[0];
    Vn[e] = new di(e, 1, !1, n[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    Vn[n] = new di(n, 2, !1, n.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    Vn[n] = new di(n, 2, !1, n, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    Vn[n] = new di(n, 3, !1, n.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    Vn[n] = new di(n, 3, !0, n, null, !1, !1)
});
["capture", "download"].forEach(function(n) {
    Vn[n] = new di(n, 4, !1, n, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    Vn[n] = new di(n, 6, !1, n, null, !1, !1)
});
["rowSpan", "start"].forEach(function(n) {
    Vn[n] = new di(n, 5, !1, n.toLowerCase(), null, !1, !1)
});
var e1 = /[\-:]([a-z])/g;

function t1(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(e1, t1);
    Vn[e] = new di(e, 1, !1, n, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(e1, t1);
    Vn[e] = new di(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(e1, t1);
    Vn[e] = new di(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    Vn[n] = new di(n, 1, !1, n.toLowerCase(), null, !1, !1)
});
Vn.xlinkHref = new di("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(n) {
    Vn[n] = new di(n, 1, !1, n.toLowerCase(), null, !0, !0)
});

function n1(n, e, t, i) {
    var r = Vn.hasOwnProperty(e) ? Vn[e] : null;
    (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (ZL(e, t, r, i) && (t = null), i || r === null ? KL(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName, i = r.attributeNamespace, t === null ? n.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === !0 ? "" : "" + t, i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))))
}
var Js = PT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    Nh = Symbol.for("react.element"),
    Yl = Symbol.for("react.portal"),
    Zl = Symbol.for("react.fragment"),
    i1 = Symbol.for("react.strict_mode"),
    Nv = Symbol.for("react.profiler"),
    IT = Symbol.for("react.provider"),
    LT = Symbol.for("react.context"),
    r1 = Symbol.for("react.forward_ref"),
    Ov = Symbol.for("react.suspense"),
    Uv = Symbol.for("react.suspense_list"),
    s1 = Symbol.for("react.memo"),
    mo = Symbol.for("react.lazy"),
    DT = Symbol.for("react.offscreen"),
    sM = Symbol.iterator;

function wc(n) {
    return n === null || typeof n != "object" ? null : (n = sM && n[sM] || n["@@iterator"], typeof n == "function" ? n : null)
}
var sn = Object.assign,
    iy;

function qc(n) {
    if (iy === void 0) try {
        throw Error()
    } catch (t) {
        var e = t.stack.trim().match(/\n( *(at )?)/);
        iy = e && e[1] || ""
    }
    return `
` + iy + n
}
var ry = !1;

function sy(n, e) {
    if (!n || ry) return "";
    ry = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                    throw Error()
                }, Object.defineProperty(e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var i = c
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    i = c
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                i = c
            }
            n()
        }
    } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (r[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--, a--, 0 > a || r[o] !== s[a]) {
                                var l = `
` + r[o].replace(" at new ", " at ");
                                return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)), l
                            } while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        ry = !1, Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? qc(n) : ""
}

function qL(n) {
    switch (n.tag) {
        case 5:
            return qc(n.type);
        case 16:
            return qc("Lazy");
        case 13:
            return qc("Suspense");
        case 19:
            return qc("SuspenseList");
        case 0:
        case 2:
        case 15:
            return n = sy(n.type, !1), n;
        case 11:
            return n = sy(n.type.render, !1), n;
        case 1:
            return n = sy(n.type, !0), n;
        default:
            return ""
    }
}

function zv(n) {
    if (n == null) return null;
    if (typeof n == "function") return n.displayName || n.name || null;
    if (typeof n == "string") return n;
    switch (n) {
        case Zl:
            return "Fragment";
        case Yl:
            return "Portal";
        case Nv:
            return "Profiler";
        case i1:
            return "StrictMode";
        case Ov:
            return "Suspense";
        case Uv:
            return "SuspenseList"
    }
    if (typeof n == "object") switch (n.$$typeof) {
        case LT:
            return (n.displayName || "Context") + ".Consumer";
        case IT:
            return (n._context.displayName || "Context") + ".Provider";
        case r1:
            var e = n.render;
            return n = n.displayName, n || (n = e.displayName || e.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
        case s1:
            return e = n.displayName || null, e !== null ? e : zv(n.type) || "Memo";
        case mo:
            e = n._payload, n = n._init;
            try {
                return zv(n(e))
            } catch {}
    }
    return null
}

function $L(n) {
    var e = n.type;
    switch (n.tag) {
        case 24:
            return "Cache";
        case 9:
            return (e.displayName || "Context") + ".Consumer";
        case 10:
            return (e._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return n = e.render, n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return e;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return zv(e);
        case 8:
            return e === i1 ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof e == "function") return e.displayName || e.name || null;
            if (typeof e == "string") return e
    }
    return null
}

function Oo(n) {
    switch (typeof n) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return n;
        case "object":
            return n;
        default:
            return ""
    }
}

function FT(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function eD(n) {
    var e = FT(n) ? "checked" : "value",
        t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
        i = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var r = t.get,
            s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(o) {
                i = "" + o, s.call(this, o)
            }
        }), Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }), {
            getValue: function() {
                return i
            },
            setValue: function(o) {
                i = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null, delete n[e]
            }
        }
    }
}

function Oh(n) {
    n._valueTracker || (n._valueTracker = eD(n))
}

function kT(n) {
    if (!n) return !1;
    var e = n._valueTracker;
    if (!e) return !0;
    var t = e.getValue(),
        i = "";
    return n && (i = FT(n) ? n.checked ? "true" : "false" : n.value), n = i, n !== t ? (e.setValue(n), !0) : !1
}

function ym(n) {
    if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}

function Gv(n, e) {
    var t = e.checked;
    return sn({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}

function oM(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue,
        i = e.checked != null ? e.checked : e.defaultChecked;
    t = Oo(e.value != null ? e.value : t), n._wrapperState = {
        initialChecked: i,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}

function NT(n, e) {
    e = e.checked, e != null && n1(n, "checked", e, !1)
}

function Hv(n, e) {
    NT(n, e);
    var t = Oo(e.value),
        i = e.type;
    if (t != null) i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (i === "submit" || i === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? Vv(n, e.type, t) : e.hasOwnProperty("defaultValue") && Vv(n, e.type, Oo(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}

function aM(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var i = e.type;
        if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return;
        e = "" + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e
    }
    t = n.name, t !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, t !== "" && (n.name = t)
}

function Vv(n, e, t) {
    (e !== "number" || ym(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var $c = Array.isArray;

function mu(n, e, t, i) {
    if (n = n.options, e) {
        e = {};
        for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
        for (t = 0; t < n.length; t++) r = e.hasOwnProperty("$" + n[t].value), n[t].selected !== r && (n[t].selected = r), r && i && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + Oo(t), e = null, r = 0; r < n.length; r++) {
            if (n[r].value === t) {
                n[r].selected = !0, i && (n[r].defaultSelected = !0);
                return
            }
            e !== null || n[r].disabled || (e = n[r])
        }
        e !== null && (e.selected = !0)
    }
}

function Wv(n, e) {
    if (e.dangerouslySetInnerHTML != null) throw Error(Me(91));
    return sn({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}

function lM(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children, e = e.defaultValue, t != null) {
            if (e != null) throw Error(Me(92));
            if ($c(t)) {
                if (1 < t.length) throw Error(Me(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""), t = e
    }
    n._wrapperState = {
        initialValue: Oo(t)
    }
}

function OT(n, e) {
    var t = Oo(e.value),
        i = Oo(e.defaultValue);
    t != null && (t = "" + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), i != null && (n.defaultValue = "" + i)
}

function uM(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}

function UT(n) {
    switch (n) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function jv(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? UT(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var Uh, zT = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, i, r)
        })
    } : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n) n.innerHTML = e;
    else {
        for (Uh = Uh || document.createElement("div"), Uh.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Uh.firstChild; n.firstChild;) n.removeChild(n.firstChild);
        for (; e.firstChild;) n.appendChild(e.firstChild)
    }
});

function Ef(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var sf = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    tD = ["Webkit", "ms", "Moz", "O"];
Object.keys(sf).forEach(function(n) {
    tD.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1), sf[e] = sf[n]
    })
});

function GT(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || sf.hasOwnProperty(n) && sf[n] ? ("" + e).trim() : e + "px"
}

function HT(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var i = t.indexOf("--") === 0,
                r = GT(t, e[t], i);
            t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : n[t] = r
        }
}
var nD = sn({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function Jv(n, e) {
    if (e) {
        if (nD[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Me(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null) throw Error(Me(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Me(61))
        }
        if (e.style != null && typeof e.style != "object") throw Error(Me(62))
    }
}

function Xv(n, e) {
    if (n.indexOf("-") === -1) return typeof e.is == "string";
    switch (n) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var Qv = null;

function o1(n) {
    return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n
}
var Kv = null,
    gu = null,
    yu = null;

function cM(n) {
    if (n = hd(n)) {
        if (typeof Kv != "function") throw Error(Me(280));
        var e = n.stateNode;
        e && (e = fg(e), Kv(n.stateNode, n.type, e))
    }
}

function VT(n) {
    gu ? yu ? yu.push(n) : yu = [n] : gu = n
}

function WT() {
    if (gu) {
        var n = gu,
            e = yu;
        if (yu = gu = null, cM(n), e)
            for (n = 0; n < e.length; n++) cM(e[n])
    }
}

function jT(n, e) {
    return n(e)
}

function JT() {}
var oy = !1;

function XT(n, e, t) {
    if (oy) return n(e, t);
    oy = !0;
    try {
        return jT(n, e, t)
    } finally {
        oy = !1, (gu !== null || yu !== null) && (JT(), WT())
    }
}

function bf(n, e) {
    var t = n.stateNode;
    if (t === null) return null;
    var i = fg(t);
    if (i === null) return null;
    t = i[e];
    e: switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (i = !i.disabled) || (n = n.type, i = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !i;
            break e;
        default:
            n = !1
    }
    if (n) return null;
    if (t && typeof t != "function") throw Error(Me(231, e, typeof t));
    return t
}
var Yv = !1;
if (Us) try {
    var Sc = {};
    Object.defineProperty(Sc, "passive", {
        get: function() {
            Yv = !0
        }
    }), window.addEventListener("test", Sc, Sc), window.removeEventListener("test", Sc, Sc)
} catch {
    Yv = !1
}

function iD(n, e, t, i, r, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, c)
    } catch (d) {
        this.onError(d)
    }
}
var of = !1, vm = null, Am = !1, Zv = null, rD = {
    onError: function(n) {
        of = !0, vm = n
    }
};

function sD(n, e, t, i, r, s, o, a, l) {
    of = !1, vm = null, iD.apply(rD, arguments)
}

function oD(n, e, t, i, r, s, o, a, l) {
    if (sD.apply(this, arguments), of ) {
        if ( of ) {
            var c = vm; of = !1, vm = null
        } else throw Error(Me(198));
        Am || (Am = !0, Zv = c)
    }
}

function al(n) {
    var e = n,
        t = n;
    if (n.alternate)
        for (; e.return;) e = e.return;
    else {
        n = e;
        do e = n, e.flags & 4098 && (t = e.return), n = e.return; while (n)
    }
    return e.tag === 3 ? t : null
}

function QT(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null) return e.dehydrated
    }
    return null
}

function fM(n) {
    if (al(n) !== n) throw Error(Me(188))
}

function aD(n) {
    var e = n.alternate;
    if (!e) {
        if (e = al(n), e === null) throw Error(Me(188));
        return e !== n ? null : n
    }
    for (var t = n, i = e;;) {
        var r = t.return;
        if (r === null) break;
        var s = r.alternate;
        if (s === null) {
            if (i = r.return, i !== null) {
                t = i;
                continue
            }
            break
        }
        if (r.child === s.child) {
            for (s = r.child; s;) {
                if (s === t) return fM(r), n;
                if (s === i) return fM(r), e;
                s = s.sibling
            }
            throw Error(Me(188))
        }
        if (t.return !== i.return) t = r, i = s;
        else {
            for (var o = !1, a = r.child; a;) {
                if (a === t) {
                    o = !0, t = r, i = s;
                    break
                }
                if (a === i) {
                    o = !0, i = r, t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a;) {
                    if (a === t) {
                        o = !0, t = s, i = r;
                        break
                    }
                    if (a === i) {
                        o = !0, i = s, t = r;
                        break
                    }
                    a = a.sibling
                }
                if (!o) throw Error(Me(189))
            }
        }
        if (t.alternate !== i) throw Error(Me(190))
    }
    if (t.tag !== 3) throw Error(Me(188));
    return t.stateNode.current === t ? n : e
}

function KT(n) {
    return n = aD(n), n !== null ? YT(n) : null
}

function YT(n) {
    if (n.tag === 5 || n.tag === 6) return n;
    for (n = n.child; n !== null;) {
        var e = YT(n);
        if (e !== null) return e;
        n = n.sibling
    }
    return null
}
var ZT = zi.unstable_scheduleCallback,
    dM = zi.unstable_cancelCallback,
    lD = zi.unstable_shouldYield,
    uD = zi.unstable_requestPaint,
    mn = zi.unstable_now,
    cD = zi.unstable_getCurrentPriorityLevel,
    a1 = zi.unstable_ImmediatePriority,
    qT = zi.unstable_UserBlockingPriority,
    xm = zi.unstable_NormalPriority,
    fD = zi.unstable_LowPriority,
    $T = zi.unstable_IdlePriority,
    ag = null,
    $r = null;

function dD(n) {
    if ($r && typeof $r.onCommitFiberRoot == "function") try {
        $r.onCommitFiberRoot(ag, n, void 0, (n.current.flags & 128) === 128)
    } catch {}
}
var Ir = Math.clz32 ? Math.clz32 : mD,
    hD = Math.log,
    pD = Math.LN2;

function mD(n) {
    return n >>>= 0, n === 0 ? 32 : 31 - (hD(n) / pD | 0) | 0
}
var zh = 64,
    Gh = 4194304;

function ef(n) {
    switch (n & -n) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return n & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return n & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return n
    }
}

function _m(n, e) {
    var t = n.pendingLanes;
    if (t === 0) return 0;
    var i = 0,
        r = n.suspendedLanes,
        s = n.pingedLanes,
        o = t & 268435455;
    if (o !== 0) {
        var a = o & ~r;
        a !== 0 ? i = ef(a) : (s &= o, s !== 0 && (i = ef(s)))
    } else o = t & ~r, o !== 0 ? i = ef(o) : s !== 0 && (i = ef(s));
    if (i === 0) return 0;
    if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e;
    if (i & 4 && (i |= t & 16), e = n.entangledLanes, e !== 0)
        for (n = n.entanglements, e &= i; 0 < e;) t = 31 - Ir(e), r = 1 << t, i |= n[t], e &= ~r;
    return i
}

function gD(n, e) {
    switch (n) {
        case 1:
        case 2:
        case 4:
            return e + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function yD(n, e) {
    for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s;) {
        var o = 31 - Ir(s),
            a = 1 << o,
            l = r[o];
        l === -1 ? (!(a & t) || a & i) && (r[o] = gD(a, e)) : l <= e && (n.expiredLanes |= a), s &= ~a
    }
}

function qv(n) {
    return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}

function e2() {
    var n = zh;
    return zh <<= 1, !(zh & 4194240) && (zh = 64), n
}

function ay(n) {
    for (var e = [], t = 0; 31 > t; t++) e.push(n);
    return e
}

function fd(n, e, t) {
    n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - Ir(e), n[e] = t
}

function vD(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements;
    var i = n.eventTimes;
    for (n = n.expirationTimes; 0 < t;) {
        var r = 31 - Ir(t),
            s = 1 << r;
        e[r] = 0, i[r] = -1, n[r] = -1, t &= ~s
    }
}

function l1(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t;) {
        var i = 31 - Ir(t),
            r = 1 << i;
        r & e | n[i] & e && (n[i] |= e), t &= ~r
    }
}
var Nt = 0;

function t2(n) {
    return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var n2, u1, i2, r2, s2, $v = !1,
    Hh = [],
    bo = null,
    To = null,
    Bo = null,
    Tf = new Map,
    Bf = new Map,
    xo = [],
    AD = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function hM(n, e) {
    switch (n) {
        case "focusin":
        case "focusout":
            bo = null;
            break;
        case "dragenter":
        case "dragleave":
            To = null;
            break;
        case "mouseover":
        case "mouseout":
            Bo = null;
            break;
        case "pointerover":
        case "pointerout":
            Tf.delete(e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Bf.delete(e.pointerId)
    }
}

function Mc(n, e, t, i, r, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r]
    }, e !== null && (e = hd(e), e !== null && u1(e)), n) : (n.eventSystemFlags |= i, e = n.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), n)
}

function xD(n, e, t, i, r) {
    switch (e) {
        case "focusin":
            return bo = Mc(bo, n, e, t, i, r), !0;
        case "dragenter":
            return To = Mc(To, n, e, t, i, r), !0;
        case "mouseover":
            return Bo = Mc(Bo, n, e, t, i, r), !0;
        case "pointerover":
            var s = r.pointerId;
            return Tf.set(s, Mc(Tf.get(s) || null, n, e, t, i, r)), !0;
        case "gotpointercapture":
            return s = r.pointerId, Bf.set(s, Mc(Bf.get(s) || null, n, e, t, i, r)), !0
    }
    return !1
}

function o2(n) {
    var e = Ia(n.target);
    if (e !== null) {
        var t = al(e);
        if (t !== null) {
            if (e = t.tag, e === 13) {
                if (e = QT(t), e !== null) {
                    n.blockedOn = e, s2(n.priority, function() {
                        i2(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}

function Kp(n) {
    if (n.blockedOn !== null) return !1;
    for (var e = n.targetContainers; 0 < e.length;) {
        var t = eA(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var i = new t.constructor(t.type, t);
            Qv = i, t.target.dispatchEvent(i), Qv = null
        } else return e = hd(t), e !== null && u1(e), n.blockedOn = t, !1;
        e.shift()
    }
    return !0
}

function pM(n, e, t) {
    Kp(n) && t.delete(e)
}

function _D() {
    $v = !1, bo !== null && Kp(bo) && (bo = null), To !== null && Kp(To) && (To = null), Bo !== null && Kp(Bo) && (Bo = null), Tf.forEach(pM), Bf.forEach(pM)
}

function Cc(n, e) {
    n.blockedOn === e && (n.blockedOn = null, $v || ($v = !0, zi.unstable_scheduleCallback(zi.unstable_NormalPriority, _D)))
}

function Pf(n) {
    function e(r) {
        return Cc(r, n)
    }
    if (0 < Hh.length) {
        Cc(Hh[0], n);
        for (var t = 1; t < Hh.length; t++) {
            var i = Hh[t];
            i.blockedOn === n && (i.blockedOn = null)
        }
    }
    for (bo !== null && Cc(bo, n), To !== null && Cc(To, n), Bo !== null && Cc(Bo, n), Tf.forEach(e), Bf.forEach(e), t = 0; t < xo.length; t++) i = xo[t], i.blockedOn === n && (i.blockedOn = null);
    for (; 0 < xo.length && (t = xo[0], t.blockedOn === null);) o2(t), t.blockedOn === null && xo.shift()
}
var vu = Js.ReactCurrentBatchConfig,
    wm = !0;

function wD(n, e, t, i) {
    var r = Nt,
        s = vu.transition;
    vu.transition = null;
    try {
        Nt = 1, c1(n, e, t, i)
    } finally {
        Nt = r, vu.transition = s
    }
}

function SD(n, e, t, i) {
    var r = Nt,
        s = vu.transition;
    vu.transition = null;
    try {
        Nt = 4, c1(n, e, t, i)
    } finally {
        Nt = r, vu.transition = s
    }
}

function c1(n, e, t, i) {
    if (wm) {
        var r = eA(n, e, t, i);
        if (r === null) yy(n, e, i, Sm, t), hM(n, i);
        else if (xD(r, n, e, t, i)) i.stopPropagation();
        else if (hM(n, i), e & 4 && -1 < AD.indexOf(n)) {
            for (; r !== null;) {
                var s = hd(r);
                if (s !== null && n2(s), s = eA(n, e, t, i), s === null && yy(n, e, i, Sm, t), s === r) break;
                r = s
            }
            r !== null && i.stopPropagation()
        } else yy(n, e, i, null, t)
    }
}
var Sm = null;

function eA(n, e, t, i) {
    if (Sm = null, n = o1(i), n = Ia(n), n !== null)
        if (e = al(n), e === null) n = null;
        else if (t = e.tag, t === 13) {
        if (n = QT(e), n !== null) return n;
        n = null
    } else if (t === 3) {
        if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
        n = null
    } else e !== n && (n = null);
    return Sm = n, null
}

function a2(n) {
    switch (n) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (cD()) {
                case a1:
                    return 1;
                case qT:
                    return 4;
                case xm:
                case fD:
                    return 16;
                case $T:
                    return 536870912;
                default:
                    return 16
            }
            default:
                return 16
    }
}
var wo = null,
    f1 = null,
    Yp = null;

function l2() {
    if (Yp) return Yp;
    var n, e = f1,
        t = e.length,
        i, r = "value" in wo ? wo.value : wo.textContent,
        s = r.length;
    for (n = 0; n < t && e[n] === r[n]; n++);
    var o = t - n;
    for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
    return Yp = r.slice(n, 1 < i ? 1 - i : void 0)
}

function Zp(n) {
    var e = n.keyCode;
    return "charCode" in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0
}

function Vh() {
    return !0
}

function mM() {
    return !1
}

function Wi(n) {
    function e(t, i, r, s, o) {
        this._reactName = t, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null;
        for (var a in n) n.hasOwnProperty(a) && (t = n[a], this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Vh : mM, this.isPropagationStopped = mM, this
    }
    return sn(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = Vh)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = Vh)
        },
        persist: function() {},
        isPersistent: Vh
    }), e
}
var Wu = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(n) {
            return n.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    d1 = Wi(Wu),
    dd = sn({}, Wu, {
        view: 0,
        detail: 0
    }),
    MD = Wi(dd),
    ly, uy, Ec, lg = sn({}, dd, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: h1,
        button: 0,
        buttons: 0,
        relatedTarget: function(n) {
            return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
        },
        movementX: function(n) {
            return "movementX" in n ? n.movementX : (n !== Ec && (Ec && n.type === "mousemove" ? (ly = n.screenX - Ec.screenX, uy = n.screenY - Ec.screenY) : uy = ly = 0, Ec = n), ly)
        },
        movementY: function(n) {
            return "movementY" in n ? n.movementY : uy
        }
    }),
    gM = Wi(lg),
    CD = sn({}, lg, {
        dataTransfer: 0
    }),
    ED = Wi(CD),
    bD = sn({}, dd, {
        relatedTarget: 0
    }),
    cy = Wi(bD),
    TD = sn({}, Wu, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    BD = Wi(TD),
    PD = sn({}, Wu, {
        clipboardData: function(n) {
            return "clipboardData" in n ? n.clipboardData : window.clipboardData
        }
    }),
    RD = Wi(PD),
    ID = sn({}, Wu, {
        data: 0
    }),
    yM = Wi(ID),
    LD = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    DD = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    FD = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function kD(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = FD[n]) ? !!e[n] : !1
}

function h1() {
    return kD
}
var ND = sn({}, dd, {
        key: function(n) {
            if (n.key) {
                var e = LD[n.key] || n.key;
                if (e !== "Unidentified") return e
            }
            return n.type === "keypress" ? (n = Zp(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? DD[n.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: h1,
        charCode: function(n) {
            return n.type === "keypress" ? Zp(n) : 0
        },
        keyCode: function(n) {
            return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
        },
        which: function(n) {
            return n.type === "keypress" ? Zp(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
        }
    }),
    OD = Wi(ND),
    UD = sn({}, lg, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    vM = Wi(UD),
    zD = sn({}, dd, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: h1
    }),
    GD = Wi(zD),
    HD = sn({}, Wu, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    VD = Wi(HD),
    WD = sn({}, lg, {
        deltaX: function(n) {
            return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0
        },
        deltaY: function(n) {
            return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    jD = Wi(WD),
    JD = [9, 13, 27, 32],
    p1 = Us && "CompositionEvent" in window,
    af = null;
Us && "documentMode" in document && (af = document.documentMode);
var XD = Us && "TextEvent" in window && !af,
    u2 = Us && (!p1 || af && 8 < af && 11 >= af),
    AM = String.fromCharCode(32),
    xM = !1;

function c2(n, e) {
    switch (n) {
        case "keyup":
            return JD.indexOf(e.keyCode) !== -1;
        case "keydown":
            return e.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function f2(n) {
    return n = n.detail, typeof n == "object" && "data" in n ? n.data : null
}
var ql = !1;

function QD(n, e) {
    switch (n) {
        case "compositionend":
            return f2(e);
        case "keypress":
            return e.which !== 32 ? null : (xM = !0, AM);
        case "textInput":
            return n = e.data, n === AM && xM ? null : n;
        default:
            return null
    }
}

function KD(n, e) {
    if (ql) return n === "compositionend" || !p1 && c2(n, e) ? (n = l2(), Yp = f1 = wo = null, ql = !1, n) : null;
    switch (n) {
        case "paste":
            return null;
        case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
                if (e.char && 1 < e.char.length) return e.char;
                if (e.which) return String.fromCharCode(e.which)
            }
            return null;
        case "compositionend":
            return u2 && e.locale !== "ko" ? null : e.data;
        default:
            return null
    }
}
var YD = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function _M(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!YD[n.type] : e === "textarea"
}

function d2(n, e, t, i) {
    VT(i), e = Mm(e, "onChange"), 0 < e.length && (t = new d1("onChange", "change", null, t, i), n.push({
        event: t,
        listeners: e
    }))
}
var lf = null,
    Rf = null;

function ZD(n) {
    S2(n, 0)
}

function ug(n) {
    var e = tu(n);
    if (kT(e)) return n
}

function qD(n, e) {
    if (n === "change") return e
}
var h2 = !1;
if (Us) {
    var fy;
    if (Us) {
        var dy = "oninput" in document;
        if (!dy) {
            var wM = document.createElement("div");
            wM.setAttribute("oninput", "return;"), dy = typeof wM.oninput == "function"
        }
        fy = dy
    } else fy = !1;
    h2 = fy && (!document.documentMode || 9 < document.documentMode)
}

function SM() {
    lf && (lf.detachEvent("onpropertychange", p2), Rf = lf = null)
}

function p2(n) {
    if (n.propertyName === "value" && ug(Rf)) {
        var e = [];
        d2(e, Rf, n, o1(n)), XT(ZD, e)
    }
}

function $D(n, e, t) {
    n === "focusin" ? (SM(), lf = e, Rf = t, lf.attachEvent("onpropertychange", p2)) : n === "focusout" && SM()
}

function eF(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown") return ug(Rf)
}

function tF(n, e) {
    if (n === "click") return ug(e)
}

function nF(n, e) {
    if (n === "input" || n === "change") return ug(e)
}

function iF(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var kr = typeof Object.is == "function" ? Object.is : iF;

function If(n, e) {
    if (kr(n, e)) return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null) return !1;
    var t = Object.keys(n),
        i = Object.keys(e);
    if (t.length !== i.length) return !1;
    for (i = 0; i < t.length; i++) {
        var r = t[i];
        if (!kv.call(e, r) || !kr(n[r], e[r])) return !1
    }
    return !0
}

function MM(n) {
    for (; n && n.firstChild;) n = n.firstChild;
    return n
}

function CM(n, e) {
    var t = MM(n);
    n = 0;
    for (var i; t;) {
        if (t.nodeType === 3) {
            if (i = n + t.textContent.length, n <= e && i >= e) return {
                node: t,
                offset: e - n
            };
            n = i
        }
        e: {
            for (; t;) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = MM(t)
    }
}

function m2(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? m2(n, e.parentNode) : "contains" in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}

function g2() {
    for (var n = window, e = ym(); e instanceof n.HTMLIFrameElement;) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t) n = e.contentWindow;
        else break;
        e = ym(n.document)
    }
    return e
}

function m1(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}

function rF(n) {
    var e = g2(),
        t = n.focusedElem,
        i = n.selectionRange;
    if (e !== t && t && t.ownerDocument && m2(t.ownerDocument.documentElement, t)) {
        if (i !== null && m1(t)) {
            if (e = i.start, n = i.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) {
                n = n.getSelection();
                var r = t.textContent.length,
                    s = Math.min(i.start, r);
                i = i.end === void 0 ? s : Math.min(i.end, r), !n.extend && s > i && (r = i, i = s, s = r), r = CM(t, s);
                var o = CM(t, i);
                r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n.removeAllRanges(), s > i ? (n.addRange(e), n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n.addRange(e)))
            }
        }
        for (e = [], n = t; n = n.parentNode;) n.nodeType === 1 && e.push({
            element: n,
            left: n.scrollLeft,
            top: n.scrollTop
        });
        for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++) n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top
    }
}
var sF = Us && "documentMode" in document && 11 >= document.documentMode,
    $l = null,
    tA = null,
    uf = null,
    nA = !1;

function EM(n, e, t) {
    var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    nA || $l == null || $l !== ym(i) || (i = $l, "selectionStart" in i && m1(i) ? i = {
        start: i.selectionStart,
        end: i.selectionEnd
    } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = {
        anchorNode: i.anchorNode,
        anchorOffset: i.anchorOffset,
        focusNode: i.focusNode,
        focusOffset: i.focusOffset
    }), uf && If(uf, i) || (uf = i, i = Mm(tA, "onSelect"), 0 < i.length && (e = new d1("onSelect", "select", null, e, t), n.push({
        event: e,
        listeners: i
    }), e.target = $l)))
}

function Wh(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit" + n] = "webkit" + e, t["Moz" + n] = "moz" + e, t
}
var eu = {
        animationend: Wh("Animation", "AnimationEnd"),
        animationiteration: Wh("Animation", "AnimationIteration"),
        animationstart: Wh("Animation", "AnimationStart"),
        transitionend: Wh("Transition", "TransitionEnd")
    },
    hy = {},
    y2 = {};
Us && (y2 = document.createElement("div").style, "AnimationEvent" in window || (delete eu.animationend.animation, delete eu.animationiteration.animation, delete eu.animationstart.animation), "TransitionEvent" in window || delete eu.transitionend.transition);

function cg(n) {
    if (hy[n]) return hy[n];
    if (!eu[n]) return n;
    var e = eu[n],
        t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in y2) return hy[n] = e[t];
    return n
}
var v2 = cg("animationend"),
    A2 = cg("animationiteration"),
    x2 = cg("animationstart"),
    _2 = cg("transitionend"),
    w2 = new Map,
    bM = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function Xo(n, e) {
    w2.set(n, e), ol(e, [n])
}
for (var py = 0; py < bM.length; py++) {
    var my = bM[py],
        oF = my.toLowerCase(),
        aF = my[0].toUpperCase() + my.slice(1);
    Xo(oF, "on" + aF)
}
Xo(v2, "onAnimationEnd");
Xo(A2, "onAnimationIteration");
Xo(x2, "onAnimationStart");
Xo("dblclick", "onDoubleClick");
Xo("focusin", "onFocus");
Xo("focusout", "onBlur");
Xo(_2, "onTransitionEnd");
Mu("onMouseEnter", ["mouseout", "mouseover"]);
Mu("onMouseLeave", ["mouseout", "mouseover"]);
Mu("onPointerEnter", ["pointerout", "pointerover"]);
Mu("onPointerLeave", ["pointerout", "pointerover"]);
ol("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
ol("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
ol("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ol("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
ol("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
ol("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var tf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    lF = new Set("cancel close invalid load scroll toggle".split(" ").concat(tf));

function TM(n, e, t) {
    var i = n.type || "unknown-event";
    n.currentTarget = t, oD(i, e, void 0, n), n.currentTarget = null
}

function S2(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var i = n[t],
            r = i.event;
        i = i.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = i.length - 1; 0 <= o; o--) {
                    var a = i[o],
                        l = a.instance,
                        c = a.currentTarget;
                    if (a = a.listener, l !== s && r.isPropagationStopped()) break e;
                    TM(r, a, c), s = l
                } else
                    for (o = 0; o < i.length; o++) {
                        if (a = i[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e;
                        TM(r, a, c), s = l
                    }
        }
    }
    if (Am) throw n = Zv, Am = !1, Zv = null, n
}

function Wt(n, e) {
    var t = e[aA];
    t === void 0 && (t = e[aA] = new Set);
    var i = n + "__bubble";
    t.has(i) || (M2(e, n, 2, !1), t.add(i))
}

function gy(n, e, t) {
    var i = 0;
    e && (i |= 4), M2(t, n, i, e)
}
var jh = "_reactListening" + Math.random().toString(36).slice(2);

function Lf(n) {
    if (!n[jh]) {
        n[jh] = !0, RT.forEach(function(t) {
            t !== "selectionchange" && (lF.has(t) || gy(t, !1, n), gy(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[jh] || (e[jh] = !0, gy("selectionchange", !1, e))
    }
}

function M2(n, e, t, i) {
    switch (a2(e)) {
        case 1:
            var r = wD;
            break;
        case 4:
            r = SD;
            break;
        default:
            r = c1
    }
    t = r.bind(null, e, t, n), r = void 0, !Yv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: r
    }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, {
        passive: r
    }) : n.addEventListener(e, t, !1)
}

function yy(n, e, t, i, r) {
    var s = i;
    if (!(e & 1) && !(e & 2) && i !== null) e: for (;;) {
        if (i === null) return;
        var o = i.tag;
        if (o === 3 || o === 4) {
            var a = i.stateNode.containerInfo;
            if (a === r || a.nodeType === 8 && a.parentNode === r) break;
            if (o === 4)
                for (o = i.return; o !== null;) {
                    var l = o.tag;
                    if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return;
                    o = o.return
                }
            for (; a !== null;) {
                if (o = Ia(a), o === null) return;
                if (l = o.tag, l === 5 || l === 6) {
                    i = s = o;
                    continue e
                }
                a = a.parentNode
            }
        }
        i = i.return
    }
    XT(function() {
        var c = s,
            d = o1(t),
            h = [];
        e: {
            var p = w2.get(n);
            if (p !== void 0) {
                var m = d1,
                    v = n;
                switch (n) {
                    case "keypress":
                        if (Zp(t) === 0) break e;
                    case "keydown":
                    case "keyup":
                        m = OD;
                        break;
                    case "focusin":
                        v = "focus", m = cy;
                        break;
                    case "focusout":
                        v = "blur", m = cy;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        m = cy;
                        break;
                    case "click":
                        if (t.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        m = gM;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        m = ED;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        m = GD;
                        break;
                    case v2:
                    case A2:
                    case x2:
                        m = BD;
                        break;
                    case _2:
                        m = VD;
                        break;
                    case "scroll":
                        m = MD;
                        break;
                    case "wheel":
                        m = jD;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        m = RD;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        m = vM
                }
                var y = (e & 4) !== 0,
                    A = !y && n === "scroll",
                    x = y ? p !== null ? p + "Capture" : null : p;
                y = [];
                for (var _ = c, S; _ !== null;) {
                    S = _;
                    var M = S.stateNode;
                    if (S.tag === 5 && M !== null && (S = M, x !== null && (M = bf(_, x), M != null && y.push(Df(_, M, S)))), A) break;
                    _ = _.return
                }
                0 < y.length && (p = new m(p, v, null, t, d), h.push({
                    event: p,
                    listeners: y
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (p = n === "mouseover" || n === "pointerover", m = n === "mouseout" || n === "pointerout", p && t !== Qv && (v = t.relatedTarget || t.fromElement) && (Ia(v) || v[zs])) break e;
                if ((m || p) && (p = d.window === d ? d : (p = d.ownerDocument) ? p.defaultView || p.parentWindow : window, m ? (v = t.relatedTarget || t.toElement, m = c, v = v ? Ia(v) : null, v !== null && (A = al(v), v !== A || v.tag !== 5 && v.tag !== 6) && (v = null)) : (m = null, v = c), m !== v)) {
                    if (y = gM, M = "onMouseLeave", x = "onMouseEnter", _ = "mouse", (n === "pointerout" || n === "pointerover") && (y = vM, M = "onPointerLeave", x = "onPointerEnter", _ = "pointer"), A = m == null ? p : tu(m), S = v == null ? p : tu(v), p = new y(M, _ + "leave", m, t, d), p.target = A, p.relatedTarget = S, M = null, Ia(d) === c && (y = new y(x, _ + "enter", v, t, d), y.target = S, y.relatedTarget = A, M = y), A = M, m && v) t: {
                        for (y = m, x = v, _ = 0, S = y; S; S = Tl(S)) _++;
                        for (S = 0, M = x; M; M = Tl(M)) S++;
                        for (; 0 < _ - S;) y = Tl(y),
                        _--;
                        for (; 0 < S - _;) x = Tl(x),
                        S--;
                        for (; _--;) {
                            if (y === x || x !== null && y === x.alternate) break t;
                            y = Tl(y), x = Tl(x)
                        }
                        y = null
                    }
                    else y = null;
                    m !== null && BM(h, p, m, y, !1), v !== null && A !== null && BM(h, A, v, y, !0)
                }
            }
            e: {
                if (p = c ? tu(c) : window, m = p.nodeName && p.nodeName.toLowerCase(), m === "select" || m === "input" && p.type === "file") var b = qD;
                else if (_M(p))
                    if (h2) b = nF;
                    else {
                        b = eF;
                        var B = $D
                    }
                else(m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (b = tF);
                if (b && (b = b(n, c))) {
                    d2(h, b, t, d);
                    break e
                }
                B && B(n, p, c),
                n === "focusout" && (B = p._wrapperState) && B.controlled && p.type === "number" && Vv(p, "number", p.value)
            }
            switch (B = c ? tu(c) : window, n) {
                case "focusin":
                    (_M(B) || B.contentEditable === "true") && ($l = B, tA = c, uf = null);
                    break;
                case "focusout":
                    uf = tA = $l = null;
                    break;
                case "mousedown":
                    nA = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    nA = !1, EM(h, t, d);
                    break;
                case "selectionchange":
                    if (sF) break;
                case "keydown":
                case "keyup":
                    EM(h, t, d)
            }
            var R;
            if (p1) e: {
                switch (n) {
                    case "compositionstart":
                        var E = "onCompositionStart";
                        break e;
                    case "compositionend":
                        E = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        E = "onCompositionUpdate";
                        break e
                }
                E = void 0
            }
            else ql ? c2(n, t) && (E = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (E = "onCompositionStart");E && (u2 && t.locale !== "ko" && (ql || E !== "onCompositionStart" ? E === "onCompositionEnd" && ql && (R = l2()) : (wo = d, f1 = "value" in wo ? wo.value : wo.textContent, ql = !0)), B = Mm(c, E), 0 < B.length && (E = new yM(E, n, null, t, d), h.push({
                event: E,
                listeners: B
            }), R ? E.data = R : (R = f2(t), R !== null && (E.data = R)))),
            (R = XD ? QD(n, t) : KD(n, t)) && (c = Mm(c, "onBeforeInput"), 0 < c.length && (d = new yM("onBeforeInput", "beforeinput", null, t, d), h.push({
                event: d,
                listeners: c
            }), d.data = R))
        }
        S2(h, e)
    })
}

function Df(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}

function Mm(n, e) {
    for (var t = e + "Capture", i = []; n !== null;) {
        var r = n,
            s = r.stateNode;
        r.tag === 5 && s !== null && (r = s, s = bf(n, t), s != null && i.unshift(Df(n, s, r)), s = bf(n, e), s != null && i.push(Df(n, s, r))), n = n.return
    }
    return i
}

function Tl(n) {
    if (n === null) return null;
    do n = n.return; while (n && n.tag !== 5);
    return n || null
}

function BM(n, e, t, i, r) {
    for (var s = e._reactName, o = []; t !== null && t !== i;) {
        var a = t,
            l = a.alternate,
            c = a.stateNode;
        if (l !== null && l === i) break;
        a.tag === 5 && c !== null && (a = c, r ? (l = bf(t, s), l != null && o.unshift(Df(t, l, a))) : r || (l = bf(t, s), l != null && o.push(Df(t, l, a)))), t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var uF = /\r\n?/g,
    cF = /\u0000|\uFFFD/g;

function PM(n) {
    return (typeof n == "string" ? n : "" + n).replace(uF, `
`).replace(cF, "")
}

function Jh(n, e, t) {
    if (e = PM(e), PM(n) !== e && t) throw Error(Me(425))
}

function Cm() {}
var iA = null,
    rA = null;

function sA(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var oA = typeof setTimeout == "function" ? setTimeout : void 0,
    fF = typeof clearTimeout == "function" ? clearTimeout : void 0,
    RM = typeof Promise == "function" ? Promise : void 0,
    dF = typeof queueMicrotask == "function" ? queueMicrotask : typeof RM < "u" ? function(n) {
        return RM.resolve(null).then(n).catch(hF)
    } : oA;

function hF(n) {
    setTimeout(function() {
        throw n
    })
}

function vy(n, e) {
    var t = e,
        i = 0;
    do {
        var r = t.nextSibling;
        if (n.removeChild(t), r && r.nodeType === 8)
            if (t = r.data, t === "/$") {
                if (i === 0) {
                    n.removeChild(r), Pf(e);
                    return
                }
                i--
            } else t !== "$" && t !== "$?" && t !== "$!" || i++;
        t = r
    } while (t);
    Pf(e)
}

function Po(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3) break;
        if (e === 8) {
            if (e = n.data, e === "$" || e === "$!" || e === "$?") break;
            if (e === "/$") return null
        }
    }
    return n
}

function IM(n) {
    n = n.previousSibling;
    for (var e = 0; n;) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0) return n;
                e--
            } else t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var ju = Math.random().toString(36).slice(2),
    qr = "__reactFiber$" + ju,
    Ff = "__reactProps$" + ju,
    zs = "__reactContainer$" + ju,
    aA = "__reactEvents$" + ju,
    pF = "__reactListeners$" + ju,
    mF = "__reactHandles$" + ju;

function Ia(n) {
    var e = n[qr];
    if (e) return e;
    for (var t = n.parentNode; t;) {
        if (e = t[zs] || t[qr]) {
            if (t = e.alternate, e.child !== null || t !== null && t.child !== null)
                for (n = IM(n); n !== null;) {
                    if (t = n[qr]) return t;
                    n = IM(n)
                }
            return e
        }
        n = t, t = n.parentNode
    }
    return null
}

function hd(n) {
    return n = n[qr] || n[zs], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}

function tu(n) {
    if (n.tag === 5 || n.tag === 6) return n.stateNode;
    throw Error(Me(33))
}

function fg(n) {
    return n[Ff] || null
}
var lA = [],
    nu = -1;

function Qo(n) {
    return {
        current: n
    }
}

function jt(n) {
    0 > nu || (n.current = lA[nu], lA[nu] = null, nu--)
}

function Ht(n, e) {
    nu++, lA[nu] = n.current, n.current = e
}
var Uo = {},
    $n = Qo(Uo),
    wi = Qo(!1),
    Za = Uo;

function Cu(n, e) {
    var t = n.type.contextTypes;
    if (!t) return Uo;
    var i = n.stateNode;
    if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext;
    var r = {},
        s;
    for (s in t) r[s] = e[s];
    return i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = r), r
}

function Si(n) {
    return n = n.childContextTypes, n != null
}

function Em() {
    jt(wi), jt($n)
}

function LM(n, e, t) {
    if ($n.current !== Uo) throw Error(Me(168));
    Ht($n, e), Ht(wi, t)
}

function C2(n, e, t) {
    var i = n.stateNode;
    if (e = e.childContextTypes, typeof i.getChildContext != "function") return t;
    i = i.getChildContext();
    for (var r in i)
        if (!(r in e)) throw Error(Me(108, $L(n) || "Unknown", r));
    return sn({}, t, i)
}

function bm(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Uo, Za = $n.current, Ht($n, n), Ht(wi, wi.current), !0
}

function DM(n, e, t) {
    var i = n.stateNode;
    if (!i) throw Error(Me(169));
    t ? (n = C2(n, e, Za), i.__reactInternalMemoizedMergedChildContext = n, jt(wi), jt($n), Ht($n, n)) : jt(wi), Ht(wi, t)
}
var Es = null,
    dg = !1,
    Ay = !1;

function E2(n) {
    Es === null ? Es = [n] : Es.push(n)
}

function gF(n) {
    dg = !0, E2(n)
}

function Ko() {
    if (!Ay && Es !== null) {
        Ay = !0;
        var n = 0,
            e = Nt;
        try {
            var t = Es;
            for (Nt = 1; n < t.length; n++) {
                var i = t[n];
                do i = i(!0); while (i !== null)
            }
            Es = null, dg = !1
        } catch (r) {
            throw Es !== null && (Es = Es.slice(n + 1)), ZT(a1, Ko), r
        } finally {
            Nt = e, Ay = !1
        }
    }
    return null
}
var iu = [],
    ru = 0,
    Tm = null,
    Bm = 0,
    lr = [],
    ur = 0,
    qa = null,
    Bs = 1,
    Ps = "";

function wa(n, e) {
    iu[ru++] = Bm, iu[ru++] = Tm, Tm = n, Bm = e
}

function b2(n, e, t) {
    lr[ur++] = Bs, lr[ur++] = Ps, lr[ur++] = qa, qa = n;
    var i = Bs;
    n = Ps;
    var r = 32 - Ir(i) - 1;
    i &= ~(1 << r), t += 1;
    var s = 32 - Ir(e) + r;
    if (30 < s) {
        var o = r - r % 5;
        s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, Bs = 1 << 32 - Ir(e) + r | t << r | i, Ps = s + n
    } else Bs = 1 << s | t << r | i, Ps = n
}

function g1(n) {
    n.return !== null && (wa(n, 1), b2(n, 1, 0))
}

function y1(n) {
    for (; n === Tm;) Tm = iu[--ru], iu[ru] = null, Bm = iu[--ru], iu[ru] = null;
    for (; n === qa;) qa = lr[--ur], lr[ur] = null, Ps = lr[--ur], lr[ur] = null, Bs = lr[--ur], lr[ur] = null
}
var Oi = null,
    ki = null,
    Kt = !1,
    Br = null;

function T2(n, e) {
    var t = fr(5, null, null, 0);
    t.elementType = "DELETED", t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t)
}

function FM(n, e) {
    switch (n.tag) {
        case 5:
            var t = n.type;
            return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, Oi = n, ki = Po(e.firstChild), !0) : !1;
        case 6:
            return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, Oi = n, ki = null, !0) : !1;
        case 13:
            return e = e.nodeType !== 8 ? null : e, e !== null ? (t = qa !== null ? {
                id: Bs,
                overflow: Ps
            } : null, n.memoizedState = {
                dehydrated: e,
                treeContext: t,
                retryLane: 1073741824
            }, t = fr(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, Oi = n, ki = null, !0) : !1;
        default:
            return !1
    }
}

function uA(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}

function cA(n) {
    if (Kt) {
        var e = ki;
        if (e) {
            var t = e;
            if (!FM(n, e)) {
                if (uA(n)) throw Error(Me(418));
                e = Po(t.nextSibling);
                var i = Oi;
                e && FM(n, e) ? T2(i, t) : (n.flags = n.flags & -4097 | 2, Kt = !1, Oi = n)
            }
        } else {
            if (uA(n)) throw Error(Me(418));
            n.flags = n.flags & -4097 | 2, Kt = !1, Oi = n
        }
    }
}

function kM(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;) n = n.return;
    Oi = n
}

function Xh(n) {
    if (n !== Oi) return !1;
    if (!Kt) return kM(n), Kt = !0, !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== "head" && e !== "body" && !sA(n.type, n.memoizedProps)), e && (e = ki)) {
        if (uA(n)) throw B2(), Error(Me(418));
        for (; e;) T2(n, e), e = Po(e.nextSibling)
    }
    if (kM(n), n.tag === 13) {
        if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(Me(317));
        e: {
            for (n = n.nextSibling, e = 0; n;) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            ki = Po(n.nextSibling);
                            break e
                        }
                        e--
                    } else t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            ki = null
        }
    } else ki = Oi ? Po(n.stateNode.nextSibling) : null;
    return !0
}

function B2() {
    for (var n = ki; n;) n = Po(n.nextSibling)
}

function Eu() {
    ki = Oi = null, Kt = !1
}

function v1(n) {
    Br === null ? Br = [n] : Br.push(n)
}
var yF = Js.ReactCurrentBatchConfig;

function Er(n, e) {
    if (n && n.defaultProps) {
        e = sn({}, e), n = n.defaultProps;
        for (var t in n) e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
var Pm = Qo(null),
    Rm = null,
    su = null,
    A1 = null;

function x1() {
    A1 = su = Rm = null
}

function _1(n) {
    var e = Pm.current;
    jt(Pm), n._currentValue = e
}

function fA(n, e, t) {
    for (; n !== null;) {
        var i = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), n === t) break;
        n = n.return
    }
}

function Au(n, e) {
    Rm = n, A1 = su = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (_i = !0), n.firstContext = null)
}

function mr(n) {
    var e = n._currentValue;
    if (A1 !== n)
        if (n = {
                context: n,
                memoizedValue: e,
                next: null
            }, su === null) {
            if (Rm === null) throw Error(Me(308));
            su = n, Rm.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else su = su.next = n;
    return e
}
var La = null;

function w1(n) {
    La === null ? La = [n] : La.push(n)
}

function P2(n, e, t, i) {
    var r = e.interleaved;
    return r === null ? (t.next = t, w1(e)) : (t.next = r.next, r.next = t), e.interleaved = t, Gs(n, i)
}

function Gs(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;) n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var go = !1;

function S1(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function R2(n, e) {
    n = n.updateQueue, e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}

function Fs(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function Ro(n, e, t) {
    var i = n.updateQueue;
    if (i === null) return null;
    if (i = i.shared, Pt & 2) {
        var r = i.pending;
        return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, Gs(n, t)
    }
    return r = i.interleaved, r === null ? (e.next = e, w1(i)) : (e.next = r.next, r.next = e), i.interleaved = e, Gs(n, t)
}

function qp(n, e, t) {
    if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) {
        var i = e.lanes;
        i &= n.pendingLanes, t |= i, e.lanes = t, l1(n, t)
    }
}

function NM(n, e) {
    var t = n.updateQueue,
        i = n.alternate;
    if (i !== null && (i = i.updateQueue, t === i)) {
        var r = null,
            s = null;
        if (t = t.firstBaseUpdate, t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? r = s = o : s = s.next = o, t = t.next
            } while (t !== null);
            s === null ? r = s = e : s = s.next = e
        } else r = s = e;
        t = {
            baseState: i.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: s,
            shared: i.shared,
            effects: i.effects
        }, n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e
}

function Im(n, e, t, i) {
    var r = n.updateQueue;
    go = !1;
    var s = r.firstBaseUpdate,
        o = r.lastBaseUpdate,
        a = r.shared.pending;
    if (a !== null) {
        r.shared.pending = null;
        var l = a,
            c = l.next;
        l.next = null, o === null ? s = c : o.next = c, o = l;
        var d = n.alternate;
        d !== null && (d = d.updateQueue, a = d.lastBaseUpdate, a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c, d.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = r.baseState;
        o = 0, d = c = l = null, a = s;
        do {
            var p = a.lane,
                m = a.eventTime;
            if ((i & p) === p) {
                d !== null && (d = d.next = {
                    eventTime: m,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var v = n,
                        y = a;
                    switch (p = e, m = t, y.tag) {
                        case 1:
                            if (v = y.payload, typeof v == "function") {
                                h = v.call(m, h, p);
                                break e
                            }
                            h = v;
                            break e;
                        case 3:
                            v.flags = v.flags & -65537 | 128;
                        case 0:
                            if (v = y.payload, p = typeof v == "function" ? v.call(m, h, p) : v, p == null) break e;
                            h = sn({}, h, p);
                            break e;
                        case 2:
                            go = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64, p = r.effects, p === null ? r.effects = [a] : p.push(a))
            } else m = {
                eventTime: m,
                lane: p,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
            }, d === null ? (c = d = m, l = h) : d = d.next = m, o |= p;
            if (a = a.next, a === null) {
                if (a = r.shared.pending, a === null) break;
                p = a, a = p.next, p.next = null, r.lastBaseUpdate = p, r.shared.pending = null
            }
        } while (1);
        if (d === null && (l = h), r.baseState = l, r.firstBaseUpdate = c, r.lastBaseUpdate = d, e = r.shared.interleaved, e !== null) {
            r = e;
            do o |= r.lane, r = r.next; while (r !== e)
        } else s === null && (r.shared.lanes = 0);
        el |= o, n.lanes = o, n.memoizedState = h
    }
}

function OM(n, e, t) {
    if (n = e.effects, e.effects = null, n !== null)
        for (e = 0; e < n.length; e++) {
            var i = n[e],
                r = i.callback;
            if (r !== null) {
                if (i.callback = null, i = t, typeof r != "function") throw Error(Me(191, r));
                r.call(i)
            }
        }
}
var I2 = new PT.Component().refs;

function dA(n, e, t, i) {
    e = n.memoizedState, t = t(i, e), t = t == null ? e : sn({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t)
}
var hg = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? al(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var i = ui(),
            r = Lo(n),
            s = Fs(i, r);
        s.payload = e, t != null && (s.callback = t), e = Ro(n, s, r), e !== null && (Lr(e, n, r, i), qp(e, n, r))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var i = ui(),
            r = Lo(n),
            s = Fs(i, r);
        s.tag = 1, s.payload = e, t != null && (s.callback = t), e = Ro(n, s, r), e !== null && (Lr(e, n, r, i), qp(e, n, r))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = ui(),
            i = Lo(n),
            r = Fs(t, i);
        r.tag = 2, e != null && (r.callback = e), e = Ro(n, r, i), e !== null && (Lr(e, n, i, t), qp(e, n, i))
    }
};

function UM(n, e, t, i, r, s, o) {
    return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !If(t, i) || !If(r, s) : !0
}

function L2(n, e, t) {
    var i = !1,
        r = Uo,
        s = e.contextType;
    return typeof s == "object" && s !== null ? s = mr(s) : (r = Si(e) ? Za : $n.current, i = e.contextTypes, s = (i = i != null) ? Cu(n, r) : Uo), e = new e(t, s), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = hg, n.stateNode = e, e._reactInternals = n, i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = r, n.__reactInternalMemoizedMaskedChildContext = s), e
}

function zM(n, e, t, i) {
    n = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== n && hg.enqueueReplaceState(e, e.state, null)
}

function hA(n, e, t, i) {
    var r = n.stateNode;
    r.props = t, r.state = n.memoizedState, r.refs = I2, S1(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? r.context = mr(s) : (s = Si(e) ? Za : $n.current, r.context = Cu(n, s)), r.state = n.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (dA(n, e, s, t), r.state = n.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && hg.enqueueReplaceState(r, r.state, null), Im(n, t, r, i), r.state = n.memoizedState), typeof r.componentDidMount == "function" && (n.flags |= 4194308)
}

function bc(n, e, t) {
    if (n = t.ref, n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner, t) {
                if (t.tag !== 1) throw Error(Me(309));
                var i = t.stateNode
            }
            if (!i) throw Error(Me(147, n));
            var r = i,
                s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = r.refs;
                a === I2 && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o
            }, e._stringRef = s, e)
        }
        if (typeof n != "string") throw Error(Me(284));
        if (!t._owner) throw Error(Me(290, n))
    }
    return n
}

function Qh(n, e) {
    throw n = Object.prototype.toString.call(e), Error(Me(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}

function GM(n) {
    var e = n._init;
    return e(n._payload)
}

function D2(n) {
    function e(x, _) {
        if (n) {
            var S = x.deletions;
            S === null ? (x.deletions = [_], x.flags |= 16) : S.push(_)
        }
    }

    function t(x, _) {
        if (!n) return null;
        for (; _ !== null;) e(x, _), _ = _.sibling;
        return null
    }

    function i(x, _) {
        for (x = new Map; _ !== null;) _.key !== null ? x.set(_.key, _) : x.set(_.index, _), _ = _.sibling;
        return x
    }

    function r(x, _) {
        return x = Do(x, _), x.index = 0, x.sibling = null, x
    }

    function s(x, _, S) {
        return x.index = S, n ? (S = x.alternate, S !== null ? (S = S.index, S < _ ? (x.flags |= 2, _) : S) : (x.flags |= 2, _)) : (x.flags |= 1048576, _)
    }

    function o(x) {
        return n && x.alternate === null && (x.flags |= 2), x
    }

    function a(x, _, S, M) {
        return _ === null || _.tag !== 6 ? (_ = Ey(S, x.mode, M), _.return = x, _) : (_ = r(_, S), _.return = x, _)
    }

    function l(x, _, S, M) {
        var b = S.type;
        return b === Zl ? d(x, _, S.props.children, M, S.key) : _ !== null && (_.elementType === b || typeof b == "object" && b !== null && b.$$typeof === mo && GM(b) === _.type) ? (M = r(_, S.props), M.ref = bc(x, _, S), M.return = x, M) : (M = rm(S.type, S.key, S.props, null, x.mode, M), M.ref = bc(x, _, S), M.return = x, M)
    }

    function c(x, _, S, M) {
        return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== S.containerInfo || _.stateNode.implementation !== S.implementation ? (_ = by(S, x.mode, M), _.return = x, _) : (_ = r(_, S.children || []), _.return = x, _)
    }

    function d(x, _, S, M, b) {
        return _ === null || _.tag !== 7 ? (_ = Va(S, x.mode, M, b), _.return = x, _) : (_ = r(_, S), _.return = x, _)
    }

    function h(x, _, S) {
        if (typeof _ == "string" && _ !== "" || typeof _ == "number") return _ = Ey("" + _, x.mode, S), _.return = x, _;
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
                case Nh:
                    return S = rm(_.type, _.key, _.props, null, x.mode, S), S.ref = bc(x, null, _), S.return = x, S;
                case Yl:
                    return _ = by(_, x.mode, S), _.return = x, _;
                case mo:
                    var M = _._init;
                    return h(x, M(_._payload), S)
            }
            if ($c(_) || wc(_)) return _ = Va(_, x.mode, S, null), _.return = x, _;
            Qh(x, _)
        }
        return null
    }

    function p(x, _, S, M) {
        var b = _ !== null ? _.key : null;
        if (typeof S == "string" && S !== "" || typeof S == "number") return b !== null ? null : a(x, _, "" + S, M);
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
                case Nh:
                    return S.key === b ? l(x, _, S, M) : null;
                case Yl:
                    return S.key === b ? c(x, _, S, M) : null;
                case mo:
                    return b = S._init, p(x, _, b(S._payload), M)
            }
            if ($c(S) || wc(S)) return b !== null ? null : d(x, _, S, M, null);
            Qh(x, S)
        }
        return null
    }

    function m(x, _, S, M, b) {
        if (typeof M == "string" && M !== "" || typeof M == "number") return x = x.get(S) || null, a(_, x, "" + M, b);
        if (typeof M == "object" && M !== null) {
            switch (M.$$typeof) {
                case Nh:
                    return x = x.get(M.key === null ? S : M.key) || null, l(_, x, M, b);
                case Yl:
                    return x = x.get(M.key === null ? S : M.key) || null, c(_, x, M, b);
                case mo:
                    var B = M._init;
                    return m(x, _, S, B(M._payload), b)
            }
            if ($c(M) || wc(M)) return x = x.get(S) || null, d(_, x, M, b, null);
            Qh(_, M)
        }
        return null
    }

    function v(x, _, S, M) {
        for (var b = null, B = null, R = _, E = _ = 0, P = null; R !== null && E < S.length; E++) {
            R.index > E ? (P = R, R = null) : P = R.sibling;
            var I = p(x, R, S[E], M);
            if (I === null) {
                R === null && (R = P);
                break
            }
            n && R && I.alternate === null && e(x, R), _ = s(I, _, E), B === null ? b = I : B.sibling = I, B = I, R = P
        }
        if (E === S.length) return t(x, R), Kt && wa(x, E), b;
        if (R === null) {
            for (; E < S.length; E++) R = h(x, S[E], M), R !== null && (_ = s(R, _, E), B === null ? b = R : B.sibling = R, B = R);
            return Kt && wa(x, E), b
        }
        for (R = i(x, R); E < S.length; E++) P = m(R, x, E, S[E], M), P !== null && (n && P.alternate !== null && R.delete(P.key === null ? E : P.key), _ = s(P, _, E), B === null ? b = P : B.sibling = P, B = P);
        return n && R.forEach(function(z) {
            return e(x, z)
        }), Kt && wa(x, E), b
    }

    function y(x, _, S, M) {
        var b = wc(S);
        if (typeof b != "function") throw Error(Me(150));
        if (S = b.call(S), S == null) throw Error(Me(151));
        for (var B = b = null, R = _, E = _ = 0, P = null, I = S.next(); R !== null && !I.done; E++, I = S.next()) {
            R.index > E ? (P = R, R = null) : P = R.sibling;
            var z = p(x, R, I.value, M);
            if (z === null) {
                R === null && (R = P);
                break
            }
            n && R && z.alternate === null && e(x, R), _ = s(z, _, E), B === null ? b = z : B.sibling = z, B = z, R = P
        }
        if (I.done) return t(x, R), Kt && wa(x, E), b;
        if (R === null) {
            for (; !I.done; E++, I = S.next()) I = h(x, I.value, M), I !== null && (_ = s(I, _, E), B === null ? b = I : B.sibling = I, B = I);
            return Kt && wa(x, E), b
        }
        for (R = i(x, R); !I.done; E++, I = S.next()) I = m(R, x, E, I.value, M), I !== null && (n && I.alternate !== null && R.delete(I.key === null ? E : I.key), _ = s(I, _, E), B === null ? b = I : B.sibling = I, B = I);
        return n && R.forEach(function(Z) {
            return e(x, Z)
        }), Kt && wa(x, E), b
    }

    function A(x, _, S, M) {
        if (typeof S == "object" && S !== null && S.type === Zl && S.key === null && (S = S.props.children), typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
                case Nh:
                    e: {
                        for (var b = S.key, B = _; B !== null;) {
                            if (B.key === b) {
                                if (b = S.type, b === Zl) {
                                    if (B.tag === 7) {
                                        t(x, B.sibling), _ = r(B, S.props.children), _.return = x, x = _;
                                        break e
                                    }
                                } else if (B.elementType === b || typeof b == "object" && b !== null && b.$$typeof === mo && GM(b) === B.type) {
                                    t(x, B.sibling), _ = r(B, S.props), _.ref = bc(x, B, S), _.return = x, x = _;
                                    break e
                                }
                                t(x, B);
                                break
                            } else e(x, B);
                            B = B.sibling
                        }
                        S.type === Zl ? (_ = Va(S.props.children, x.mode, M, S.key), _.return = x, x = _) : (M = rm(S.type, S.key, S.props, null, x.mode, M), M.ref = bc(x, _, S), M.return = x, x = M)
                    }
                    return o(x);
                case Yl:
                    e: {
                        for (B = S.key; _ !== null;) {
                            if (_.key === B)
                                if (_.tag === 4 && _.stateNode.containerInfo === S.containerInfo && _.stateNode.implementation === S.implementation) {
                                    t(x, _.sibling), _ = r(_, S.children || []), _.return = x, x = _;
                                    break e
                                } else {
                                    t(x, _);
                                    break
                                }
                            else e(x, _);
                            _ = _.sibling
                        }
                        _ = by(S, x.mode, M),
                        _.return = x,
                        x = _
                    }
                    return o(x);
                case mo:
                    return B = S._init, A(x, _, B(S._payload), M)
            }
            if ($c(S)) return v(x, _, S, M);
            if (wc(S)) return y(x, _, S, M);
            Qh(x, S)
        }
        return typeof S == "string" && S !== "" || typeof S == "number" ? (S = "" + S, _ !== null && _.tag === 6 ? (t(x, _.sibling), _ = r(_, S), _.return = x, x = _) : (t(x, _), _ = Ey(S, x.mode, M), _.return = x, x = _), o(x)) : t(x, _)
    }
    return A
}
var bu = D2(!0),
    F2 = D2(!1),
    pd = {},
    es = Qo(pd),
    kf = Qo(pd),
    Nf = Qo(pd);

function Da(n) {
    if (n === pd) throw Error(Me(174));
    return n
}

function M1(n, e) {
    switch (Ht(Nf, e), Ht(kf, n), Ht(es, pd), n = e.nodeType, n) {
        case 9:
        case 11:
            e = (e = e.documentElement) ? e.namespaceURI : jv(null, "");
            break;
        default:
            n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = jv(e, n)
    }
    jt(es), Ht(es, e)
}

function Tu() {
    jt(es), jt(kf), jt(Nf)
}

function k2(n) {
    Da(Nf.current);
    var e = Da(es.current),
        t = jv(e, n.type);
    e !== t && (Ht(kf, n), Ht(es, t))
}

function C1(n) {
    kf.current === n && (jt(es), jt(kf))
}
var $t = Qo(0);

function Lm(n) {
    for (var e = n; e !== null;) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e
        } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue
        }
        if (e === n) break;
        for (; e.sibling === null;) {
            if (e.return === null || e.return === n) return null;
            e = e.return
        }
        e.sibling.return = e.return, e = e.sibling
    }
    return null
}
var xy = [];

function E1() {
    for (var n = 0; n < xy.length; n++) xy[n]._workInProgressVersionPrimary = null;
    xy.length = 0
}
var $p = Js.ReactCurrentDispatcher,
    _y = Js.ReactCurrentBatchConfig,
    $a = 0,
    rn = null,
    Cn = null,
    kn = null,
    Dm = !1,
    cf = !1,
    Of = 0,
    vF = 0;

function Qn() {
    throw Error(Me(321))
}

function b1(n, e) {
    if (e === null) return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!kr(n[t], e[t])) return !1;
    return !0
}

function T1(n, e, t, i, r, s) {
    if ($a = s, rn = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, $p.current = n === null || n.memoizedState === null ? wF : SF, n = t(i, r), cf) {
        s = 0;
        do {
            if (cf = !1, Of = 0, 25 <= s) throw Error(Me(301));
            s += 1, kn = Cn = null, e.updateQueue = null, $p.current = MF, n = t(i, r)
        } while (cf)
    }
    if ($p.current = Fm, e = Cn !== null && Cn.next !== null, $a = 0, kn = Cn = rn = null, Dm = !1, e) throw Error(Me(300));
    return n
}

function B1() {
    var n = Of !== 0;
    return Of = 0, n
}

function Yr() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return kn === null ? rn.memoizedState = kn = n : kn = kn.next = n, kn
}

function gr() {
    if (Cn === null) {
        var n = rn.alternate;
        n = n !== null ? n.memoizedState : null
    } else n = Cn.next;
    var e = kn === null ? rn.memoizedState : kn.next;
    if (e !== null) kn = e, Cn = n;
    else {
        if (n === null) throw Error(Me(310));
        Cn = n, n = {
            memoizedState: Cn.memoizedState,
            baseState: Cn.baseState,
            baseQueue: Cn.baseQueue,
            queue: Cn.queue,
            next: null
        }, kn === null ? rn.memoizedState = kn = n : kn = kn.next = n
    }
    return kn
}

function Uf(n, e) {
    return typeof e == "function" ? e(n) : e
}

function wy(n) {
    var e = gr(),
        t = e.queue;
    if (t === null) throw Error(Me(311));
    t.lastRenderedReducer = n;
    var i = Cn,
        r = i.baseQueue,
        s = t.pending;
    if (s !== null) {
        if (r !== null) {
            var o = r.next;
            r.next = s.next, s.next = o
        }
        i.baseQueue = r = s, t.pending = null
    }
    if (r !== null) {
        s = r.next, i = i.baseState;
        var a = o = null,
            l = null,
            c = s;
        do {
            var d = c.lane;
            if (($a & d) === d) l !== null && (l = l.next = {
                lane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
            }), i = c.hasEagerState ? c.eagerState : n(i, c.action);
            else {
                var h = {
                    lane: d,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h, o = i) : l = l.next = h, rn.lanes |= d, el |= d
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = i : l.next = a, kr(i, e.memoizedState) || (_i = !0), e.memoizedState = i, e.baseState = o, e.baseQueue = l, t.lastRenderedState = i
    }
    if (n = t.interleaved, n !== null) {
        r = n;
        do s = r.lane, rn.lanes |= s, el |= s, r = r.next; while (r !== n)
    } else r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}

function Sy(n) {
    var e = gr(),
        t = e.queue;
    if (t === null) throw Error(Me(311));
    t.lastRenderedReducer = n;
    var i = t.dispatch,
        r = t.pending,
        s = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var o = r = r.next;
        do s = n(s, o.action), o = o.next; while (o !== r);
        kr(s, e.memoizedState) || (_i = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s
    }
    return [s, i]
}

function N2() {}

function O2(n, e) {
    var t = rn,
        i = gr(),
        r = e(),
        s = !kr(i.memoizedState, r);
    if (s && (i.memoizedState = r, _i = !0), i = i.queue, P1(G2.bind(null, t, i, n), [n]), i.getSnapshot !== e || s || kn !== null && kn.memoizedState.tag & 1) {
        if (t.flags |= 2048, zf(9, z2.bind(null, t, i, r, e), void 0, null), Nn === null) throw Error(Me(349));
        $a & 30 || U2(t, e, r)
    }
    return r
}

function U2(n, e, t) {
    n.flags |= 16384, n = {
        getSnapshot: e,
        value: t
    }, e = rn.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, rn.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n))
}

function z2(n, e, t, i) {
    e.value = t, e.getSnapshot = i, H2(e) && V2(n)
}

function G2(n, e, t) {
    return t(function() {
        H2(e) && V2(n)
    })
}

function H2(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !kr(n, t)
    } catch {
        return !0
    }
}

function V2(n) {
    var e = Gs(n, 1);
    e !== null && Lr(e, n, 1, -1)
}

function HM(n) {
    var e = Yr();
    return typeof n == "function" && (n = n()), e.memoizedState = e.baseState = n, n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Uf,
        lastRenderedState: n
    }, e.queue = n, n = n.dispatch = _F.bind(null, rn, n), [e.memoizedState, n]
}

function zf(n, e, t, i) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: i,
        next: null
    }, e = rn.updateQueue, e === null ? (e = {
        lastEffect: null,
        stores: null
    }, rn.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (i = t.next, t.next = n, n.next = i, e.lastEffect = n)), n
}

function W2() {
    return gr().memoizedState
}

function em(n, e, t, i) {
    var r = Yr();
    rn.flags |= n, r.memoizedState = zf(1 | e, t, void 0, i === void 0 ? null : i)
}

function pg(n, e, t, i) {
    var r = gr();
    i = i === void 0 ? null : i;
    var s = void 0;
    if (Cn !== null) {
        var o = Cn.memoizedState;
        if (s = o.destroy, i !== null && b1(i, o.deps)) {
            r.memoizedState = zf(e, t, s, i);
            return
        }
    }
    rn.flags |= n, r.memoizedState = zf(1 | e, t, s, i)
}

function VM(n, e) {
    return em(8390656, 8, n, e)
}

function P1(n, e) {
    return pg(2048, 8, n, e)
}

function j2(n, e) {
    return pg(4, 2, n, e)
}

function J2(n, e) {
    return pg(4, 4, n, e)
}

function X2(n, e) {
    if (typeof e == "function") return n = n(), e(n),
        function() {
            e(null)
        };
    if (e != null) return n = n(), e.current = n,
        function() {
            e.current = null
        }
}

function Q2(n, e, t) {
    return t = t != null ? t.concat([n]) : null, pg(4, 4, X2.bind(null, e, n), t)
}

function R1() {}

function K2(n, e) {
    var t = gr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && b1(e, i[1]) ? i[0] : (t.memoizedState = [n, e], n)
}

function Y2(n, e) {
    var t = gr();
    e = e === void 0 ? null : e;
    var i = t.memoizedState;
    return i !== null && e !== null && b1(e, i[1]) ? i[0] : (n = n(), t.memoizedState = [n, e], n)
}

function Z2(n, e, t) {
    return $a & 21 ? (kr(t, e) || (t = e2(), rn.lanes |= t, el |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, _i = !0), n.memoizedState = t)
}

function AF(n, e) {
    var t = Nt;
    Nt = t !== 0 && 4 > t ? t : 4, n(!0);
    var i = _y.transition;
    _y.transition = {};
    try {
        n(!1), e()
    } finally {
        Nt = t, _y.transition = i
    }
}

function q2() {
    return gr().memoizedState
}

function xF(n, e, t) {
    var i = Lo(n);
    if (t = {
            lane: i,
            action: t,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, $2(n)) eB(e, t);
    else if (t = P2(n, e, t, i), t !== null) {
        var r = ui();
        Lr(t, n, i, r), tB(t, e, i)
    }
}

function _F(n, e, t) {
    var i = Lo(n),
        r = {
            lane: i,
            action: t,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if ($2(n)) eB(e, r);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
            var o = e.lastRenderedState,
                a = s(o, t);
            if (r.hasEagerState = !0, r.eagerState = a, kr(a, o)) {
                var l = e.interleaved;
                l === null ? (r.next = r, w1(e)) : (r.next = l.next, l.next = r), e.interleaved = r;
                return
            }
        } catch {} finally {}
        t = P2(n, e, r, i), t !== null && (r = ui(), Lr(t, n, i, r), tB(t, e, i))
    }
}

function $2(n) {
    var e = n.alternate;
    return n === rn || e !== null && e === rn
}

function eB(n, e) {
    cf = Dm = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e
}

function tB(n, e, t) {
    if (t & 4194240) {
        var i = e.lanes;
        i &= n.pendingLanes, t |= i, e.lanes = t, l1(n, t)
    }
}
var Fm = {
        readContext: mr,
        useCallback: Qn,
        useContext: Qn,
        useEffect: Qn,
        useImperativeHandle: Qn,
        useInsertionEffect: Qn,
        useLayoutEffect: Qn,
        useMemo: Qn,
        useReducer: Qn,
        useRef: Qn,
        useState: Qn,
        useDebugValue: Qn,
        useDeferredValue: Qn,
        useTransition: Qn,
        useMutableSource: Qn,
        useSyncExternalStore: Qn,
        useId: Qn,
        unstable_isNewReconciler: !1
    },
    wF = {
        readContext: mr,
        useCallback: function(n, e) {
            return Yr().memoizedState = [n, e === void 0 ? null : e], n
        },
        useContext: mr,
        useEffect: VM,
        useImperativeHandle: function(n, e, t) {
            return t = t != null ? t.concat([n]) : null, em(4194308, 4, X2.bind(null, e, n), t)
        },
        useLayoutEffect: function(n, e) {
            return em(4194308, 4, n, e)
        },
        useInsertionEffect: function(n, e) {
            return em(4, 2, n, e)
        },
        useMemo: function(n, e) {
            var t = Yr();
            return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n
        },
        useReducer: function(n, e, t) {
            var i = Yr();
            return e = t !== void 0 ? t(e) : e, i.memoizedState = i.baseState = e, n = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: n,
                lastRenderedState: e
            }, i.queue = n, n = n.dispatch = xF.bind(null, rn, n), [i.memoizedState, n]
        },
        useRef: function(n) {
            var e = Yr();
            return n = {
                current: n
            }, e.memoizedState = n
        },
        useState: HM,
        useDebugValue: R1,
        useDeferredValue: function(n) {
            return Yr().memoizedState = n
        },
        useTransition: function() {
            var n = HM(!1),
                e = n[0];
            return n = AF.bind(null, n[1]), Yr().memoizedState = n, [e, n]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(n, e, t) {
            var i = rn,
                r = Yr();
            if (Kt) {
                if (t === void 0) throw Error(Me(407));
                t = t()
            } else {
                if (t = e(), Nn === null) throw Error(Me(349));
                $a & 30 || U2(i, e, t)
            }
            r.memoizedState = t;
            var s = {
                value: t,
                getSnapshot: e
            };
            return r.queue = s, VM(G2.bind(null, i, s, n), [n]), i.flags |= 2048, zf(9, z2.bind(null, i, s, t, e), void 0, null), t
        },
        useId: function() {
            var n = Yr(),
                e = Nn.identifierPrefix;
            if (Kt) {
                var t = Ps,
                    i = Bs;
                t = (i & ~(1 << 32 - Ir(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = Of++, 0 < t && (e += "H" + t.toString(32)), e += ":"
            } else t = vF++, e = ":" + e + "r" + t.toString(32) + ":";
            return n.memoizedState = e
        },
        unstable_isNewReconciler: !1
    },
    SF = {
        readContext: mr,
        useCallback: K2,
        useContext: mr,
        useEffect: P1,
        useImperativeHandle: Q2,
        useInsertionEffect: j2,
        useLayoutEffect: J2,
        useMemo: Y2,
        useReducer: wy,
        useRef: W2,
        useState: function() {
            return wy(Uf)
        },
        useDebugValue: R1,
        useDeferredValue: function(n) {
            var e = gr();
            return Z2(e, Cn.memoizedState, n)
        },
        useTransition: function() {
            var n = wy(Uf)[0],
                e = gr().memoizedState;
            return [n, e]
        },
        useMutableSource: N2,
        useSyncExternalStore: O2,
        useId: q2,
        unstable_isNewReconciler: !1
    },
    MF = {
        readContext: mr,
        useCallback: K2,
        useContext: mr,
        useEffect: P1,
        useImperativeHandle: Q2,
        useInsertionEffect: j2,
        useLayoutEffect: J2,
        useMemo: Y2,
        useReducer: Sy,
        useRef: W2,
        useState: function() {
            return Sy(Uf)
        },
        useDebugValue: R1,
        useDeferredValue: function(n) {
            var e = gr();
            return Cn === null ? e.memoizedState = n : Z2(e, Cn.memoizedState, n)
        },
        useTransition: function() {
            var n = Sy(Uf)[0],
                e = gr().memoizedState;
            return [n, e]
        },
        useMutableSource: N2,
        useSyncExternalStore: O2,
        useId: q2,
        unstable_isNewReconciler: !1
    };

function Bu(n, e) {
    try {
        var t = "",
            i = e;
        do t += qL(i), i = i.return; while (i);
        var r = t
    } catch (s) {
        r = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: r,
        digest: null
    }
}

function My(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}

function pA(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var CF = typeof WeakMap == "function" ? WeakMap : Map;

function nB(n, e, t) {
    t = Fs(-1, t), t.tag = 3, t.payload = {
        element: null
    };
    var i = e.value;
    return t.callback = function() {
        Nm || (Nm = !0, MA = i), pA(n, e)
    }, t
}

function iB(n, e, t) {
    t = Fs(-1, t), t.tag = 3;
    var i = n.type.getDerivedStateFromError;
    if (typeof i == "function") {
        var r = e.value;
        t.payload = function() {
            return i(r)
        }, t.callback = function() {
            pA(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        pA(n, e), typeof i != "function" && (Io === null ? Io = new Set([this]) : Io.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }), t
}

function WM(n, e, t) {
    var i = n.pingCache;
    if (i === null) {
        i = n.pingCache = new CF;
        var r = new Set;
        i.set(e, r)
    } else r = i.get(e), r === void 0 && (r = new Set, i.set(e, r));
    r.has(t) || (r.add(t), n = UF.bind(null, n, e, t), e.then(n, n))
}

function jM(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return n;
        n = n.return
    } while (n !== null);
    return null
}

function JM(n, e, t, i, r) {
    return n.mode & 1 ? (n.flags |= 65536, n.lanes = r, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Fs(-1, 1), e.tag = 2, Ro(t, e, 1))), t.lanes |= 1), n)
}
var EF = Js.ReactCurrentOwner,
    _i = !1;

function ai(n, e, t, i) {
    e.child = n === null ? F2(e, null, t, i) : bu(e, n.child, t, i)
}

function XM(n, e, t, i, r) {
    t = t.render;
    var s = e.ref;
    return Au(e, r), i = T1(n, e, t, i, s, r), t = B1(), n !== null && !_i ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Hs(n, e, r)) : (Kt && t && g1(e), e.flags |= 1, ai(n, e, i, r), e.child)
}

function QM(n, e, t, i, r) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !U1(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, rB(n, e, s, i, r)) : (n = rm(t.type, null, i, e, e.mode, r), n.ref = e.ref, n.return = e, e.child = n)
    }
    if (s = n.child, !(n.lanes & r)) {
        var o = s.memoizedProps;
        if (t = t.compare, t = t !== null ? t : If, t(o, i) && n.ref === e.ref) return Hs(n, e, r)
    }
    return e.flags |= 1, n = Do(s, i), n.ref = e.ref, n.return = e, e.child = n
}

function rB(n, e, t, i, r) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (If(s, i) && n.ref === e.ref)
            if (_i = !1, e.pendingProps = i = s, (n.lanes & r) !== 0) n.flags & 131072 && (_i = !0);
            else return e.lanes = n.lanes, Hs(n, e, r)
    }
    return mA(n, e, t, i, r)
}

function sB(n, e, t) {
    var i = e.pendingProps,
        r = i.children,
        s = n !== null ? n.memoizedState : null;
    if (i.mode === "hidden")
        if (!(e.mode & 1)) e.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, Ht(au, Di), Di |= t;
        else {
            if (!(t & 1073741824)) return n = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
                baseLanes: n,
                cachePool: null,
                transitions: null
            }, e.updateQueue = null, Ht(au, Di), Di |= n, null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, i = s !== null ? s.baseLanes : t, Ht(au, Di), Di |= i
        }
    else s !== null ? (i = s.baseLanes | t, e.memoizedState = null) : i = t, Ht(au, Di), Di |= i;
    return ai(n, e, r, t), e.child
}

function oB(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152)
}

function mA(n, e, t, i, r) {
    var s = Si(t) ? Za : $n.current;
    return s = Cu(e, s), Au(e, r), t = T1(n, e, t, i, s, r), i = B1(), n !== null && !_i ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Hs(n, e, r)) : (Kt && i && g1(e), e.flags |= 1, ai(n, e, t, r), e.child)
}

function KM(n, e, t, i, r) {
    if (Si(t)) {
        var s = !0;
        bm(e)
    } else s = !1;
    if (Au(e, r), e.stateNode === null) tm(n, e), L2(e, t, i), hA(e, t, i, r), i = !0;
    else if (n === null) {
        var o = e.stateNode,
            a = e.memoizedProps;
        o.props = a;
        var l = o.context,
            c = t.contextType;
        typeof c == "object" && c !== null ? c = mr(c) : (c = Si(t) ? Za : $n.current, c = Cu(e, c));
        var d = t.getDerivedStateFromProps,
            h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && zM(e, o, i, c), go = !1;
        var p = e.memoizedState;
        o.state = p, Im(e, i, o, r), l = e.memoizedState, a !== i || p !== l || wi.current || go ? (typeof d == "function" && (dA(e, t, d, i), l = e.memoizedState), (a = go || UM(e, t, a, i, p, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = l), o.props = i, o.state = l, o.context = c, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = !1)
    } else {
        o = e.stateNode, R2(n, e), a = e.memoizedProps, c = e.type === e.elementType ? a : Er(e.type, a), o.props = c, h = e.pendingProps, p = o.context, l = t.contextType, typeof l == "object" && l !== null ? l = mr(l) : (l = Si(t) ? Za : $n.current, l = Cu(e, l));
        var m = t.getDerivedStateFromProps;
        (d = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || p !== l) && zM(e, o, i, l), go = !1, p = e.memoizedState, o.state = p, Im(e, i, o, r);
        var v = e.memoizedState;
        a !== h || p !== v || wi.current || go ? (typeof m == "function" && (dA(e, t, m, i), v = e.memoizedState), (c = go || UM(e, t, c, i, p, v, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, v, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, v, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = v), o.props = i, o.state = v, o.context = l, i = c) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), i = !1)
    }
    return gA(n, e, t, i, s, r)
}

function gA(n, e, t, i, r, s) {
    oB(n, e);
    var o = (e.flags & 128) !== 0;
    if (!i && !o) return r && DM(e, t, !1), Hs(n, e, s);
    i = e.stateNode, EF.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
    return e.flags |= 1, n !== null && o ? (e.child = bu(e, n.child, null, s), e.child = bu(e, null, a, s)) : ai(n, e, a, s), e.memoizedState = i.state, r && DM(e, t, !0), e.child
}

function aB(n) {
    var e = n.stateNode;
    e.pendingContext ? LM(n, e.pendingContext, e.pendingContext !== e.context) : e.context && LM(n, e.context, !1), M1(n, e.containerInfo)
}

function YM(n, e, t, i, r) {
    return Eu(), v1(r), e.flags |= 256, ai(n, e, t, i), e.child
}
var yA = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function vA(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}

function lB(n, e, t) {
    var i = e.pendingProps,
        r = $t.current,
        s = !1,
        o = (e.flags & 128) !== 0,
        a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1), Ht($t, r & 1), n === null) return cA(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, n = i.fallback, s ? (i = e.mode, s = e.child, o = {
        mode: "hidden",
        children: o
    }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = yg(o, i, 0, null), n = Va(n, i, t, null), s.return = e, n.return = e, s.sibling = n, e.child = s, e.child.memoizedState = vA(t), e.memoizedState = yA, n) : I1(e, o));
    if (r = n.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return bF(n, e, o, i, a, r, t);
    if (s) {
        s = i.fallback, o = e.mode, r = n.child, a = r.sibling;
        var l = {
            mode: "hidden",
            children: i.children
        };
        return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = l, e.deletions = null) : (i = Do(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = Do(a, s) : (s = Va(s, o, t, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = n.child.memoizedState, o = o === null ? vA(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        }, s.memoizedState = o, s.childLanes = n.childLanes & ~t, e.memoizedState = yA, i
    }
    return s = n.child, n = s.sibling, i = Do(s, {
        mode: "visible",
        children: i.children
    }), !(e.mode & 1) && (i.lanes = t), i.return = e, i.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = i, e.memoizedState = null, i
}

function I1(n, e) {
    return e = yg({
        mode: "visible",
        children: e
    }, n.mode, 0, null), e.return = n, n.child = e
}

function Kh(n, e, t, i) {
    return i !== null && v1(i), bu(e, n.child, null, t), n = I1(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n
}

function bF(n, e, t, i, r, s, o) {
    if (t) return e.flags & 256 ? (e.flags &= -257, i = My(Error(Me(422))), Kh(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = yg({
        mode: "visible",
        children: i.children
    }, r, 0, null), s = Va(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && bu(e, n.child, null, o), e.child.memoizedState = vA(o), e.memoizedState = yA, s);
    if (!(e.mode & 1)) return Kh(n, e, o, null);
    if (r.data === "$!") {
        if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst;
        return i = a, s = Error(Me(419)), i = My(s, i, void 0), Kh(n, e, o, i)
    }
    if (a = (o & n.childLanes) !== 0, _i || a) {
        if (i = Nn, i !== null) {
            switch (o & -o) {
                case 4:
                    r = 2;
                    break;
                case 16:
                    r = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    r = 32;
                    break;
                case 536870912:
                    r = 268435456;
                    break;
                default:
                    r = 0
            }
            r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Gs(n, r), Lr(i, n, r, -1))
        }
        return O1(), i = My(Error(Me(421))), Kh(n, e, o, i)
    }
    return r.data === "$?" ? (e.flags |= 128, e.child = n.child, e = zF.bind(null, n), r._reactRetry = e, null) : (n = s.treeContext, ki = Po(r.nextSibling), Oi = e, Kt = !0, Br = null, n !== null && (lr[ur++] = Bs, lr[ur++] = Ps, lr[ur++] = qa, Bs = n.id, Ps = n.overflow, qa = e), e = I1(e, i.children), e.flags |= 4096, e)
}

function ZM(n, e, t) {
    n.lanes |= e;
    var i = n.alternate;
    i !== null && (i.lanes |= e), fA(n.return, e, t)
}

function Cy(n, e, t, i, r) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r
    } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = t, s.tailMode = r)
}

function uB(n, e, t) {
    var i = e.pendingProps,
        r = i.revealOrder,
        s = i.tail;
    if (ai(n, e, i.children, t), i = $t.current, i & 2) i = i & 1 | 2, e.flags |= 128;
    else {
        if (n !== null && n.flags & 128) e: for (n = e.child; n !== null;) {
            if (n.tag === 13) n.memoizedState !== null && ZM(n, t, e);
            else if (n.tag === 19) ZM(n, t, e);
            else if (n.child !== null) {
                n.child.return = n, n = n.child;
                continue
            }
            if (n === e) break e;
            for (; n.sibling === null;) {
                if (n.return === null || n.return === e) break e;
                n = n.return
            }
            n.sibling.return = n.return, n = n.sibling
        }
        i &= 1
    }
    if (Ht($t, i), !(e.mode & 1)) e.memoizedState = null;
    else switch (r) {
        case "forwards":
            for (t = e.child, r = null; t !== null;) n = t.alternate, n !== null && Lm(n) === null && (r = t), t = t.sibling;
            t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), Cy(e, !1, r, t, s);
            break;
        case "backwards":
            for (t = null, r = e.child, e.child = null; r !== null;) {
                if (n = r.alternate, n !== null && Lm(n) === null) {
                    e.child = r;
                    break
                }
                n = r.sibling, r.sibling = t, t = r, r = n
            }
            Cy(e, !0, t, null, s);
            break;
        case "together":
            Cy(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
    }
    return e.child
}

function tm(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2)
}

function Hs(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies), el |= e.lanes, !(t & e.childLanes)) return null;
    if (n !== null && e.child !== n.child) throw Error(Me(153));
    if (e.child !== null) {
        for (n = e.child, t = Do(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null;) n = n.sibling, t = t.sibling = Do(n, n.pendingProps), t.return = e;
        t.sibling = null
    }
    return e.child
}

function TF(n, e, t) {
    switch (e.tag) {
        case 3:
            aB(e), Eu();
            break;
        case 5:
            k2(e);
            break;
        case 1:
            Si(e.type) && bm(e);
            break;
        case 4:
            M1(e, e.stateNode.containerInfo);
            break;
        case 10:
            var i = e.type._context,
                r = e.memoizedProps.value;
            Ht(Pm, i._currentValue), i._currentValue = r;
            break;
        case 13:
            if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (Ht($t, $t.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? lB(n, e, t) : (Ht($t, $t.current & 1), n = Hs(n, e, t), n !== null ? n.sibling : null);
            Ht($t, $t.current & 1);
            break;
        case 19:
            if (i = (t & e.childLanes) !== 0, n.flags & 128) {
                if (i) return uB(n, e, t);
                e.flags |= 128
            }
            if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Ht($t, $t.current), i) break;
            return null;
        case 22:
        case 23:
            return e.lanes = 0, sB(n, e, t)
    }
    return Hs(n, e, t)
}
var cB, AA, fB, dB;
cB = function(n, e) {
    for (var t = e.child; t !== null;) {
        if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t, t = t.child;
            continue
        }
        if (t === e) break;
        for (; t.sibling === null;) {
            if (t.return === null || t.return === e) return;
            t = t.return
        }
        t.sibling.return = t.return, t = t.sibling
    }
};
AA = function() {};
fB = function(n, e, t, i) {
    var r = n.memoizedProps;
    if (r !== i) {
        n = e.stateNode, Da(es.current);
        var s = null;
        switch (t) {
            case "input":
                r = Gv(n, r), i = Gv(n, i), s = [];
                break;
            case "select":
                r = sn({}, r, {
                    value: void 0
                }), i = sn({}, i, {
                    value: void 0
                }), s = [];
                break;
            case "textarea":
                r = Wv(n, r), i = Wv(n, i), s = [];
                break;
            default:
                typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = Cm)
        }
        Jv(t, i);
        var o;
        t = null;
        for (c in r)
            if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
                if (c === "style") {
                    var a = r[c];
                    for (o in a) a.hasOwnProperty(o) && (t || (t = {}), t[o] = "")
                } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (Cf.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in i) {
            var l = i[c];
            if (a = r != null ? r[c] : void 0, i.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}), t[o] = "");
                        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}), t[o] = l[o])
                    } else t || (s || (s = []), s.push(c, t)), t = l;
            else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (Cf.hasOwnProperty(c) ? (l != null && c === "onScroll" && Wt("scroll", n), s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        t && (s = s || []).push("style", t);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
};
dB = function(n, e, t, i) {
    t !== i && (e.flags |= 4)
};

function Tc(n, e) {
    if (!Kt) switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null;) e.alternate !== null && (t = e), e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var i = null; t !== null;) t.alternate !== null && (i = t), t = t.sibling;
            i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null
    }
}

function Kn(n) {
    var e = n.alternate !== null && n.alternate.child === n.child,
        t = 0,
        i = 0;
    if (e)
        for (var r = n.child; r !== null;) t |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = n, r = r.sibling;
    else
        for (r = n.child; r !== null;) t |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = n, r = r.sibling;
    return n.subtreeFlags |= i, n.childLanes = t, e
}

function BF(n, e, t) {
    var i = e.pendingProps;
    switch (y1(e), e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Kn(e), null;
        case 1:
            return Si(e.type) && Em(), Kn(e), null;
        case 3:
            return i = e.stateNode, Tu(), jt(wi), jt($n), E1(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (n === null || n.child === null) && (Xh(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Br !== null && (bA(Br), Br = null))), AA(n, e), Kn(e), null;
        case 5:
            C1(e);
            var r = Da(Nf.current);
            if (t = e.type, n !== null && e.stateNode != null) fB(n, e, t, i, r), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
            else {
                if (!i) {
                    if (e.stateNode === null) throw Error(Me(166));
                    return Kn(e), null
                }
                if (n = Da(es.current), Xh(e)) {
                    i = e.stateNode, t = e.type;
                    var s = e.memoizedProps;
                    switch (i[qr] = e, i[Ff] = s, n = (e.mode & 1) !== 0, t) {
                        case "dialog":
                            Wt("cancel", i), Wt("close", i);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            Wt("load", i);
                            break;
                        case "video":
                        case "audio":
                            for (r = 0; r < tf.length; r++) Wt(tf[r], i);
                            break;
                        case "source":
                            Wt("error", i);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            Wt("error", i), Wt("load", i);
                            break;
                        case "details":
                            Wt("toggle", i);
                            break;
                        case "input":
                            oM(i, s), Wt("invalid", i);
                            break;
                        case "select":
                            i._wrapperState = {
                                wasMultiple: !!s.multiple
                            }, Wt("invalid", i);
                            break;
                        case "textarea":
                            lM(i, s), Wt("invalid", i)
                    }
                    Jv(t, s), r = null;
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Jh(i.textContent, a, n), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Jh(i.textContent, a, n), r = ["children", "" + a]) : Cf.hasOwnProperty(o) && a != null && o === "onScroll" && Wt("scroll", i)
                        } switch (t) {
                        case "input":
                            Oh(i), aM(i, s, !0);
                            break;
                        case "textarea":
                            Oh(i), uM(i);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof s.onClick == "function" && (i.onclick = Cm)
                    }
                    i = r, e.updateQueue = i, i !== null && (e.flags |= 4)
                } else {
                    o = r.nodeType === 9 ? r : r.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = UT(t)), n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, {
                        is: i.is
                    }) : (n = o.createElement(t), t === "select" && (o = n, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t), n[qr] = e, n[Ff] = i, cB(n, e, !1, !1), e.stateNode = n;
                    e: {
                        switch (o = Xv(t, i), t) {
                            case "dialog":
                                Wt("cancel", n), Wt("close", n), r = i;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                Wt("load", n), r = i;
                                break;
                            case "video":
                            case "audio":
                                for (r = 0; r < tf.length; r++) Wt(tf[r], n);
                                r = i;
                                break;
                            case "source":
                                Wt("error", n), r = i;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                Wt("error", n), Wt("load", n), r = i;
                                break;
                            case "details":
                                Wt("toggle", n), r = i;
                                break;
                            case "input":
                                oM(n, i), r = Gv(n, i), Wt("invalid", n);
                                break;
                            case "option":
                                r = i;
                                break;
                            case "select":
                                n._wrapperState = {
                                    wasMultiple: !!i.multiple
                                }, r = sn({}, i, {
                                    value: void 0
                                }), Wt("invalid", n);
                                break;
                            case "textarea":
                                lM(n, i), r = Wv(n, i), Wt("invalid", n);
                                break;
                            default:
                                r = i
                        }
                        Jv(t, r),
                        a = r;
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var l = a[s];
                                s === "style" ? HT(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && zT(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && Ef(n, l) : typeof l == "number" && Ef(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Cf.hasOwnProperty(s) ? l != null && s === "onScroll" && Wt("scroll", n) : l != null && n1(n, s, l, o))
                            } switch (t) {
                            case "input":
                                Oh(n), aM(n, i, !1);
                                break;
                            case "textarea":
                                Oh(n), uM(n);
                                break;
                            case "option":
                                i.value != null && n.setAttribute("value", "" + Oo(i.value));
                                break;
                            case "select":
                                n.multiple = !!i.multiple, s = i.value, s != null ? mu(n, !!i.multiple, s, !1) : i.defaultValue != null && mu(n, !!i.multiple, i.defaultValue, !0);
                                break;
                            default:
                                typeof r.onClick == "function" && (n.onclick = Cm)
                        }
                        switch (t) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                i = !!i.autoFocus;
                                break e;
                            case "img":
                                i = !0;
                                break e;
                            default:
                                i = !1
                        }
                    }
                    i && (e.flags |= 4)
                }
                e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
            }
            return Kn(e), null;
        case 6:
            if (n && e.stateNode != null) dB(n, e, n.memoizedProps, i);
            else {
                if (typeof i != "string" && e.stateNode === null) throw Error(Me(166));
                if (t = Da(Nf.current), Da(es.current), Xh(e)) {
                    if (i = e.stateNode, t = e.memoizedProps, i[qr] = e, (s = i.nodeValue !== t) && (n = Oi, n !== null)) switch (n.tag) {
                        case 3:
                            Jh(i.nodeValue, t, (n.mode & 1) !== 0);
                            break;
                        case 5:
                            n.memoizedProps.suppressHydrationWarning !== !0 && Jh(i.nodeValue, t, (n.mode & 1) !== 0)
                    }
                    s && (e.flags |= 4)
                } else i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[qr] = e, e.stateNode = i
            }
            return Kn(e), null;
        case 13:
            if (jt($t), i = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
                if (Kt && ki !== null && e.mode & 1 && !(e.flags & 128)) B2(), Eu(), e.flags |= 98560, s = !1;
                else if (s = Xh(e), i !== null && i.dehydrated !== null) {
                    if (n === null) {
                        if (!s) throw Error(Me(318));
                        if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Me(317));
                        s[qr] = e
                    } else Eu(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
                    Kn(e), s = !1
                } else Br !== null && (bA(Br), Br = null), s = !0;
                if (!s) return e.flags & 65536 ? e : null
            }
            return e.flags & 128 ? (e.lanes = t, e) : (i = i !== null, i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (n === null || $t.current & 1 ? En === 0 && (En = 3) : O1())), e.updateQueue !== null && (e.flags |= 4), Kn(e), null);
        case 4:
            return Tu(), AA(n, e), n === null && Lf(e.stateNode.containerInfo), Kn(e), null;
        case 10:
            return _1(e.type._context), Kn(e), null;
        case 17:
            return Si(e.type) && Em(), Kn(e), null;
        case 19:
            if (jt($t), s = e.memoizedState, s === null) return Kn(e), null;
            if (i = (e.flags & 128) !== 0, o = s.rendering, o === null)
                if (i) Tc(s, !1);
                else {
                    if (En !== 0 || n !== null && n.flags & 128)
                        for (n = e.child; n !== null;) {
                            if (o = Lm(n), o !== null) {
                                for (e.flags |= 128, Tc(s, !1), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = t, t = e.child; t !== null;) s = t, n = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n = o.dependencies, s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }), t = t.sibling;
                                return Ht($t, $t.current & 1 | 2), e.child
                            }
                            n = n.sibling
                        }
                    s.tail !== null && mn() > Pu && (e.flags |= 128, i = !0, Tc(s, !1), e.lanes = 4194304)
                }
            else {
                if (!i)
                    if (n = Lm(o), n !== null) {
                        if (e.flags |= 128, i = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Tc(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Kt) return Kn(e), null
                    } else 2 * mn() - s.renderingStartTime > Pu && t !== 1073741824 && (e.flags |= 128, i = !0, Tc(s, !1), e.lanes = 4194304);
                s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o)
            }
            return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = mn(), e.sibling = null, t = $t.current, Ht($t, i ? t & 1 | 2 : t & 1), e) : (Kn(e), null);
        case 22:
        case 23:
            return N1(), i = e.memoizedState !== null, n !== null && n.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? Di & 1073741824 && (Kn(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Kn(e), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(Me(156, e.tag))
}

function PF(n, e) {
    switch (y1(e), e.tag) {
        case 1:
            return Si(e.type) && Em(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null;
        case 3:
            return Tu(), jt(wi), jt($n), E1(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null;
        case 5:
            return C1(e), null;
        case 13:
            if (jt($t), n = e.memoizedState, n !== null && n.dehydrated !== null) {
                if (e.alternate === null) throw Error(Me(340));
                Eu()
            }
            return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null;
        case 19:
            return jt($t), null;
        case 4:
            return Tu(), null;
        case 10:
            return _1(e.type._context), null;
        case 22:
        case 23:
            return N1(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var Yh = !1,
    qn = !1,
    RF = typeof WeakSet == "function" ? WeakSet : Set,
    Ge = null;

function ou(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function") try {
            t(null)
        } catch (i) {
            cn(n, e, i)
        } else t.current = null
}

function xA(n, e, t) {
    try {
        t()
    } catch (i) {
        cn(n, e, i)
    }
}
var qM = !1;

function IF(n, e) {
    if (iA = wm, n = g2(), m1(n)) {
        if ("selectionStart" in n) var t = {
            start: n.selectionStart,
            end: n.selectionEnd
        };
        else e: {
            t = (t = n.ownerDocument) && t.defaultView || window;
            var i = t.getSelection && t.getSelection();
            if (i && i.rangeCount !== 0) {
                t = i.anchorNode;
                var r = i.anchorOffset,
                    s = i.focusNode;
                i = i.focusOffset;
                try {
                    t.nodeType, s.nodeType
                } catch {
                    t = null;
                    break e
                }
                var o = 0,
                    a = -1,
                    l = -1,
                    c = 0,
                    d = 0,
                    h = n,
                    p = null;
                t: for (;;) {
                    for (var m; h !== t || r !== 0 && h.nodeType !== 3 || (a = o + r), h !== s || i !== 0 && h.nodeType !== 3 || (l = o + i), h.nodeType === 3 && (o += h.nodeValue.length), (m = h.firstChild) !== null;) p = h, h = m;
                    for (;;) {
                        if (h === n) break t;
                        if (p === t && ++c === r && (a = o), p === s && ++d === i && (l = o), (m = h.nextSibling) !== null) break;
                        h = p, p = h.parentNode
                    }
                    h = m
                }
                t = a === -1 || l === -1 ? null : {
                    start: a,
                    end: l
                }
            } else t = null
        }
        t = t || {
            start: 0,
            end: 0
        }
    } else t = null;
    for (rA = {
            focusedElem: n,
            selectionRange: t
        }, wm = !1, Ge = e; Ge !== null;)
        if (e = Ge, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null) n.return = e, Ge = n;
        else
            for (; Ge !== null;) {
                e = Ge;
                try {
                    var v = e.alternate;
                    if (e.flags & 1024) switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (v !== null) {
                                var y = v.memoizedProps,
                                    A = v.memoizedState,
                                    x = e.stateNode,
                                    _ = x.getSnapshotBeforeUpdate(e.elementType === e.type ? y : Er(e.type, y), A);
                                x.__reactInternalSnapshotBeforeUpdate = _
                            }
                            break;
                        case 3:
                            var S = e.stateNode.containerInfo;
                            S.nodeType === 1 ? S.textContent = "" : S.nodeType === 9 && S.documentElement && S.removeChild(S.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Me(163))
                    }
                } catch (M) {
                    cn(e, e.return, M)
                }
                if (n = e.sibling, n !== null) {
                    n.return = e.return, Ge = n;
                    break
                }
                Ge = e.return
            }
    return v = qM, qM = !1, v
}

function ff(n, e, t) {
    var i = e.updateQueue;
    if (i = i !== null ? i.lastEffect : null, i !== null) {
        var r = i = i.next;
        do {
            if ((r.tag & n) === n) {
                var s = r.destroy;
                r.destroy = void 0, s !== void 0 && xA(e, t, s)
            }
            r = r.next
        } while (r !== i)
    }
}

function mg(n, e) {
    if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var i = t.create;
                t.destroy = i()
            }
            t = t.next
        } while (t !== e)
    }
}

function _A(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
            case 5:
                n = t;
                break;
            default:
                n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}

function hB(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null, hB(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[qr], delete e[Ff], delete e[aA], delete e[pF], delete e[mF])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null
}

function pB(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}

function $M(n) {
    e: for (;;) {
        for (; n.sibling === null;) {
            if (n.return === null || pB(n.return)) return null;
            n = n.return
        }
        for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) {
            if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
            n.child.return = n, n = n.child
        }
        if (!(n.flags & 2)) return n.stateNode
    }
}

function wA(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6) n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = Cm));
    else if (i !== 4 && (n = n.child, n !== null))
        for (wA(n, e, t), n = n.sibling; n !== null;) wA(n, e, t), n = n.sibling
}

function SA(n, e, t) {
    var i = n.tag;
    if (i === 5 || i === 6) n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (i !== 4 && (n = n.child, n !== null))
        for (SA(n, e, t), n = n.sibling; n !== null;) SA(n, e, t), n = n.sibling
}
var Un = null,
    br = !1;

function ro(n, e, t) {
    for (t = t.child; t !== null;) mB(n, e, t), t = t.sibling
}

function mB(n, e, t) {
    if ($r && typeof $r.onCommitFiberUnmount == "function") try {
        $r.onCommitFiberUnmount(ag, t)
    } catch {}
    switch (t.tag) {
        case 5:
            qn || ou(t, e);
        case 6:
            var i = Un,
                r = br;
            Un = null, ro(n, e, t), Un = i, br = r, Un !== null && (br ? (n = Un, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Un.removeChild(t.stateNode));
            break;
        case 18:
            Un !== null && (br ? (n = Un, t = t.stateNode, n.nodeType === 8 ? vy(n.parentNode, t) : n.nodeType === 1 && vy(n, t), Pf(n)) : vy(Un, t.stateNode));
            break;
        case 4:
            i = Un, r = br, Un = t.stateNode.containerInfo, br = !0, ro(n, e, t), Un = i, br = r;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!qn && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) {
                r = i = i.next;
                do {
                    var s = r,
                        o = s.destroy;
                    s = s.tag, o !== void 0 && (s & 2 || s & 4) && xA(t, e, o), r = r.next
                } while (r !== i)
            }
            ro(n, e, t);
            break;
        case 1:
            if (!qn && (ou(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function")) try {
                i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount()
            } catch (a) {
                cn(t, e, a)
            }
            ro(n, e, t);
            break;
        case 21:
            ro(n, e, t);
            break;
        case 22:
            t.mode & 1 ? (qn = (i = qn) || t.memoizedState !== null, ro(n, e, t), qn = i) : ro(n, e, t);
            break;
        default:
            ro(n, e, t)
    }
}

function eC(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new RF), e.forEach(function(i) {
            var r = GF.bind(null, n, i);
            t.has(i) || (t.add(i), i.then(r, r))
        })
    }
}

function wr(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var i = 0; i < t.length; i++) {
            var r = t[i];
            try {
                var s = n,
                    o = e,
                    a = o;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            Un = a.stateNode, br = !1;
                            break e;
                        case 3:
                            Un = a.stateNode.containerInfo, br = !0;
                            break e;
                        case 4:
                            Un = a.stateNode.containerInfo, br = !0;
                            break e
                    }
                    a = a.return
                }
                if (Un === null) throw Error(Me(160));
                mB(s, o, r), Un = null, br = !1;
                var l = r.alternate;
                l !== null && (l.return = null), r.return = null
            } catch (c) {
                cn(r, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null;) gB(e, n), e = e.sibling
}

function gB(n, e) {
    var t = n.alternate,
        i = n.flags;
    switch (n.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (wr(e, n), Kr(n), i & 4) {
                try {
                    ff(3, n, n.return), mg(3, n)
                } catch (y) {
                    cn(n, n.return, y)
                }
                try {
                    ff(5, n, n.return)
                } catch (y) {
                    cn(n, n.return, y)
                }
            }
            break;
        case 1:
            wr(e, n), Kr(n), i & 512 && t !== null && ou(t, t.return);
            break;
        case 5:
            if (wr(e, n), Kr(n), i & 512 && t !== null && ou(t, t.return), n.flags & 32) {
                var r = n.stateNode;
                try {
                    Ef(r, "")
                } catch (y) {
                    cn(n, n.return, y)
                }
            }
            if (i & 4 && (r = n.stateNode, r != null)) {
                var s = n.memoizedProps,
                    o = t !== null ? t.memoizedProps : s,
                    a = n.type,
                    l = n.updateQueue;
                if (n.updateQueue = null, l !== null) try {
                    a === "input" && s.type === "radio" && s.name != null && NT(r, s), Xv(a, o);
                    var c = Xv(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var d = l[o],
                            h = l[o + 1];
                        d === "style" ? HT(r, h) : d === "dangerouslySetInnerHTML" ? zT(r, h) : d === "children" ? Ef(r, h) : n1(r, d, h, c)
                    }
                    switch (a) {
                        case "input":
                            Hv(r, s);
                            break;
                        case "textarea":
                            OT(r, s);
                            break;
                        case "select":
                            var p = r._wrapperState.wasMultiple;
                            r._wrapperState.wasMultiple = !!s.multiple;
                            var m = s.value;
                            m != null ? mu(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? mu(r, !!s.multiple, s.defaultValue, !0) : mu(r, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    r[Ff] = s
                } catch (y) {
                    cn(n, n.return, y)
                }
            }
            break;
        case 6:
            if (wr(e, n), Kr(n), i & 4) {
                if (n.stateNode === null) throw Error(Me(162));
                r = n.stateNode, s = n.memoizedProps;
                try {
                    r.nodeValue = s
                } catch (y) {
                    cn(n, n.return, y)
                }
            }
            break;
        case 3:
            if (wr(e, n), Kr(n), i & 4 && t !== null && t.memoizedState.isDehydrated) try {
                Pf(e.containerInfo)
            } catch (y) {
                cn(n, n.return, y)
            }
            break;
        case 4:
            wr(e, n), Kr(n);
            break;
        case 13:
            wr(e, n), Kr(n), r = n.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (F1 = mn())), i & 4 && eC(n);
            break;
        case 22:
            if (d = t !== null && t.memoizedState !== null, n.mode & 1 ? (qn = (c = qn) || d, wr(e, n), qn = c) : wr(e, n), Kr(n), i & 8192) {
                if (c = n.memoizedState !== null, (n.stateNode.isHidden = c) && !d && n.mode & 1)
                    for (Ge = n, d = n.child; d !== null;) {
                        for (h = Ge = d; Ge !== null;) {
                            switch (p = Ge, m = p.child, p.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    ff(4, p, p.return);
                                    break;
                                case 1:
                                    ou(p, p.return);
                                    var v = p.stateNode;
                                    if (typeof v.componentWillUnmount == "function") {
                                        i = p, t = p.return;
                                        try {
                                            e = i, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount()
                                        } catch (y) {
                                            cn(i, t, y)
                                        }
                                    }
                                    break;
                                case 5:
                                    ou(p, p.return);
                                    break;
                                case 22:
                                    if (p.memoizedState !== null) {
                                        nC(h);
                                        continue
                                    }
                            }
                            m !== null ? (m.return = p, Ge = m) : nC(h)
                        }
                        d = d.sibling
                    }
                e: for (d = null, h = n;;) {
                    if (h.tag === 5) {
                        if (d === null) {
                            d = h;
                            try {
                                r = h.stateNode, c ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode, l = h.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = GT("display", o))
                            } catch (y) {
                                cn(n, n.return, y)
                            }
                        }
                    } else if (h.tag === 6) {
                        if (d === null) try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (y) {
                            cn(n, n.return, y)
                        }
                    } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === n) && h.child !== null) {
                        h.child.return = h, h = h.child;
                        continue
                    }
                    if (h === n) break e;
                    for (; h.sibling === null;) {
                        if (h.return === null || h.return === n) break e;
                        d === h && (d = null), h = h.return
                    }
                    d === h && (d = null), h.sibling.return = h.return, h = h.sibling
                }
            }
            break;
        case 19:
            wr(e, n), Kr(n), i & 4 && eC(n);
            break;
        case 21:
            break;
        default:
            wr(e, n), Kr(n)
    }
}

function Kr(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null;) {
                    if (pB(t)) {
                        var i = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(Me(160))
            }
            switch (i.tag) {
                case 5:
                    var r = i.stateNode;
                    i.flags & 32 && (Ef(r, ""), i.flags &= -33);
                    var s = $M(n);
                    SA(n, s, r);
                    break;
                case 3:
                case 4:
                    var o = i.stateNode.containerInfo,
                        a = $M(n);
                    wA(n, a, o);
                    break;
                default:
                    throw Error(Me(161))
            }
        }
        catch (l) {
            cn(n, n.return, l)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}

function LF(n, e, t) {
    Ge = n, yB(n)
}

function yB(n, e, t) {
    for (var i = (n.mode & 1) !== 0; Ge !== null;) {
        var r = Ge,
            s = r.child;
        if (r.tag === 22 && i) {
            var o = r.memoizedState !== null || Yh;
            if (!o) {
                var a = r.alternate,
                    l = a !== null && a.memoizedState !== null || qn;
                a = Yh;
                var c = qn;
                if (Yh = o, (qn = l) && !c)
                    for (Ge = r; Ge !== null;) o = Ge, l = o.child, o.tag === 22 && o.memoizedState !== null ? iC(r) : l !== null ? (l.return = o, Ge = l) : iC(r);
                for (; s !== null;) Ge = s, yB(s), s = s.sibling;
                Ge = r, Yh = a, qn = c
            }
            tC(n)
        } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, Ge = s) : tC(n)
    }
}

function tC(n) {
    for (; Ge !== null;) {
        var e = Ge;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772) switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        qn || mg(5, e);
                        break;
                    case 1:
                        var i = e.stateNode;
                        if (e.flags & 4 && !qn)
                            if (t === null) i.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? t.memoizedProps : Er(e.type, t.memoizedProps);
                                i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate)
                            } var s = e.updateQueue;
                        s !== null && OM(e, s, i);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null, e.child !== null) switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                            }
                            OM(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    l.autoFocus && t.focus();
                                    break;
                                case "img":
                                    l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var d = c.memoizedState;
                                if (d !== null) {
                                    var h = d.dehydrated;
                                    h !== null && Pf(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Me(163))
                }
                qn || e.flags & 512 && _A(e)
            } catch (p) {
                cn(e, e.return, p)
            }
        }
        if (e === n) {
            Ge = null;
            break
        }
        if (t = e.sibling, t !== null) {
            t.return = e.return, Ge = t;
            break
        }
        Ge = e.return
    }
}

function nC(n) {
    for (; Ge !== null;) {
        var e = Ge;
        if (e === n) {
            Ge = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return, Ge = t;
            break
        }
        Ge = e.return
    }
}

function iC(n) {
    for (; Ge !== null;) {
        var e = Ge;
        try {
            switch (e.tag) {
                case 0:
                case 11:
                case 15:
                    var t = e.return;
                    try {
                        mg(4, e)
                    } catch (l) {
                        cn(e, t, l)
                    }
                    break;
                case 1:
                    var i = e.stateNode;
                    if (typeof i.componentDidMount == "function") {
                        var r = e.return;
                        try {
                            i.componentDidMount()
                        } catch (l) {
                            cn(e, r, l)
                        }
                    }
                    var s = e.return;
                    try {
                        _A(e)
                    } catch (l) {
                        cn(e, s, l)
                    }
                    break;
                case 5:
                    var o = e.return;
                    try {
                        _A(e)
                    } catch (l) {
                        cn(e, o, l)
                    }
            }
        } catch (l) {
            cn(e, e.return, l)
        }
        if (e === n) {
            Ge = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return, Ge = a;
            break
        }
        Ge = e.return
    }
}
var DF = Math.ceil,
    km = Js.ReactCurrentDispatcher,
    L1 = Js.ReactCurrentOwner,
    dr = Js.ReactCurrentBatchConfig,
    Pt = 0,
    Nn = null,
    _n = null,
    Gn = 0,
    Di = 0,
    au = Qo(0),
    En = 0,
    Gf = null,
    el = 0,
    gg = 0,
    D1 = 0,
    df = null,
    Ai = null,
    F1 = 0,
    Pu = 1 / 0,
    Cs = null,
    Nm = !1,
    MA = null,
    Io = null,
    Zh = !1,
    So = null,
    Om = 0,
    hf = 0,
    CA = null,
    nm = -1,
    im = 0;

function ui() {
    return Pt & 6 ? mn() : nm !== -1 ? nm : nm = mn()
}

function Lo(n) {
    return n.mode & 1 ? Pt & 2 && Gn !== 0 ? Gn & -Gn : yF.transition !== null ? (im === 0 && (im = e2()), im) : (n = Nt, n !== 0 || (n = window.event, n = n === void 0 ? 16 : a2(n.type)), n) : 1
}

function Lr(n, e, t, i) {
    if (50 < hf) throw hf = 0, CA = null, Error(Me(185));
    fd(n, t, i), (!(Pt & 2) || n !== Nn) && (n === Nn && (!(Pt & 2) && (gg |= t), En === 4 && _o(n, Gn)), Mi(n, i), t === 1 && Pt === 0 && !(e.mode & 1) && (Pu = mn() + 500, dg && Ko()))
}

function Mi(n, e) {
    var t = n.callbackNode;
    yD(n, e);
    var i = _m(n, n === Nn ? Gn : 0);
    if (i === 0) t !== null && dM(t), n.callbackNode = null, n.callbackPriority = 0;
    else if (e = i & -i, n.callbackPriority !== e) {
        if (t != null && dM(t), e === 1) n.tag === 0 ? gF(rC.bind(null, n)) : E2(rC.bind(null, n)), dF(function() {
            !(Pt & 6) && Ko()
        }), t = null;
        else {
            switch (t2(i)) {
                case 1:
                    t = a1;
                    break;
                case 4:
                    t = qT;
                    break;
                case 16:
                    t = xm;
                    break;
                case 536870912:
                    t = $T;
                    break;
                default:
                    t = xm
            }
            t = CB(t, vB.bind(null, n))
        }
        n.callbackPriority = e, n.callbackNode = t
    }
}

function vB(n, e) {
    if (nm = -1, im = 0, Pt & 6) throw Error(Me(327));
    var t = n.callbackNode;
    if (xu() && n.callbackNode !== t) return null;
    var i = _m(n, n === Nn ? Gn : 0);
    if (i === 0) return null;
    if (i & 30 || i & n.expiredLanes || e) e = Um(n, i);
    else {
        e = i;
        var r = Pt;
        Pt |= 2;
        var s = xB();
        (Nn !== n || Gn !== e) && (Cs = null, Pu = mn() + 500, Ha(n, e));
        do try {
            NF();
            break
        } catch (a) {
            AB(n, a)
        }
        while (1);
        x1(), km.current = s, Pt = r, _n !== null ? e = 0 : (Nn = null, Gn = 0, e = En)
    }
    if (e !== 0) {
        if (e === 2 && (r = qv(n), r !== 0 && (i = r, e = EA(n, r))), e === 1) throw t = Gf, Ha(n, 0), _o(n, i), Mi(n, mn()), t;
        if (e === 6) _o(n, i);
        else {
            if (r = n.current.alternate, !(i & 30) && !FF(r) && (e = Um(n, i), e === 2 && (s = qv(n), s !== 0 && (i = s, e = EA(n, s))), e === 1)) throw t = Gf, Ha(n, 0), _o(n, i), Mi(n, mn()), t;
            switch (n.finishedWork = r, n.finishedLanes = i, e) {
                case 0:
                case 1:
                    throw Error(Me(345));
                case 2:
                    Sa(n, Ai, Cs);
                    break;
                case 3:
                    if (_o(n, i), (i & 130023424) === i && (e = F1 + 500 - mn(), 10 < e)) {
                        if (_m(n, 0) !== 0) break;
                        if (r = n.suspendedLanes, (r & i) !== i) {
                            ui(), n.pingedLanes |= n.suspendedLanes & r;
                            break
                        }
                        n.timeoutHandle = oA(Sa.bind(null, n, Ai, Cs), e);
                        break
                    }
                    Sa(n, Ai, Cs);
                    break;
                case 4:
                    if (_o(n, i), (i & 4194240) === i) break;
                    for (e = n.eventTimes, r = -1; 0 < i;) {
                        var o = 31 - Ir(i);
                        s = 1 << o, o = e[o], o > r && (r = o), i &= ~s
                    }
                    if (i = r, i = mn() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * DF(i / 1960)) - i, 10 < i) {
                        n.timeoutHandle = oA(Sa.bind(null, n, Ai, Cs), i);
                        break
                    }
                    Sa(n, Ai, Cs);
                    break;
                case 5:
                    Sa(n, Ai, Cs);
                    break;
                default:
                    throw Error(Me(329))
            }
        }
    }
    return Mi(n, mn()), n.callbackNode === t ? vB.bind(null, n) : null
}

function EA(n, e) {
    var t = df;
    return n.current.memoizedState.isDehydrated && (Ha(n, e).flags |= 256), n = Um(n, e), n !== 2 && (e = Ai, Ai = t, e !== null && bA(e)), n
}

function bA(n) {
    Ai === null ? Ai = n : Ai.push.apply(Ai, n)
}

function FF(n) {
    for (var e = n;;) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores, t !== null))
                for (var i = 0; i < t.length; i++) {
                    var r = t[i],
                        s = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!kr(s(), r)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t;
        else {
            if (e === n) break;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === n) return !0;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
    }
    return !0
}

function _o(n, e) {
    for (e &= ~D1, e &= ~gg, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; 0 < e;) {
        var t = 31 - Ir(e),
            i = 1 << t;
        n[t] = -1, e &= ~i
    }
}

function rC(n) {
    if (Pt & 6) throw Error(Me(327));
    xu();
    var e = _m(n, 0);
    if (!(e & 1)) return Mi(n, mn()), null;
    var t = Um(n, e);
    if (n.tag !== 0 && t === 2) {
        var i = qv(n);
        i !== 0 && (e = i, t = EA(n, i))
    }
    if (t === 1) throw t = Gf, Ha(n, 0), _o(n, e), Mi(n, mn()), t;
    if (t === 6) throw Error(Me(345));
    return n.finishedWork = n.current.alternate, n.finishedLanes = e, Sa(n, Ai, Cs), Mi(n, mn()), null
}

function k1(n, e) {
    var t = Pt;
    Pt |= 1;
    try {
        return n(e)
    } finally {
        Pt = t, Pt === 0 && (Pu = mn() + 500, dg && Ko())
    }
}

function tl(n) {
    So !== null && So.tag === 0 && !(Pt & 6) && xu();
    var e = Pt;
    Pt |= 1;
    var t = dr.transition,
        i = Nt;
    try {
        if (dr.transition = null, Nt = 1, n) return n()
    } finally {
        Nt = i, dr.transition = t, Pt = e, !(Pt & 6) && Ko()
    }
}

function N1() {
    Di = au.current, jt(au)
}

function Ha(n, e) {
    n.finishedWork = null, n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1, fF(t)), _n !== null)
        for (t = _n.return; t !== null;) {
            var i = t;
            switch (y1(i), i.tag) {
                case 1:
                    i = i.type.childContextTypes, i != null && Em();
                    break;
                case 3:
                    Tu(), jt(wi), jt($n), E1();
                    break;
                case 5:
                    C1(i);
                    break;
                case 4:
                    Tu();
                    break;
                case 13:
                    jt($t);
                    break;
                case 19:
                    jt($t);
                    break;
                case 10:
                    _1(i.type._context);
                    break;
                case 22:
                case 23:
                    N1()
            }
            t = t.return
        }
    if (Nn = n, _n = n = Do(n.current, null), Gn = Di = e, En = 0, Gf = null, D1 = gg = el = 0, Ai = df = null, La !== null) {
        for (e = 0; e < La.length; e++)
            if (t = La[e], i = t.interleaved, i !== null) {
                t.interleaved = null;
                var r = i.next,
                    s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = r, i.next = o
                }
                t.pending = i
            } La = null
    }
    return n
}

function AB(n, e) {
    do {
        var t = _n;
        try {
            if (x1(), $p.current = Fm, Dm) {
                for (var i = rn.memoizedState; i !== null;) {
                    var r = i.queue;
                    r !== null && (r.pending = null), i = i.next
                }
                Dm = !1
            }
            if ($a = 0, kn = Cn = rn = null, cf = !1, Of = 0, L1.current = null, t === null || t.return === null) {
                En = 1, Gf = e, _n = null;
                break
            }
            e: {
                var s = n,
                    o = t.return,
                    a = t,
                    l = e;
                if (e = Gn, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l,
                        d = a,
                        h = d.tag;
                    if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var p = d.alternate;
                        p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null)
                    }
                    var m = jM(o);
                    if (m !== null) {
                        m.flags &= -257, JM(m, o, a, s, e), m.mode & 1 && WM(s, c, e), e = m, l = c;
                        var v = e.updateQueue;
                        if (v === null) {
                            var y = new Set;
                            y.add(l), e.updateQueue = y
                        } else v.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            WM(s, c, e), O1();
                            break e
                        }
                        l = Error(Me(426))
                    }
                } else if (Kt && a.mode & 1) {
                    var A = jM(o);
                    if (A !== null) {
                        !(A.flags & 65536) && (A.flags |= 256), JM(A, o, a, s, e), v1(Bu(l, a));
                        break e
                    }
                }
                s = l = Bu(l, a),
                En !== 4 && (En = 2),
                df === null ? df = [s] : df.push(s),
                s = o;do {
                    switch (s.tag) {
                        case 3:
                            s.flags |= 65536, e &= -e, s.lanes |= e;
                            var x = nB(s, l, e);
                            NM(s, x);
                            break e;
                        case 1:
                            a = l;
                            var _ = s.type,
                                S = s.stateNode;
                            if (!(s.flags & 128) && (typeof _.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (Io === null || !Io.has(S)))) {
                                s.flags |= 65536, e &= -e, s.lanes |= e;
                                var M = iB(s, a, e);
                                NM(s, M);
                                break e
                            }
                    }
                    s = s.return
                } while (s !== null)
            }
            wB(t)
        } catch (b) {
            e = b, _n === t && t !== null && (_n = t = t.return);
            continue
        }
        break
    } while (1)
}

function xB() {
    var n = km.current;
    return km.current = Fm, n === null ? Fm : n
}

function O1() {
    (En === 0 || En === 3 || En === 2) && (En = 4), Nn === null || !(el & 268435455) && !(gg & 268435455) || _o(Nn, Gn)
}

function Um(n, e) {
    var t = Pt;
    Pt |= 2;
    var i = xB();
    (Nn !== n || Gn !== e) && (Cs = null, Ha(n, e));
    do try {
        kF();
        break
    } catch (r) {
        AB(n, r)
    }
    while (1);
    if (x1(), Pt = t, km.current = i, _n !== null) throw Error(Me(261));
    return Nn = null, Gn = 0, En
}

function kF() {
    for (; _n !== null;) _B(_n)
}

function NF() {
    for (; _n !== null && !lD();) _B(_n)
}

function _B(n) {
    var e = MB(n.alternate, n, Di);
    n.memoizedProps = n.pendingProps, e === null ? wB(n) : _n = e, L1.current = null
}

function wB(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return, e.flags & 32768) {
            if (t = PF(t, e), t !== null) {
                t.flags &= 32767, _n = t;
                return
            }
            if (n !== null) n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null;
            else {
                En = 6, _n = null;
                return
            }
        } else if (t = BF(t, e, Di), t !== null) {
            _n = t;
            return
        }
        if (e = e.sibling, e !== null) {
            _n = e;
            return
        }
        _n = e = n
    } while (e !== null);
    En === 0 && (En = 5)
}

function Sa(n, e, t) {
    var i = Nt,
        r = dr.transition;
    try {
        dr.transition = null, Nt = 1, OF(n, e, t, i)
    } finally {
        dr.transition = r, Nt = i
    }
    return null
}

function OF(n, e, t, i) {
    do xu(); while (So !== null);
    if (Pt & 6) throw Error(Me(327));
    t = n.finishedWork;
    var r = n.finishedLanes;
    if (t === null) return null;
    if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) throw Error(Me(177));
    n.callbackNode = null, n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (vD(n, s), n === Nn && (_n = Nn = null, Gn = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Zh || (Zh = !0, CB(xm, function() {
            return xu(), null
        })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) {
        s = dr.transition, dr.transition = null;
        var o = Nt;
        Nt = 1;
        var a = Pt;
        Pt |= 4, L1.current = null, IF(n, t), gB(t, n), rF(rA), wm = !!iA, rA = iA = null, n.current = t, LF(t), uD(), Pt = a, Nt = o, dr.transition = s
    } else n.current = t;
    if (Zh && (Zh = !1, So = n, Om = r), s = n.pendingLanes, s === 0 && (Io = null), dD(t.stateNode), Mi(n, mn()), e !== null)
        for (i = n.onRecoverableError, t = 0; t < e.length; t++) r = e[t], i(r.value, {
            componentStack: r.stack,
            digest: r.digest
        });
    if (Nm) throw Nm = !1, n = MA, MA = null, n;
    return Om & 1 && n.tag !== 0 && xu(), s = n.pendingLanes, s & 1 ? n === CA ? hf++ : (hf = 0, CA = n) : hf = 0, Ko(), null
}

function xu() {
    if (So !== null) {
        var n = t2(Om),
            e = dr.transition,
            t = Nt;
        try {
            if (dr.transition = null, Nt = 16 > n ? 16 : n, So === null) var i = !1;
            else {
                if (n = So, So = null, Om = 0, Pt & 6) throw Error(Me(331));
                var r = Pt;
                for (Pt |= 4, Ge = n.current; Ge !== null;) {
                    var s = Ge,
                        o = s.child;
                    if (Ge.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (Ge = c; Ge !== null;) {
                                    var d = Ge;
                                    switch (d.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            ff(8, d, s)
                                    }
                                    var h = d.child;
                                    if (h !== null) h.return = d, Ge = h;
                                    else
                                        for (; Ge !== null;) {
                                            d = Ge;
                                            var p = d.sibling,
                                                m = d.return;
                                            if (hB(d), d === c) {
                                                Ge = null;
                                                break
                                            }
                                            if (p !== null) {
                                                p.return = m, Ge = p;
                                                break
                                            }
                                            Ge = m
                                        }
                                }
                            }
                            var v = s.alternate;
                            if (v !== null) {
                                var y = v.child;
                                if (y !== null) {
                                    v.child = null;
                                    do {
                                        var A = y.sibling;
                                        y.sibling = null, y = A
                                    } while (y !== null)
                                }
                            }
                            Ge = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null) o.return = s, Ge = o;
                    else e: for (; Ge !== null;) {
                        if (s = Ge, s.flags & 2048) switch (s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                ff(9, s, s.return)
                        }
                        var x = s.sibling;
                        if (x !== null) {
                            x.return = s.return, Ge = x;
                            break e
                        }
                        Ge = s.return
                    }
                }
                var _ = n.current;
                for (Ge = _; Ge !== null;) {
                    o = Ge;
                    var S = o.child;
                    if (o.subtreeFlags & 2064 && S !== null) S.return = o, Ge = S;
                    else e: for (o = _; Ge !== null;) {
                        if (a = Ge, a.flags & 2048) try {
                            switch (a.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    mg(9, a)
                            }
                        } catch (b) {
                            cn(a, a.return, b)
                        }
                        if (a === o) {
                            Ge = null;
                            break e
                        }
                        var M = a.sibling;
                        if (M !== null) {
                            M.return = a.return, Ge = M;
                            break e
                        }
                        Ge = a.return
                    }
                }
                if (Pt = r, Ko(), $r && typeof $r.onPostCommitFiberRoot == "function") try {
                    $r.onPostCommitFiberRoot(ag, n)
                } catch {}
                i = !0
            }
            return i
        } finally {
            Nt = t, dr.transition = e
        }
    }
    return !1
}

function sC(n, e, t) {
    e = Bu(t, e), e = nB(n, e, 1), n = Ro(n, e, 1), e = ui(), n !== null && (fd(n, 1, e), Mi(n, e))
}

function cn(n, e, t) {
    if (n.tag === 3) sC(n, n, t);
    else
        for (; e !== null;) {
            if (e.tag === 3) {
                sC(e, n, t);
                break
            } else if (e.tag === 1) {
                var i = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Io === null || !Io.has(i))) {
                    n = Bu(t, n), n = iB(e, n, 1), e = Ro(e, n, 1), n = ui(), e !== null && (fd(e, 1, n), Mi(e, n));
                    break
                }
            }
            e = e.return
        }
}

function UF(n, e, t) {
    var i = n.pingCache;
    i !== null && i.delete(e), e = ui(), n.pingedLanes |= n.suspendedLanes & t, Nn === n && (Gn & t) === t && (En === 4 || En === 3 && (Gn & 130023424) === Gn && 500 > mn() - F1 ? Ha(n, 0) : D1 |= t), Mi(n, e)
}

function SB(n, e) {
    e === 0 && (n.mode & 1 ? (e = Gh, Gh <<= 1, !(Gh & 130023424) && (Gh = 4194304)) : e = 1);
    var t = ui();
    n = Gs(n, e), n !== null && (fd(n, e, t), Mi(n, t))
}

function zF(n) {
    var e = n.memoizedState,
        t = 0;
    e !== null && (t = e.retryLane), SB(n, t)
}

function GF(n, e) {
    var t = 0;
    switch (n.tag) {
        case 13:
            var i = n.stateNode,
                r = n.memoizedState;
            r !== null && (t = r.retryLane);
            break;
        case 19:
            i = n.stateNode;
            break;
        default:
            throw Error(Me(314))
    }
    i !== null && i.delete(e), SB(n, t)
}
var MB;
MB = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || wi.current) _i = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128)) return _i = !1, TF(n, e, t);
            _i = !!(n.flags & 131072)
        }
    else _i = !1, Kt && e.flags & 1048576 && b2(e, Bm, e.index);
    switch (e.lanes = 0, e.tag) {
        case 2:
            var i = e.type;
            tm(n, e), n = e.pendingProps;
            var r = Cu(e, $n.current);
            Au(e, t), r = T1(null, e, i, n, r, t);
            var s = B1();
            return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Si(i) ? (s = !0, bm(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, S1(e), r.updater = hg, e.stateNode = r, r._reactInternals = e, hA(e, i, n, t), e = gA(null, e, i, !0, s, t)) : (e.tag = 0, Kt && s && g1(e), ai(null, e, r, t), e = e.child), e;
        case 16:
            i = e.elementType;
            e: {
                switch (tm(n, e), n = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = VF(i), n = Er(i, n), r) {
                    case 0:
                        e = mA(null, e, i, n, t);
                        break e;
                    case 1:
                        e = KM(null, e, i, n, t);
                        break e;
                    case 11:
                        e = XM(null, e, i, n, t);
                        break e;
                    case 14:
                        e = QM(null, e, i, Er(i.type, n), t);
                        break e
                }
                throw Error(Me(306, i, ""))
            }
            return e;
        case 0:
            return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Er(i, r), mA(n, e, i, r, t);
        case 1:
            return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Er(i, r), KM(n, e, i, r, t);
        case 3:
            e: {
                if (aB(e), n === null) throw Error(Me(387));i = e.pendingProps,
                s = e.memoizedState,
                r = s.element,
                R2(n, e),
                Im(e, i, null, t);
                var o = e.memoizedState;
                if (i = o.element, s.isDehydrated)
                    if (s = {
                            element: i,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions
                        }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
                        r = Bu(Error(Me(423)), e), e = YM(n, e, i, t, r);
                        break e
                    } else if (i !== r) {
                    r = Bu(Error(Me(424)), e), e = YM(n, e, i, t, r);
                    break e
                } else
                    for (ki = Po(e.stateNode.containerInfo.firstChild), Oi = e, Kt = !0, Br = null, t = F2(e, null, i, t), e.child = t; t;) t.flags = t.flags & -3 | 4096, t = t.sibling;
                else {
                    if (Eu(), i === r) {
                        e = Hs(n, e, t);
                        break e
                    }
                    ai(n, e, i, t)
                }
                e = e.child
            }
            return e;
        case 5:
            return k2(e), n === null && cA(e), i = e.type, r = e.pendingProps, s = n !== null ? n.memoizedProps : null, o = r.children, sA(i, r) ? o = null : s !== null && sA(i, s) && (e.flags |= 32), oB(n, e), ai(n, e, o, t), e.child;
        case 6:
            return n === null && cA(e), null;
        case 13:
            return lB(n, e, t);
        case 4:
            return M1(e, e.stateNode.containerInfo), i = e.pendingProps, n === null ? e.child = bu(e, null, i, t) : ai(n, e, i, t), e.child;
        case 11:
            return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Er(i, r), XM(n, e, i, r, t);
        case 7:
            return ai(n, e, e.pendingProps, t), e.child;
        case 8:
            return ai(n, e, e.pendingProps.children, t), e.child;
        case 12:
            return ai(n, e, e.pendingProps.children, t), e.child;
        case 10:
            e: {
                if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, Ht(Pm, i._currentValue), i._currentValue = o, s !== null)
                    if (kr(s.value, o)) {
                        if (s.children === r.children && !wi.current) {
                            e = Hs(n, e, t);
                            break e
                        }
                    } else
                        for (s = e.child, s !== null && (s.return = e); s !== null;) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var l = a.firstContext; l !== null;) {
                                    if (l.context === i) {
                                        if (s.tag === 1) {
                                            l = Fs(-1, t & -t), l.tag = 2;
                                            var c = s.updateQueue;
                                            if (c !== null) {
                                                c = c.shared;
                                                var d = c.pending;
                                                d === null ? l.next = l : (l.next = d.next, d.next = l), c.pending = l
                                            }
                                        }
                                        s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), fA(s.return, t, e), a.lanes |= t;
                                        break
                                    }
                                    l = l.next
                                }
                            } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (o = s.return, o === null) throw Error(Me(341));
                                o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), fA(o, t, e), o = s.sibling
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null;) {
                                    if (o === e) {
                                        o = null;
                                        break
                                    }
                                    if (s = o.sibling, s !== null) {
                                        s.return = o.return, o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                ai(n, e, r.children, t),
                e = e.child
            }
            return e;
        case 9:
            return r = e.type, i = e.pendingProps.children, Au(e, t), r = mr(r), i = i(r), e.flags |= 1, ai(n, e, i, t), e.child;
        case 14:
            return i = e.type, r = Er(i, e.pendingProps), r = Er(i.type, r), QM(n, e, i, r, t);
        case 15:
            return rB(n, e, e.type, e.pendingProps, t);
        case 17:
            return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Er(i, r), tm(n, e), e.tag = 1, Si(i) ? (n = !0, bm(e)) : n = !1, Au(e, t), L2(e, i, r), hA(e, i, r, t), gA(null, e, i, !0, n, t);
        case 19:
            return uB(n, e, t);
        case 22:
            return sB(n, e, t)
    }
    throw Error(Me(156, e.tag))
};

function CB(n, e) {
    return ZT(n, e)
}

function HF(n, e, t, i) {
    this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function fr(n, e, t, i) {
    return new HF(n, e, t, i)
}

function U1(n) {
    return n = n.prototype, !(!n || !n.isReactComponent)
}

function VF(n) {
    if (typeof n == "function") return U1(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof, n === r1) return 11;
        if (n === s1) return 14
    }
    return 2
}

function Do(n, e) {
    var t = n.alternate;
    return t === null ? (t = fr(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t
}

function rm(n, e, t, i, r, s) {
    var o = 2;
    if (i = n, typeof n == "function") U1(n) && (o = 1);
    else if (typeof n == "string") o = 5;
    else e: switch (n) {
        case Zl:
            return Va(t.children, r, s, e);
        case i1:
            o = 8, r |= 8;
            break;
        case Nv:
            return n = fr(12, t, e, r | 2), n.elementType = Nv, n.lanes = s, n;
        case Ov:
            return n = fr(13, t, e, r), n.elementType = Ov, n.lanes = s, n;
        case Uv:
            return n = fr(19, t, e, r), n.elementType = Uv, n.lanes = s, n;
        case DT:
            return yg(t, r, s, e);
        default:
            if (typeof n == "object" && n !== null) switch (n.$$typeof) {
                case IT:
                    o = 10;
                    break e;
                case LT:
                    o = 9;
                    break e;
                case r1:
                    o = 11;
                    break e;
                case s1:
                    o = 14;
                    break e;
                case mo:
                    o = 16, i = null;
                    break e
            }
            throw Error(Me(130, n == null ? n : typeof n, ""))
    }
    return e = fr(o, t, e, r), e.elementType = n, e.type = i, e.lanes = s, e
}

function Va(n, e, t, i) {
    return n = fr(7, n, i, e), n.lanes = t, n
}

function yg(n, e, t, i) {
    return n = fr(22, n, i, e), n.elementType = DT, n.lanes = t, n.stateNode = {
        isHidden: !1
    }, n
}

function Ey(n, e, t) {
    return n = fr(6, n, null, e), n.lanes = t, n
}

function by(n, e, t) {
    return e = fr(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    }, e
}

function WF(n, e, t, i, r) {
    this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ay(0), this.expirationTimes = ay(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ay(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null
}

function z1(n, e, t, i, r, s, o, a, l) {
    return n = new WF(n, e, t, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = fr(3, null, null, e), n.current = s, s.stateNode = n, s.memoizedState = {
        element: i,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, S1(s), n
}

function jF(n, e, t) {
    var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Yl,
        key: i == null ? null : "" + i,
        children: n,
        containerInfo: e,
        implementation: t
    }
}

function EB(n) {
    if (!n) return Uo;
    n = n._reactInternals;
    e: {
        if (al(n) !== n || n.tag !== 1) throw Error(Me(170));
        var e = n;do {
            switch (e.tag) {
                case 3:
                    e = e.stateNode.context;
                    break e;
                case 1:
                    if (Si(e.type)) {
                        e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            e = e.return
        } while (e !== null);
        throw Error(Me(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (Si(t)) return C2(n, t, e)
    }
    return e
}

function bB(n, e, t, i, r, s, o, a, l) {
    return n = z1(t, i, !0, n, r, s, o, a, l), n.context = EB(null), t = n.current, i = ui(), r = Lo(t), s = Fs(i, r), s.callback = e ?? null, Ro(t, s, r), n.current.lanes = r, fd(n, r, i), Mi(n, i), n
}

function vg(n, e, t, i) {
    var r = e.current,
        s = ui(),
        o = Lo(r);
    return t = EB(t), e.context === null ? e.context = t : e.pendingContext = t, e = Fs(s, o), e.payload = {
        element: n
    }, i = i === void 0 ? null : i, i !== null && (e.callback = i), n = Ro(r, e, o), n !== null && (Lr(n, r, o, s), qp(n, r, o)), o
}

function zm(n) {
    if (n = n.current, !n.child) return null;
    switch (n.child.tag) {
        case 5:
            return n.child.stateNode;
        default:
            return n.child.stateNode
    }
}

function oC(n, e) {
    if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}

function G1(n, e) {
    oC(n, e), (n = n.alternate) && oC(n, e)
}

function JF() {
    return null
}
var TB = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
};

function H1(n) {
    this._internalRoot = n
}
Ag.prototype.render = H1.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null) throw Error(Me(409));
    vg(n, e, null, null)
};
Ag.prototype.unmount = H1.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        tl(function() {
            vg(null, n, null, null)
        }), e[zs] = null
    }
};

function Ag(n) {
    this._internalRoot = n
}
Ag.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = r2();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < xo.length && e !== 0 && e < xo[t].priority; t++);
        xo.splice(t, 0, n), t === 0 && o2(n)
    }
};

function V1(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}

function xg(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}

function aC() {}

function XF(n, e, t, i, r) {
    if (r) {
        if (typeof i == "function") {
            var s = i;
            i = function() {
                var c = zm(o);
                s.call(c)
            }
        }
        var o = bB(e, i, n, 0, null, !1, !1, "", aC);
        return n._reactRootContainer = o, n[zs] = o.current, Lf(n.nodeType === 8 ? n.parentNode : n), tl(), o
    }
    for (; r = n.lastChild;) n.removeChild(r);
    if (typeof i == "function") {
        var a = i;
        i = function() {
            var c = zm(l);
            a.call(c)
        }
    }
    var l = z1(n, 0, !1, null, null, !1, !1, "", aC);
    return n._reactRootContainer = l, n[zs] = l.current, Lf(n.nodeType === 8 ? n.parentNode : n), tl(function() {
        vg(e, l, t, i)
    }), l
}

function _g(n, e, t, i, r) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof r == "function") {
            var a = r;
            r = function() {
                var l = zm(o);
                a.call(l)
            }
        }
        vg(e, o, n, r)
    } else o = XF(t, e, n, r, i);
    return zm(o)
}
n2 = function(n) {
    switch (n.tag) {
        case 3:
            var e = n.stateNode;
            if (e.current.memoizedState.isDehydrated) {
                var t = ef(e.pendingLanes);
                t !== 0 && (l1(e, t | 1), Mi(e, mn()), !(Pt & 6) && (Pu = mn() + 500, Ko()))
            }
            break;
        case 13:
            tl(function() {
                var i = Gs(n, 1);
                if (i !== null) {
                    var r = ui();
                    Lr(i, n, 1, r)
                }
            }), G1(n, 1)
    }
};
u1 = function(n) {
    if (n.tag === 13) {
        var e = Gs(n, 134217728);
        if (e !== null) {
            var t = ui();
            Lr(e, n, 134217728, t)
        }
        G1(n, 134217728)
    }
};
i2 = function(n) {
    if (n.tag === 13) {
        var e = Lo(n),
            t = Gs(n, e);
        if (t !== null) {
            var i = ui();
            Lr(t, n, e, i)
        }
        G1(n, e)
    }
};
r2 = function() {
    return Nt
};
s2 = function(n, e) {
    var t = Nt;
    try {
        return Nt = n, e()
    } finally {
        Nt = t
    }
};
Kv = function(n, e, t) {
    switch (e) {
        case "input":
            if (Hv(n, t), e = t.name, t.type === "radio" && e != null) {
                for (t = n; t.parentNode;) t = t.parentNode;
                for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) {
                    var i = t[e];
                    if (i !== n && i.form === n.form) {
                        var r = fg(i);
                        if (!r) throw Error(Me(90));
                        kT(i), Hv(i, r)
                    }
                }
            }
            break;
        case "textarea":
            OT(n, t);
            break;
        case "select":
            e = t.value, e != null && mu(n, !!t.multiple, e, !1)
    }
};
jT = k1;
JT = tl;
var QF = {
        usingClientEntryPoint: !1,
        Events: [hd, tu, fg, VT, WT, k1]
    },
    Bc = {
        findFiberByHostInstance: Ia,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
    },
    KF = {
        bundleType: Bc.bundleType,
        version: Bc.version,
        rendererPackageName: Bc.rendererPackageName,
        rendererConfig: Bc.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Js.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(n) {
            return n = KT(n), n === null ? null : n.stateNode
        },
        findFiberByHostInstance: Bc.findFiberByHostInstance || JF,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var qh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qh.isDisabled && qh.supportsFiber) try {
        ag = qh.inject(KF), $r = qh
    } catch {}
}
Vi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = QF;
Vi.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!V1(e)) throw Error(Me(200));
    return jF(n, e, null, t)
};
Vi.createRoot = function(n, e) {
    if (!V1(n)) throw Error(Me(299));
    var t = !1,
        i = "",
        r = TB;
    return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = z1(n, 1, !1, null, null, t, !1, i, r), n[zs] = e.current, Lf(n.nodeType === 8 ? n.parentNode : n), new H1(e)
};
Vi.findDOMNode = function(n) {
    if (n == null) return null;
    if (n.nodeType === 1) return n;
    var e = n._reactInternals;
    if (e === void 0) throw typeof n.render == "function" ? Error(Me(188)) : (n = Object.keys(n).join(","), Error(Me(268, n)));
    return n = KT(e), n = n === null ? null : n.stateNode, n
};
Vi.flushSync = function(n) {
    return tl(n)
};
Vi.hydrate = function(n, e, t) {
    if (!xg(e)) throw Error(Me(200));
    return _g(null, n, e, !0, t)
};
Vi.hydrateRoot = function(n, e, t) {
    if (!V1(n)) throw Error(Me(405));
    var i = t != null && t.hydratedSources || null,
        r = !1,
        s = "",
        o = TB;
    if (t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = bB(e, null, n, 1, t ?? null, r, !1, s, o), n[zs] = e.current, Lf(n), i)
        for (n = 0; n < i.length; n++) t = i[n], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
    return new Ag(e)
};
Vi.render = function(n, e, t) {
    if (!xg(e)) throw Error(Me(200));
    return _g(null, n, e, !1, t)
};
Vi.unmountComponentAtNode = function(n) {
    if (!xg(n)) throw Error(Me(40));
    return n._reactRootContainer ? (tl(function() {
        _g(null, null, n, !1, function() {
            n._reactRootContainer = null, n[zs] = null
        })
    }), !0) : !1
};
Vi.unstable_batchedUpdates = k1;
Vi.unstable_renderSubtreeIntoContainer = function(n, e, t, i) {
    if (!xg(t)) throw Error(Me(200));
    if (n == null || n._reactInternals === void 0) throw Error(Me(38));
    return _g(n, e, t, !1, i)
};
Vi.version = "18.2.0-next-9e3b772b8-20220608";
(function(n) {
    function e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
        } catch (t) {
            console.error(t)
        }
    }
    e(), n.exports = Vi
})(JL);
var BB, lC = gm;
BB = Dv.createRoot = lC.createRoot, Dv.hydrateRoot = lC.hydrateRoot;
/**
 * @remix-run/router v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Hf() {
    return Hf = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }, Hf.apply(this, arguments)
}
var Fa;
(function(n) {
    n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE"
})(Fa || (Fa = {}));
const uC = "popstate";

function YF(n) {
    n === void 0 && (n = {});

    function e(i, r) {
        let {
            pathname: s,
            search: o,
            hash: a
        } = i.location;
        return TA("", {
            pathname: s,
            search: o,
            hash: a
        }, r.state && r.state.usr || null, r.state && r.state.key || "default")
    }

    function t(i, r) {
        return typeof r == "string" ? r : Gm(r)
    }
    return qF(e, t, null, n)
}

function Fo(n, e) {
    if (n === !1 || n === null || typeof n > "u") throw new Error(e)
}

function ZF() {
    return Math.random().toString(36).substr(2, 8)
}

function cC(n, e) {
    return {
        usr: n.state,
        key: n.key,
        idx: e
    }
}

function TA(n, e, t, i) {
    return t === void 0 && (t = null), Hf({
        pathname: typeof n == "string" ? n : n.pathname,
        search: "",
        hash: ""
    }, typeof e == "string" ? wg(e) : e, {
        state: t,
        key: e && e.key || i || ZF()
    })
}

function Gm(n) {
    let {
        pathname: e = "/",
        search: t = "",
        hash: i = ""
    } = n;
    return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i), e
}

function wg(n) {
    let e = {};
    if (n) {
        let t = n.indexOf("#");
        t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t));
        let i = n.indexOf("?");
        i >= 0 && (e.search = n.substr(i), n = n.substr(0, i)), n && (e.pathname = n)
    }
    return e
}

function qF(n, e, t, i) {
    i === void 0 && (i = {});
    let {
        window: r = document.defaultView,
        v5Compat: s = !1
    } = i, o = r.history, a = Fa.Pop, l = null, c = d();
    c == null && (c = 0, o.replaceState(Hf({}, o.state, {
        idx: c
    }), ""));

    function d() {
        return (o.state || {
            idx: null
        }).idx
    }

    function h() {
        a = Fa.Pop;
        let A = d(),
            x = A == null ? null : A - c;
        c = A, l && l({
            action: a,
            location: y.location,
            delta: x
        })
    }

    function p(A, x) {
        a = Fa.Push;
        let _ = TA(y.location, A, x);
        t && t(_, A), c = d() + 1;
        let S = cC(_, c),
            M = y.createHref(_);
        try {
            o.pushState(S, "", M)
        } catch {
            r.location.assign(M)
        }
        s && l && l({
            action: a,
            location: y.location,
            delta: 1
        })
    }

    function m(A, x) {
        a = Fa.Replace;
        let _ = TA(y.location, A, x);
        t && t(_, A), c = d();
        let S = cC(_, c),
            M = y.createHref(_);
        o.replaceState(S, "", M), s && l && l({
            action: a,
            location: y.location,
            delta: 0
        })
    }

    function v(A) {
        let x = r.location.origin !== "null" ? r.location.origin : r.location.href,
            _ = typeof A == "string" ? A : Gm(A);
        return Fo(x, "No window.location.(origin|href) available to create URL for href: " + _), new URL(_, x)
    }
    let y = {
        get action() {
            return a
        },
        get location() {
            return n(r, o)
        },
        listen(A) {
            if (l) throw new Error("A history only accepts one active listener");
            return r.addEventListener(uC, h), l = A, () => {
                r.removeEventListener(uC, h), l = null
            }
        },
        createHref(A) {
            return e(r, A)
        },
        createURL: v,
        encodeLocation(A) {
            let x = v(A);
            return {
                pathname: x.pathname,
                search: x.search,
                hash: x.hash
            }
        },
        push: p,
        replace: m,
        go(A) {
            return o.go(A)
        }
    };
    return y
}
var fC;
(function(n) {
    n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error"
})(fC || (fC = {}));

function $F(n, e) {
    if (e === "/") return n;
    if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length,
        i = n.charAt(t);
    return i && i !== "/" ? null : n.slice(t) || "/"
}

function ek(n, e) {
    e === void 0 && (e = "/");
    let {
        pathname: t,
        search: i = "",
        hash: r = ""
    } = typeof n == "string" ? wg(n) : n;
    return {
        pathname: t ? t.startsWith("/") ? t : tk(t, e) : e,
        search: nk(i),
        hash: ik(r)
    }
}

function tk(n, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return n.split("/").forEach(r => {
        r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r)
    }), t.length > 1 ? t.join("/") : "/"
}

function Ty(n, e, t, i) {
    return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function PB(n) {
    return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}

function RB(n, e, t, i) {
    i === void 0 && (i = !1);
    let r;
    typeof n == "string" ? r = wg(n) : (r = Hf({}, n), Fo(!r.pathname || !r.pathname.includes("?"), Ty("?", "pathname", "search", r)), Fo(!r.pathname || !r.pathname.includes("#"), Ty("#", "pathname", "hash", r)), Fo(!r.search || !r.search.includes("#"), Ty("#", "search", "hash", r)));
    let s = n === "" || r.pathname === "",
        o = s ? "/" : r.pathname,
        a;
    if (i || o == null) a = t;
    else {
        let h = e.length - 1;
        if (o.startsWith("..")) {
            let p = o.split("/");
            for (; p[0] === "..";) p.shift(), h -= 1;
            r.pathname = p.join("/")
        }
        a = h >= 0 ? e[h] : "/"
    }
    let l = ek(r, a),
        c = o && o !== "/" && o.endsWith("/"),
        d = (s || o === ".") && t.endsWith("/");
    return !l.pathname.endsWith("/") && (c || d) && (l.pathname += "/"), l
}
const IB = n => n.join("/").replace(/\/\/+/g, "/"),
    nk = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n,
    ik = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n,
    rk = ["post", "put", "patch", "delete"];
[...rk];
/**
 * React Router v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function sk(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
const ok = typeof Object.is == "function" ? Object.is : sk,
    {
        useState: ak,
        useEffect: lk,
        useLayoutEffect: uk,
        useDebugValue: ck
    } = Lv;

function fk(n, e, t) {
    const i = e(),
        [{
            inst: r
        }, s] = ak({
            inst: {
                value: i,
                getSnapshot: e
            }
        });
    return uk(() => {
        r.value = i, r.getSnapshot = e, By(r) && s({
            inst: r
        })
    }, [n, i, e]), lk(() => (By(r) && s({
        inst: r
    }), n(() => {
        By(r) && s({
            inst: r
        })
    })), [n]), ck(i), i
}

function By(n) {
    const e = n.getSnapshot,
        t = n.value;
    try {
        const i = e();
        return !ok(t, i)
    } catch {
        return !0
    }
}

function dk(n, e, t) {
    return e()
}
const hk = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    pk = !hk,
    mk = pk ? dk : fk;
"useSyncExternalStore" in Lv && (n => n.useSyncExternalStore)(Lv);
const W1 = U.createContext(null),
    j1 = U.createContext(null),
    LB = U.createContext({
        outlet: null,
        matches: []
    });

function gk(n, e) {
    let {
        relative: t
    } = e === void 0 ? {} : e;
    Sg() || Fo(!1);
    let {
        basename: i,
        navigator: r
    } = U.useContext(W1), {
        hash: s,
        pathname: o,
        search: a
    } = DB(n, {
        relative: t
    }), l = o;
    return i !== "/" && (l = o === "/" ? i : IB([i, o])), r.createHref({
        pathname: l,
        search: a,
        hash: s
    })
}

function Sg() {
    return U.useContext(j1) != null
}

function J1() {
    return Sg() || Fo(!1), U.useContext(j1).location
}

function yk() {
    Sg() || Fo(!1);
    let {
        basename: n,
        navigator: e
    } = U.useContext(W1), {
        matches: t
    } = U.useContext(LB), {
        pathname: i
    } = J1(), r = JSON.stringify(PB(t).map(a => a.pathnameBase)), s = U.useRef(!1);
    return U.useEffect(() => {
        s.current = !0
    }), U.useCallback(function(a, l) {
        if (l === void 0 && (l = {}), !s.current) return;
        if (typeof a == "number") {
            e.go(a);
            return
        }
        let c = RB(a, JSON.parse(r), i, l.relative === "path");
        n !== "/" && (c.pathname = c.pathname === "/" ? n : IB([n, c.pathname])), (l.replace ? e.replace : e.push)(c, l.state, l)
    }, [n, e, r, i])
}

function DB(n, e) {
    let {
        relative: t
    } = e === void 0 ? {} : e, {
        matches: i
    } = U.useContext(LB), {
        pathname: r
    } = J1(), s = JSON.stringify(PB(i).map(o => o.pathnameBase));
    return U.useMemo(() => RB(n, JSON.parse(s), r, t === "path"), [n, s, r, t])
}
var dC;
(function(n) {
    n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator"
})(dC || (dC = {}));
var hC;
(function(n) {
    n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator"
})(hC || (hC = {}));

function vk(n) {
    let {
        basename: e = "/",
        children: t = null,
        location: i,
        navigationType: r = Fa.Pop,
        navigator: s,
        static: o = !1
    } = n;
    Sg() && Fo(!1);
    let a = e.replace(/^\/*/, "/"),
        l = U.useMemo(() => ({
            basename: a,
            navigator: s,
            static: o
        }), [a, s, o]);
    typeof i == "string" && (i = wg(i));
    let {
        pathname: c = "/",
        search: d = "",
        hash: h = "",
        state: p = null,
        key: m = "default"
    } = i, v = U.useMemo(() => {
        let y = $F(c, a);
        return y == null ? null : {
            pathname: y,
            search: d,
            hash: h,
            state: p,
            key: m
        }
    }, [a, c, d, h, p, m]);
    return v == null ? null : U.createElement(W1.Provider, {
        value: l
    }, U.createElement(j1.Provider, {
        children: t,
        value: {
            location: v,
            navigationType: r
        }
    }))
}
var pC;
(function(n) {
    n[n.pending = 0] = "pending", n[n.success = 1] = "success", n[n.error = 2] = "error"
})(pC || (pC = {}));
new Promise(() => {});
/**
 * React Router DOM v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function BA() {
    return BA = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }, BA.apply(this, arguments)
}

function Ak(n, e) {
    if (n == null) return {};
    var t = {},
        i = Object.keys(n),
        r, s;
    for (s = 0; s < i.length; s++) r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}

function xk(n) {
    return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}

function _k(n, e) {
    return n.button === 0 && (!e || e === "_self") && !xk(n)
}
const wk = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];

function Sk(n) {
    let {
        basename: e,
        children: t,
        window: i
    } = n, r = U.useRef();
    r.current == null && (r.current = YF({
        window: i,
        v5Compat: !0
    }));
    let s = r.current,
        [o, a] = U.useState({
            action: s.action,
            location: s.location
        });
    return U.useLayoutEffect(() => s.listen(a), [s]), U.createElement(vk, {
        basename: e,
        children: t,
        location: o.location,
        navigationType: o.action,
        navigator: s
    })
}
const Mk = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
    Ck = U.forwardRef(function(e, t) {
        let {
            onClick: i,
            relative: r,
            reloadDocument: s,
            replace: o,
            state: a,
            target: l,
            to: c,
            preventScrollReset: d
        } = e, h = Ak(e, wk), p, m = !1;
        if (Mk && typeof c == "string" && /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(c)) {
            p = c;
            let x = new URL(window.location.href),
                _ = c.startsWith("//") ? new URL(x.protocol + c) : new URL(c);
            _.origin === x.origin ? c = _.pathname + _.search + _.hash : m = !0
        }
        let v = gk(c, {
                relative: r
            }),
            y = Ek(c, {
                replace: o,
                state: a,
                target: l,
                preventScrollReset: d,
                relative: r
            });

        function A(x) {
            i && i(x), x.defaultPrevented || y(x)
        }
        return U.createElement("a", BA({}, h, {
            href: p || v,
            onClick: m || s ? i : A,
            ref: t,
            target: l
        }))
    });
var mC;
(function(n) {
    n.UseScrollRestoration = "useScrollRestoration", n.UseSubmitImpl = "useSubmitImpl", n.UseFetcher = "useFetcher"
})(mC || (mC = {}));
var gC;
(function(n) {
    n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration"
})(gC || (gC = {}));

function Ek(n, e) {
    let {
        target: t,
        replace: i,
        state: r,
        preventScrollReset: s,
        relative: o
    } = e === void 0 ? {} : e, a = yk(), l = J1(), c = DB(n, {
        relative: o
    });
    return U.useCallback(d => {
        if (_k(d, t)) {
            d.preventDefault();
            let h = i !== void 0 ? i : Gm(l) === Gm(c);
            a(n, {
                replace: h,
                state: r,
                preventScrollReset: s,
                relative: o
            })
        }
    }, [l, a, c, i, r, t, n, s, o])
}
var PA = {},
    bk = {
        get exports() {
            return PA
        },
        set exports(n) {
            PA = n
        }
    };
/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function(n, e) {
    (function(t) {
        var i;
        if (n.exports = t(), i = !0, !i) {
            var r = window.Cookies,
                s = window.Cookies = t();
            s.noConflict = function() {
                return window.Cookies = r, s
            }
        }
    })(function() {
        function t() {
            for (var s = 0, o = {}; s < arguments.length; s++) {
                var a = arguments[s];
                for (var l in a) o[l] = a[l]
            }
            return o
        }

        function i(s) {
            return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
        }

        function r(s) {
            function o() {}

            function a(c, d, h) {
                if (!(typeof document > "u")) {
                    h = t({
                        path: "/"
                    }, o.defaults, h), typeof h.expires == "number" && (h.expires = new Date(new Date * 1 + h.expires * 864e5)), h.expires = h.expires ? h.expires.toUTCString() : "";
                    try {
                        var p = JSON.stringify(d);
                        /^[\{\[]/.test(p) && (d = p)
                    } catch {}
                    d = s.write ? s.write(d, c) : encodeURIComponent(String(d)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), c = encodeURIComponent(String(c)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
                    var m = "";
                    for (var v in h) h[v] && (m += "; " + v, h[v] !== !0 && (m += "=" + h[v].split(";")[0]));
                    return document.cookie = c + "=" + d + m
                }
            }

            function l(c, d) {
                if (!(typeof document > "u")) {
                    for (var h = {}, p = document.cookie ? document.cookie.split("; ") : [], m = 0; m < p.length; m++) {
                        var v = p[m].split("="),
                            y = v.slice(1).join("=");
                        !d && y.charAt(0) === '"' && (y = y.slice(1, -1));
                        try {
                            var A = i(v[0]);
                            if (y = (s.read || s)(y, A) || i(y), d) try {
                                y = JSON.parse(y)
                            } catch {}
                            if (h[A] = y, c === A) break
                        } catch {}
                    }
                    return c ? h[c] : h
                }
            }
            return o.set = a, o.get = function(c) {
                return l(c, !1)
            }, o.getJSON = function(c) {
                return l(c, !0)
            }, o.remove = function(c, d) {
                a(c, "", t(d, {
                    expires: -1
                }))
            }, o.defaults = {}, o.withConverter = r, o
        }
        return r(function() {})
    })
})(bk);
const Hm = PA;
var Tk = function(e) {
    var t = e.condition,
        i = e.wrapper,
        r = e.children;
    return t ? i(r) : r
};

function yo() {
    return yo = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }, yo.apply(this, arguments)
}

function Bk(n, e) {
    n.prototype = Object.create(e.prototype), n.prototype.constructor = n, RA(n, e)
}

function RA(n, e) {
    return RA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
        return i.__proto__ = r, i
    }, RA(n, e)
}

function Pk(n, e) {
    if (n == null) return {};
    var t = {},
        i = Object.keys(n),
        r, s;
    for (s = 0; s < i.length; s++) r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
var IA = {
        TOP: "top",
        BOTTOM: "bottom",
        NONE: "none"
    },
    Vm;
(function(n) {
    n.STRICT = "strict", n.LAX = "lax", n.NONE = "none"
})(Vm || (Vm = {}));
var LA = {
        HIDDEN: "hidden",
        SHOW: "show",
        BY_COOKIE_VALUE: "byCookieValue"
    },
    FB = "CookieConsent",
    Rk = ["children"],
    Ik = function(e) {
        var t = e.children,
            i = Pk(e, Rk);
        return ar.createElement("button", Object.assign({}, i), t)
    },
    Lk = {
        disableStyles: !1,
        hideOnAccept: !0,
        hideOnDecline: !0,
        location: IA.BOTTOM,
        visible: LA.BY_COOKIE_VALUE,
        onAccept: function(e) {},
        onDecline: function() {},
        cookieName: FB,
        cookieValue: "true",
        declineCookieValue: "false",
        setDeclineCookie: !0,
        buttonText: "I understand",
        declineButtonText: "I decline",
        debug: !1,
        expires: 365,
        containerClasses: "CookieConsent",
        contentClasses: "",
        buttonClasses: "",
        buttonWrapperClasses: "",
        declineButtonClasses: "",
        buttonId: "rcc-confirm-button",
        declineButtonId: "rcc-decline-button",
        extraCookieOptions: {},
        disableButtonStyles: !1,
        enableDeclineButton: !1,
        flipButtons: !1,
        sameSite: Vm.LAX,
        ButtonComponent: Ik,
        overlay: !1,
        overlayClasses: "",
        onOverlayClick: function() {},
        acceptOnOverlayClick: !1,
        ariaAcceptLabel: "Accept cookies",
        ariaDeclineLabel: "Decline cookies",
        acceptOnScroll: !1,
        acceptOnScrollPercentage: 25,
        customContentAttributes: {},
        customContainerAttributes: {},
        customButtonProps: {},
        customDeclineButtonProps: {},
        customButtonWrapperAttributes: {},
        style: {},
        buttonStyle: {},
        declineButtonStyle: {},
        contentStyle: {},
        overlayStyle: {}
    },
    Dk = {
        visible: !1,
        style: {
            alignItems: "baseline",
            background: "#353535",
            color: "white",
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "space-between",
            left: "0",
            position: "fixed",
            width: "100%",
            zIndex: "999"
        },
        buttonStyle: {
            background: "#ffd42d",
            border: "0",
            borderRadius: "0px",
            boxShadow: "none",
            color: "black",
            cursor: "pointer",
            flex: "0 0 auto",
            padding: "5px 10px",
            margin: "15px"
        },
        declineButtonStyle: {
            background: "#c12a2a",
            border: "0",
            borderRadius: "0px",
            boxShadow: "none",
            color: "#e5e5e5",
            cursor: "pointer",
            flex: "0 0 auto",
            padding: "5px 10px",
            margin: "15px"
        },
        contentStyle: {
            flex: "1 0 300px",
            margin: "15px"
        },
        overlayStyle: {
            position: "fixed",
            left: 0,
            top: 0,
            width: "100%",
            height: "100%",
            zIndex: "999",
            backgroundColor: "rgba(0,0,0,0.3)"
        }
    },
    Fk = function(e) {
        e === void 0 && (e = FB);
        var t = Hm.get(e);
        return t === void 0 ? Hm.get(kB(e)) : t
    },
    kB = function(e) {
        return e + "-legacy"
    },
    NB = function(n) {
        Bk(e, n);

        function e() {
            var i;
            return i = n.apply(this, arguments) || this, i.state = Dk, i.handleScroll = function() {
                var r = i.props.acceptOnScrollPercentage,
                    s = document.documentElement,
                    o = document.body,
                    a = "scrollTop",
                    l = "scrollHeight",
                    c = (s[a] || o[a]) / ((s[l] || o[l]) - s.clientHeight) * 100;
                c > r && i.accept(!0)
            }, i.removeScrollListener = function() {
                var r = i.props.acceptOnScroll;
                r && window.removeEventListener("scroll", i.handleScroll)
            }, i
        }
        var t = e.prototype;
        return t.componentDidMount = function() {
            var r = this.props.debug;
            (this.getCookieValue() === void 0 || r) && (this.setState({
                visible: !0
            }), this.props.acceptOnScroll && window.addEventListener("scroll", this.handleScroll, {
                passive: !0
            }))
        }, t.componentWillUnmount = function() {
            this.removeScrollListener()
        }, t.accept = function(r) {
            var s;
            r === void 0 && (r = !1);
            var o = this.props,
                a = o.cookieName,
                l = o.cookieValue,
                c = o.hideOnAccept,
                d = o.onAccept;
            this.setCookie(a, l), d((s = r) != null ? s : !1), c && (this.setState({
                visible: !1
            }), this.removeScrollListener())
        }, t.overlayClick = function() {
            var r = this.props,
                s = r.acceptOnOverlayClick,
                o = r.onOverlayClick;
            s && this.accept(), o()
        }, t.decline = function() {
            var r = this.props,
                s = r.cookieName,
                o = r.declineCookieValue,
                a = r.hideOnDecline,
                l = r.onDecline,
                c = r.setDeclineCookie;
            c && this.setCookie(s, o), l(), a && this.setState({
                visible: !1
            })
        }, t.setCookie = function(r, s) {
            var o = this.props,
                a = o.extraCookieOptions,
                l = o.expires,
                c = o.sameSite,
                d = this.props.cookieSecurity;
            d === void 0 && (d = window.location ? window.location.protocol === "https:" : !0);
            var h = yo({
                expires: l
            }, a, {
                sameSite: c,
                secure: d
            });
            c === Vm.NONE && Hm.set(kB(r), s, h), Hm.set(r, s, h)
        }, t.getCookieValue = function() {
            var r = this.props.cookieName;
            return Fk(r)
        }, t.render = function() {
            var r = this;
            switch (this.props.visible) {
                case LA.HIDDEN:
                    return null;
                case LA.BY_COOKIE_VALUE:
                    if (!this.state.visible) return null;
                    break
            }
            var s = this.props,
                o = s.location,
                a = s.style,
                l = s.buttonStyle,
                c = s.declineButtonStyle,
                d = s.contentStyle,
                h = s.disableStyles,
                p = s.buttonText,
                m = s.declineButtonText,
                v = s.containerClasses,
                y = s.contentClasses,
                A = s.buttonClasses,
                x = s.buttonWrapperClasses,
                _ = s.declineButtonClasses,
                S = s.buttonId,
                M = s.declineButtonId,
                b = s.disableButtonStyles,
                B = s.enableDeclineButton,
                R = s.flipButtons,
                E = s.ButtonComponent,
                P = s.overlay,
                I = s.overlayClasses,
                z = s.overlayStyle,
                Z = s.ariaAcceptLabel,
                W = s.ariaDeclineLabel,
                G = s.customContainerAttributes,
                K = s.customContentAttributes,
                te = s.customButtonProps,
                se = s.customDeclineButtonProps,
                k = s.customButtonWrapperAttributes,
                V = {},
                J = {},
                ie = {},
                j = {},
                re = {};
            switch (h ? (V = Object.assign({}, a), J = Object.assign({}, l), ie = Object.assign({}, c), j = Object.assign({}, d), re = Object.assign({}, z)) : (V = Object.assign({}, yo({}, this.state.style, a)), j = Object.assign({}, yo({}, this.state.contentStyle, d)), re = Object.assign({}, yo({}, this.state.overlayStyle, z)), b ? (J = Object.assign({}, l), ie = Object.assign({}, c)) : (J = Object.assign({}, yo({}, this.state.buttonStyle, l)), ie = Object.assign({}, yo({}, this.state.declineButtonStyle, c)))), o) {
                case IA.TOP:
                    V.top = "0";
                    break;
                case IA.BOTTOM:
                    V.bottom = "0";
                    break
            }
            var ve = [];
            return B && ve.push(ar.createElement(E, Object.assign({
                key: "declineButton",
                style: ie,
                className: _,
                id: M,
                "aria-label": W,
                onClick: function() {
                    r.decline()
                }
            }, se), m)), ve.push(ar.createElement(E, Object.assign({
                key: "acceptButton",
                style: J,
                className: A,
                id: S,
                "aria-label": Z,
                onClick: function() {
                    r.accept()
                }
            }, te), p)), R && ve.reverse(), ar.createElement(Tk, {
                condition: P,
                wrapper: function(q) {
                    return ar.createElement("div", {
                        style: re,
                        className: I,
                        onClick: function() {
                            r.overlayClick()
                        }
                    }, q)
                }
            }, ar.createElement("div", Object.assign({
                className: "" + v,
                style: V
            }, G), ar.createElement("div", Object.assign({
                style: j,
                className: y
            }, K), this.props.children), ar.createElement("div", Object.assign({
                className: "" + x
            }, k), ve.map(function(xe) {
                return xe
            }))))
        }, e
    }(U.Component);
NB.defaultProps = Lk;
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Mg = "149",
    Ma = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    Ca = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    OB = 0,
    DA = 1,
    UB = 2,
    kk = 3,
    zB = 0,
    Cg = 1,
    pf = 2,
    ka = 3,
    rs = 0,
    Ci = 1,
    Rr = 2,
    Nk = 2,
    ks = 0,
    Wa = 1,
    FA = 2,
    kA = 3,
    NA = 4,
    GB = 5,
    Pa = 100,
    HB = 101,
    VB = 102,
    OA = 103,
    UA = 104,
    WB = 200,
    jB = 201,
    JB = 202,
    XB = 203,
    X1 = 204,
    Q1 = 205,
    QB = 206,
    KB = 207,
    YB = 208,
    ZB = 209,
    qB = 210,
    $B = 0,
    eP = 1,
    tP = 2,
    Wm = 3,
    nP = 4,
    iP = 5,
    rP = 6,
    sP = 7,
    md = 0,
    oP = 1,
    aP = 2,
    Dr = 0,
    lP = 1,
    uP = 2,
    cP = 3,
    K1 = 4,
    fP = 5,
    Eg = 300,
    zo = 301,
    Go = 302,
    Vf = 303,
    Wf = 304,
    Ju = 306,
    Ho = 1e3,
    zn = 1001,
    Ru = 1002,
    fn = 1003,
    jf = 1004,
    Ok = 1004,
    _u = 1005,
    Uk = 1005,
    en = 1006,
    bg = 1007,
    zk = 1007,
    ss = 1008,
    Gk = 1008,
    Vs = 1009,
    dP = 1010,
    hP = 1011,
    Y1 = 1012,
    pP = 1013,
    Mo = 1014,
    Rs = 1015,
    Iu = 1016,
    mP = 1017,
    gP = 1018,
    ja = 1020,
    yP = 1021,
    xi = 1023,
    vP = 1024,
    AP = 1025,
    ko = 1026,
    nl = 1027,
    xP = 1028,
    _P = 1029,
    wP = 1030,
    SP = 1031,
    MP = 1033,
    sm = 33776,
    om = 33777,
    am = 33778,
    lm = 33779,
    zA = 35840,
    GA = 35841,
    HA = 35842,
    VA = 35843,
    CP = 36196,
    WA = 37492,
    jA = 37496,
    JA = 37808,
    XA = 37809,
    QA = 37810,
    KA = 37811,
    YA = 37812,
    ZA = 37813,
    qA = 37814,
    $A = 37815,
    ex = 37816,
    tx = 37817,
    nx = 37818,
    ix = 37819,
    rx = 37820,
    sx = 37821,
    um = 36492,
    EP = 36283,
    ox = 36284,
    ax = 36285,
    lx = 36286,
    bP = 2200,
    TP = 2201,
    BP = 2202,
    Lu = 2300,
    il = 2301,
    cm = 2302,
    Na = 2400,
    Oa = 2401,
    Jf = 2402,
    Tg = 2500,
    Z1 = 2501,
    Hk = 0,
    PP = 1,
    q1 = 2,
    Ws = 3e3,
    Ct = 3001,
    RP = 3200,
    IP = 3201,
    Xs = 0,
    LP = 1,
    Vk = "",
    Tr = "srgb",
    Du = "srgb-linear",
    Wk = 0,
    fm = 7680,
    jk = 7681,
    Jk = 7682,
    Xk = 7683,
    Qk = 34055,
    Kk = 34056,
    Yk = 5386,
    Zk = 512,
    qk = 513,
    $k = 514,
    eN = 515,
    tN = 516,
    nN = 517,
    iN = 518,
    DP = 519,
    Xf = 35044,
    Ja = 35048,
    rN = 35040,
    sN = 35045,
    oN = 35049,
    aN = 35041,
    lN = 35046,
    uN = 35050,
    cN = 35042,
    fN = "100",
    ux = "300 es",
    jm = 1035;
class as {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
            e.target = null
        }
    }
}
const Yn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let yC = 1234567;
const Xa = Math.PI / 180,
    Qf = 180 / Math.PI;

function Ui() {
    const n = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        i = Math.random() * 4294967295 | 0;
    return (Yn[n & 255] + Yn[n >> 8 & 255] + Yn[n >> 16 & 255] + Yn[n >> 24 & 255] + "-" + Yn[e & 255] + Yn[e >> 8 & 255] + "-" + Yn[e >> 16 & 15 | 64] + Yn[e >> 24 & 255] + "-" + Yn[t & 63 | 128] + Yn[t >> 8 & 255] + "-" + Yn[t >> 16 & 255] + Yn[t >> 24 & 255] + Yn[i & 255] + Yn[i >> 8 & 255] + Yn[i >> 16 & 255] + Yn[i >> 24 & 255]).toLowerCase()
}

function gn(n, e, t) {
    return Math.max(e, Math.min(t, n))
}

function $1(n, e) {
    return (n % e + e) % e
}

function dN(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}

function hN(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}

function mf(n, e, t) {
    return (1 - t) * n + t * e
}

function pN(n, e, t, i) {
    return mf(n, e, 1 - Math.exp(-t * i))
}

function mN(n, e = 1) {
    return e - Math.abs($1(n, e * 2) - e)
}

function gN(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n))
}

function yN(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10))
}

function vN(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}

function AN(n, e) {
    return n + Math.random() * (e - n)
}

function xN(n) {
    return n * (.5 - Math.random())
}

function _N(n) {
    n !== void 0 && (yC = n);
    let e = yC += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function wN(n) {
    return n * Xa
}

function SN(n) {
    return n * Qf
}

function cx(n) {
    return (n & n - 1) === 0 && n !== 0
}

function FP(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}

function Jm(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}

function MN(n, e, t, i, r) {
    const s = Math.cos,
        o = Math.sin,
        a = s(t / 2),
        l = o(t / 2),
        c = s((e + i) / 2),
        d = o((e + i) / 2),
        h = s((e - i) / 2),
        p = o((e - i) / 2),
        m = s((i - e) / 2),
        v = o((i - e) / 2);
    switch (r) {
        case "XYX":
            n.set(a * d, l * h, l * p, a * c);
            break;
        case "YZY":
            n.set(l * p, a * d, l * h, a * c);
            break;
        case "ZXZ":
            n.set(l * h, l * p, a * d, a * c);
            break;
        case "XZX":
            n.set(a * d, l * v, l * m, a * c);
            break;
        case "YXY":
            n.set(l * m, a * d, l * v, a * c);
            break;
        case "ZYZ":
            n.set(l * v, l * m, a * d, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}

function Is(n, e) {
    switch (e.constructor) {
        case Float32Array:
            return n;
        case Uint16Array:
            return n / 65535;
        case Uint8Array:
            return n / 255;
        case Int16Array:
            return Math.max(n / 32767, -1);
        case Int8Array:
            return Math.max(n / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function zt(n, e) {
    switch (e.constructor) {
        case Float32Array:
            return n;
        case Uint16Array:
            return Math.round(n * 65535);
        case Uint8Array:
            return Math.round(n * 255);
        case Int16Array:
            return Math.round(n * 32767);
        case Int8Array:
            return Math.round(n * 127);
        default:
            throw new Error("Invalid component type.")
    }
}
var e_ = Object.freeze({
    __proto__: null,
    DEG2RAD: Xa,
    RAD2DEG: Qf,
    ceilPowerOfTwo: FP,
    clamp: gn,
    damp: pN,
    degToRad: wN,
    denormalize: Is,
    euclideanModulo: $1,
    floorPowerOfTwo: Jm,
    generateUUID: Ui,
    inverseLerp: hN,
    isPowerOfTwo: cx,
    lerp: mf,
    mapLinear: dN,
    normalize: zt,
    pingpong: mN,
    radToDeg: SN,
    randFloat: AN,
    randFloatSpread: xN,
    randInt: vN,
    seededRandom: _N,
    setQuaternionFromProperEuler: MN,
    smootherstep: yN,
    smoothstep: gN
});
class me {
    constructor(e = 0, t = 0) {
        me.prototype.isVector2 = !0, this.x = e, this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e, this.y = t, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this
    }
    rotateAround(e, t) {
        const i = Math.cos(t),
            r = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
        return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
class li {
    constructor() {
        li.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, c) {
        const d = this.elements;
        return d[0] = e, d[1] = r, d[2] = a, d[3] = t, d[4] = s, d[5] = l, d[6] = i, d[7] = o, d[8] = c, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[3],
            l = i[6],
            c = i[1],
            d = i[4],
            h = i[7],
            p = i[2],
            m = i[5],
            v = i[8],
            y = r[0],
            A = r[3],
            x = r[6],
            _ = r[1],
            S = r[4],
            M = r[7],
            b = r[2],
            B = r[5],
            R = r[8];
        return s[0] = o * y + a * _ + l * b, s[3] = o * A + a * S + l * B, s[6] = o * x + a * M + l * R, s[1] = c * y + d * _ + h * b, s[4] = c * A + d * S + h * B, s[7] = c * x + d * M + h * R, s[2] = p * y + m * _ + v * b, s[5] = p * A + m * S + v * B, s[8] = p * x + m * M + v * R, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            d = e[8];
        return t * o * d - t * a * c - i * s * d + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            d = e[8],
            h = d * o - a * c,
            p = a * l - d * s,
            m = c * s - o * l,
            v = t * h + i * p + r * m;
        if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const y = 1 / v;
        return e[0] = h * y, e[1] = (r * c - d * i) * y, e[2] = (a * i - r * o) * y, e[3] = p * y, e[4] = (d * t - r * l) * y, e[5] = (r * s - a * t) * y, e[6] = m * y, e[7] = (i * l - c * t) * y, e[8] = (o * t - i * s) * y, this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s),
            c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1), this
    }
    scale(e, t) {
        return this.premultiply(Py.makeScale(e, t)), this
    }
    rotate(e) {
        return this.premultiply(Py.makeRotation(-e)), this
    }
    translate(e, t) {
        return this.premultiply(Py.makeTranslation(e, t)), this
    }
    makeTranslation(e, t) {
        return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
    }
    makeRotation(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Py = new li;

function kP(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535) return !0;
    return !1
}
const CN = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};

function lu(n, e) {
    return new CN[n](e)
}

function Kf(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}

function Qa(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}

function dm(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
const Ry = {
        [Tr]: {
            [Du]: Qa
        },
        [Du]: {
            [Tr]: dm
        }
    },
    Zn = {
        legacyMode: !0,
        get workingColorSpace() {
            return Du
        },
        set workingColorSpace(n) {
            console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
        },
        convert: function(n, e, t) {
            if (this.legacyMode || e === t || !e || !t) return n;
            if (Ry[e] && Ry[e][t] !== void 0) {
                const i = Ry[e][t];
                return n.r = i(n.r), n.g = i(n.g), n.b = i(n.b), n
            }
            throw new Error("Unsupported color space conversion.")
        },
        fromWorkingColorSpace: function(n, e) {
            return this.convert(n, this.workingColorSpace, e)
        },
        toWorkingColorSpace: function(n, e) {
            return this.convert(n, e, this.workingColorSpace)
        }
    },
    NP = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Mn = {
        r: 0,
        g: 0,
        b: 0
    },
    Sr = {
        h: 0,
        s: 0,
        l: 0
    },
    $h = {
        h: 0,
        s: 0,
        l: 0
    };

function Iy(n, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}

function ep(n, e) {
    return e.r = n.r, e.g = n.g, e.b = n.b, e
}
class Ie {
    constructor(e, t, i) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this
    }
    setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this
    }
    setHex(e, t = Tr) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Zn.toWorkingColorSpace(this, t), this
    }
    setRGB(e, t, i, r = Zn.workingColorSpace) {
        return this.r = e, this.g = t, this.b = i, Zn.toWorkingColorSpace(this, r), this
    }
    setHSL(e, t, i, r = Zn.workingColorSpace) {
        if (e = $1(e, 1), t = gn(t, 0, 1), i = gn(i, 0, 1), t === 0) this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t,
                o = 2 * i - s;
            this.r = Iy(o, s, e + 1 / 3), this.g = Iy(o, s, e), this.b = Iy(o, s, e - 1 / 3)
        }
        return Zn.toWorkingColorSpace(this, r), this
    }
    setStyle(e, t = Tr) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1],
                a = r[2];
            switch (o) {
                case "rgb":
                case "rgba":
                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, Zn.toWorkingColorSpace(this, t), i(s[4]), this;
                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, Zn.toWorkingColorSpace(this, t), i(s[4]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                        const l = parseFloat(s[1]) / 360,
                            c = parseFloat(s[2]) / 100,
                            d = parseFloat(s[3]) / 100;
                        return i(s[4]), this.setHSL(l, c, d, t)
                    }
                    break
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1],
                o = s.length;
            if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, Zn.toWorkingColorSpace(this, t), this;
            if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, Zn.toWorkingColorSpace(this, t), this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t = Tr) {
        const i = NP[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this
    }
    copySRGBToLinear(e) {
        return this.r = Qa(e.r), this.g = Qa(e.g), this.b = Qa(e.b), this
    }
    copyLinearToSRGB(e) {
        return this.r = dm(e.r), this.g = dm(e.g), this.b = dm(e.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(e = Tr) {
        return Zn.fromWorkingColorSpace(ep(this, Mn), e), gn(Mn.r * 255, 0, 255) << 16 ^ gn(Mn.g * 255, 0, 255) << 8 ^ gn(Mn.b * 255, 0, 255) << 0
    }
    getHexString(e = Tr) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t = Zn.workingColorSpace) {
        Zn.fromWorkingColorSpace(ep(this, Mn), t);
        const i = Mn.r,
            r = Mn.g,
            s = Mn.b,
            o = Math.max(i, r, s),
            a = Math.min(i, r, s);
        let l, c;
        const d = (a + o) / 2;
        if (a === o) l = 0, c = 0;
        else {
            const h = o - a;
            switch (c = d <= .5 ? h / (o + a) : h / (2 - o - a), o) {
                case i:
                    l = (r - s) / h + (r < s ? 6 : 0);
                    break;
                case r:
                    l = (s - i) / h + 2;
                    break;
                case s:
                    l = (i - r) / h + 4;
                    break
            }
            l /= 6
        }
        return e.h = l, e.s = c, e.l = d, e
    }
    getRGB(e, t = Zn.workingColorSpace) {
        return Zn.fromWorkingColorSpace(ep(this, Mn), t), e.r = Mn.r, e.g = Mn.g, e.b = Mn.b, e
    }
    getStyle(e = Tr) {
        return Zn.fromWorkingColorSpace(ep(this, Mn), e), e !== Tr ? `color(${e} ${Mn.r} ${Mn.g} ${Mn.b})` : `rgb(${Mn.r*255|0},${Mn.g*255|0},${Mn.b*255|0})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(Sr), Sr.h += e, Sr.s += t, Sr.l += i, this.setHSL(Sr.h, Sr.s, Sr.l), this
    }
    add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this
    }
    addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
    }
    addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
    }
    multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
    }
    multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
    }
    lerpHSL(e, t) {
        this.getHSL(Sr), e.getHSL($h);
        const i = mf(Sr.h, $h.h, t),
            r = mf(Sr.s, $h.s, t),
            s = mf(Sr.l, $h.l, t);
        return this.setHSL(i, r, s), this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
    }
    toJSON() {
        return this.getHex()
    }*[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
Ie.NAMES = NP;
let Bl;
class t_ {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            Bl === void 0 && (Bl = Kf("canvas")), Bl.width = e.width, Bl.height = e.height;
            const i = Bl.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Bl
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Kf("canvas");
            t.width = e.width, t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height),
                s = r.data;
            for (let o = 0; o < s.length; o++) s[o] = Qa(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0), t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Qa(t[i] / 255) * 255) : t[i] = Qa(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
    }
}
class Ua {
    constructor(e = null) {
        this.isSource = !0, this.uuid = Ui(), this.data = e, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const i = {
                uuid: this.uuid,
                url: ""
            },
            r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++) r[o].isDataTexture ? s.push(Ly(r[o].image)) : s.push(Ly(r[o]))
            } else s = Ly(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i), i
    }
}

function Ly(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? t_.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let EN = 0;
class Yt extends as {
    constructor(e = Yt.DEFAULT_IMAGE, t = Yt.DEFAULT_MAPPING, i = zn, r = zn, s = en, o = ss, a = xi, l = Vs, c = Yt.DEFAULT_ANISOTROPY, d = Ws) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: EN++
        }), this.uuid = Ui(), this.name = "", this.source = new Ua(e), this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new me(0, 0), this.repeat = new me(1, 1), this.center = new me(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new li, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Eg) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case Ho:
                e.x = e.x - Math.floor(e.x);
                break;
            case zn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Ru:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case Ho:
                e.y = e.y - Math.floor(e.y);
                break;
            case zn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Ru:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
        }
        return this.flipY && (e.y = 1 - e.y), e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, this.source.needsUpdate = !0)
    }
}
Yt.DEFAULT_IMAGE = null;
Yt.DEFAULT_MAPPING = Eg;
Yt.DEFAULT_ANISOTROPY = 1;
class kt {
    constructor(e = 0, t = 0, i = 0, r = 1) {
        kt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e, this.y = t, this.z = i, this.w = r, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setW(e) {
        return this.w = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = this.w,
            o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements,
            c = l[0],
            d = l[4],
            h = l[8],
            p = l[1],
            m = l[5],
            v = l[9],
            y = l[2],
            A = l[6],
            x = l[10];
        if (Math.abs(d - p) < .01 && Math.abs(h - y) < .01 && Math.abs(v - A) < .01) {
            if (Math.abs(d + p) < .1 && Math.abs(h + y) < .1 && Math.abs(v + A) < .1 && Math.abs(c + m + x - 3) < .1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const S = (c + 1) / 2,
                M = (m + 1) / 2,
                b = (x + 1) / 2,
                B = (d + p) / 4,
                R = (h + y) / 4,
                E = (v + A) / 4;
            return S > M && S > b ? S < .01 ? (i = 0, r = .707106781, s = .707106781) : (i = Math.sqrt(S), r = B / i, s = R / i) : M > b ? M < .01 ? (i = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(M), i = B / r, s = E / r) : b < .01 ? (i = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(b), i = R / s, r = E / s), this.set(i, r, s, t), this
        }
        let _ = Math.sqrt((A - v) * (A - v) + (h - y) * (h - y) + (p - d) * (p - d));
        return Math.abs(_) < .001 && (_ = 1), this.x = (A - v) / _, this.y = (h - y) / _, this.z = (p - d) / _, this.w = Math.acos((c + m + x - 1) / 2), this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class Nr extends as {
    constructor(e = 1, t = 1, i = {}) {
        super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new kt(0, 0, e, t), this.scissorTest = !1, this.viewport = new kt(0, 0, e, t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new Yt(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : en, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0
    }
    setSize(e, t, i = 1) {
        (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Ua(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Bg extends Yt {
    constructor(e = null, t = 1, i = 1, r = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        }, this.magFilter = fn, this.minFilter = fn, this.wrapR = zn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class bN extends Nr {
    constructor(e = 1, t = 1, i = 1) {
        super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new Bg(null, e, t, i), this.texture.isRenderTargetTexture = !0
    }
}
class n_ extends Yt {
    constructor(e = null, t = 1, i = 1, r = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        }, this.magFilter = fn, this.minFilter = fn, this.wrapR = zn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class TN extends Nr {
    constructor(e = 1, t = 1, i = 1) {
        super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new n_(null, e, t, i), this.texture.isRenderTargetTexture = !0
    }
}
class BN extends Nr {
    constructor(e = 1, t = 1, i = 1, r = {}) {
        super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
        const s = this.texture;
        this.texture = [];
        for (let o = 0; o < i; o++) this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0
    }
    setSize(e, t, i = 1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e, this.height = t, this.depth = i;
            for (let r = 0, s = this.texture.length; r < s; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
    }
    copy(e) {
        this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
        for (let t = 0, i = e.texture.length; t < i; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
        return this
    }
}
class Hn {
    constructor(e = 0, t = 0, i = 0, r = 1) {
        this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0],
            c = i[r + 1],
            d = i[r + 2],
            h = i[r + 3];
        const p = s[o + 0],
            m = s[o + 1],
            v = s[o + 2],
            y = s[o + 3];
        if (a === 0) {
            e[t + 0] = l, e[t + 1] = c, e[t + 2] = d, e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = p, e[t + 1] = m, e[t + 2] = v, e[t + 3] = y;
            return
        }
        if (h !== y || l !== p || c !== m || d !== v) {
            let A = 1 - a;
            const x = l * p + c * m + d * v + h * y,
                _ = x >= 0 ? 1 : -1,
                S = 1 - x * x;
            if (S > Number.EPSILON) {
                const b = Math.sqrt(S),
                    B = Math.atan2(b, x * _);
                A = Math.sin(A * B) / b, a = Math.sin(a * B) / b
            }
            const M = a * _;
            if (l = l * A + p * M, c = c * A + m * M, d = d * A + v * M, h = h * A + y * M, A === 1 - a) {
                const b = 1 / Math.sqrt(l * l + c * c + d * d + h * h);
                l *= b, c *= b, d *= b, h *= b
            }
        }
        e[t] = l, e[t + 1] = c, e[t + 2] = d, e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r],
            l = i[r + 1],
            c = i[r + 2],
            d = i[r + 3],
            h = s[o],
            p = s[o + 1],
            m = s[o + 2],
            v = s[o + 3];
        return e[t] = a * v + d * h + l * m - c * p, e[t + 1] = l * v + d * p + c * h - a * m, e[t + 2] = c * v + d * m + a * p - l * h, e[t + 3] = d * v - a * h - l * p - c * m, e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e, this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
    }
    setFromEuler(e, t) {
        const i = e._x,
            r = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(i / 2),
            d = a(r / 2),
            h = a(s / 2),
            p = l(i / 2),
            m = l(r / 2),
            v = l(s / 2);
        switch (o) {
            case "XYZ":
                this._x = p * d * h + c * m * v, this._y = c * m * h - p * d * v, this._z = c * d * v + p * m * h, this._w = c * d * h - p * m * v;
                break;
            case "YXZ":
                this._x = p * d * h + c * m * v, this._y = c * m * h - p * d * v, this._z = c * d * v - p * m * h, this._w = c * d * h + p * m * v;
                break;
            case "ZXY":
                this._x = p * d * h - c * m * v, this._y = c * m * h + p * d * v, this._z = c * d * v + p * m * h, this._w = c * d * h - p * m * v;
                break;
            case "ZYX":
                this._x = p * d * h - c * m * v, this._y = c * m * h + p * d * v, this._z = c * d * v - p * m * h, this._w = c * d * h + p * m * v;
                break;
            case "YZX":
                this._x = p * d * h + c * m * v, this._y = c * m * h + p * d * v, this._z = c * d * v - p * m * h, this._w = c * d * h - p * m * v;
                break;
            case "XZY":
                this._x = p * d * h - c * m * v, this._y = c * m * h - p * d * v, this._z = c * d * v + p * m * h, this._w = c * d * h + p * m * v;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t !== !1 && this._onChangeCallback(), this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2,
            r = Math.sin(i);
        return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this
    }
    setFromRotationMatrix(e) {
        const t = e.elements,
            i = t[0],
            r = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            d = t[6],
            h = t[10],
            p = i + a + h;
        if (p > 0) {
            const m = .5 / Math.sqrt(p + 1);
            this._w = .25 / m, this._x = (d - l) * m, this._y = (s - c) * m, this._z = (o - r) * m
        } else if (i > a && i > h) {
            const m = 2 * Math.sqrt(1 + i - a - h);
            this._w = (d - l) / m, this._x = .25 * m, this._y = (r + o) / m, this._z = (s + c) / m
        } else if (a > h) {
            const m = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - c) / m, this._x = (r + o) / m, this._y = .25 * m, this._z = (l + d) / m
        } else {
            const m = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / m, this._x = (s + c) / m, this._y = (l + d) / m, this._z = .25 * m
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(gn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0) return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x,
            r = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            d = t._w;
        return this._x = i * d + o * a + r * c - s * l, this._y = r * d + o * l + s * a - i * c, this._z = s * d + o * c + i * l - r * a, this._w = o * d - i * a - r * l - s * c, this._onChangeCallback(), this
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const i = this._x,
            r = this._y,
            s = this._z,
            o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * o + t * this._w, this._x = m * i + t * this._x, this._y = m * r + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this
        }
        const c = Math.sqrt(l),
            d = Math.atan2(c, a),
            h = Math.sin((1 - t) * d) / c,
            p = Math.sin(t * d) / c;
        return this._w = o * h + this._w * p, this._x = i * h + this._x * p, this._y = r * h + this._y * p, this._z = s * h + this._z * p, this._onChangeCallback(), this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = Math.random(),
            t = Math.sqrt(1 - e),
            i = Math.sqrt(e),
            r = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}
class D {
    constructor(e = 0, t = 0, i = 0) {
        D.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
    }
    applyEuler(e) {
        return this.applyQuaternion(vC.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(vC.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this
    }
    applyQuaternion(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * r - a * i,
            d = l * i + a * t - s * r,
            h = l * r + s * i - o * t,
            p = -s * t - o * i - a * r;
        return this.x = c * l + p * -s + d * -a - h * -o, this.y = d * l + p * -o + h * -s - c * -a, this.z = h * l + p * -a + c * -o - d * -s, this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize()
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
        return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return Dy.copy(this).projectOnVector(e), this.sub(Dy)
    }
    reflect(e) {
        return this.sub(Dy.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(gn(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            i = this.y - e.y,
            r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = i, this.z = r, this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection() {
        const e = (Math.random() - .5) * 2,
            t = Math.random() * Math.PI * 2,
            i = Math.sqrt(1 - e ** 2);
        return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}
const Dy = new D,
    vC = new Hn;
class Yo {
    constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = e, this.max = t
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromArray(e) {
        let t = 1 / 0,
            i = 1 / 0,
            r = 1 / 0,
            s = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
        for (let l = 0, c = e.length; l < c; l += 3) {
            const d = e[l],
                h = e[l + 1],
                p = e[l + 2];
            d < t && (t = d), h < i && (i = h), p < r && (r = p), d > s && (s = d), h > o && (o = h), p > a && (a = p)
        }
        return this.min.set(t, i, r), this.max.set(s, o, a), this
    }
    setFromBufferAttribute(e) {
        let t = 1 / 0,
            i = 1 / 0,
            r = 1 / 0,
            s = -1 / 0,
            o = -1 / 0,
            a = -1 / 0;
        for (let l = 0, c = e.count; l < c; l++) {
            const d = e.getX(l),
                h = e.getY(l),
                p = e.getZ(l);
            d < t && (t = d), h < i && (i = h), p < r && (r = p), d > s && (s = d), h > o && (o = h), p > a && (a = p)
        }
        return this.min.set(t, i, r), this.max.set(s, o, a), this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = da.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0)
            if (t && i.attributes != null && i.attributes.position !== void 0) {
                const s = i.attributes.position;
                for (let o = 0, a = s.count; o < a; o++) da.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(da)
            } else i.boundingBox === null && i.computeBoundingBox(), Fy.copy(i.boundingBox), Fy.applyMatrix4(e.matrixWorld), this.union(Fy);
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, da), da.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(Pc), tp.subVectors(this.max, Pc), Pl.subVectors(e.a, Pc), Rl.subVectors(e.b, Pc), Il.subVectors(e.c, Pc), so.subVectors(Rl, Pl), oo.subVectors(Il, Rl), ha.subVectors(Pl, Il);
        let t = [0, -so.z, so.y, 0, -oo.z, oo.y, 0, -ha.z, ha.y, so.z, 0, -so.x, oo.z, 0, -oo.x, ha.z, 0, -ha.x, -so.y, so.x, 0, -oo.y, oo.x, 0, -ha.y, ha.x, 0];
        return !ky(t, Pl, Rl, Il, tp) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !ky(t, Pl, Rl, Il, tp)) ? !1 : (np.crossVectors(so, oo), t = [np.x, np.y, np.z], ky(t, Pl, Rl, Il, tp))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return da.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center), e.radius = this.getSize(da).length() * .5, e
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (vs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), vs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), vs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), vs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), vs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), vs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), vs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), vs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(vs), this)
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const vs = [new D, new D, new D, new D, new D, new D, new D, new D],
    da = new D,
    Fy = new Yo,
    Pl = new D,
    Rl = new D,
    Il = new D,
    so = new D,
    oo = new D,
    ha = new D,
    Pc = new D,
    tp = new D,
    np = new D,
    pa = new D;

function ky(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        pa.fromArray(n, s);
        const a = r.x * Math.abs(pa.x) + r.y * Math.abs(pa.y) + r.z * Math.abs(pa.z),
            l = e.dot(pa),
            c = t.dot(pa),
            d = i.dot(pa);
        if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > a) return !1
    }
    return !0
}
const PN = new Yo,
    Rc = new D,
    Ny = new D;
class Zo {
    constructor(e = new D, t = -1) {
        this.center = e, this.radius = t
    }
    set(e, t) {
        return this.center.copy(e), this.radius = t, this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : PN.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r), this
    }
    copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
    }
    translate(e) {
        return this.center.add(e), this
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
        Rc.subVectors(e, this.center);
        const t = Rc.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
                r = (i - this.radius) * .5;
            this.center.addScaledVector(Rc, r / i), this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Ny.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Rc.copy(e.center).add(Ny)), this.expandByPoint(Rc.copy(e.center).sub(Ny))), this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const As = new D,
    Oy = new D,
    ip = new D,
    ao = new D,
    Uy = new D,
    rp = new D,
    zy = new D;
class gd {
    constructor(e = new D, t = new D(0, 0, -1)) {
        this.origin = e, this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this
    }
    recast(e) {
        return this.origin.copy(this.at(e, As)), this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = As.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (As.copy(this.direction).multiplyScalar(t).add(this.origin), As.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        Oy.copy(e).add(t).multiplyScalar(.5), ip.copy(t).sub(e).normalize(), ao.copy(this.origin).sub(Oy);
        const s = e.distanceTo(t) * .5,
            o = -this.direction.dot(ip),
            a = ao.dot(this.direction),
            l = -ao.dot(ip),
            c = ao.lengthSq(),
            d = Math.abs(1 - o * o);
        let h, p, m, v;
        if (d > 0)
            if (h = o * l - a, p = o * a - l, v = s * d, h >= 0)
                if (p >= -v)
                    if (p <= v) {
                        const y = 1 / d;
                        h *= y, p *= y, m = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * l) + c
                    } else p = s, h = Math.max(0, -(o * p + a)), m = -h * h + p * (p + 2 * l) + c;
        else p = -s, h = Math.max(0, -(o * p + a)), m = -h * h + p * (p + 2 * l) + c;
        else p <= -v ? (h = Math.max(0, -(-o * s + a)), p = h > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -h * h + p * (p + 2 * l) + c) : p <= v ? (h = 0, p = Math.min(Math.max(-s, -l), s), m = p * (p + 2 * l) + c) : (h = Math.max(0, -(o * s + a)), p = h > 0 ? s : Math.min(Math.max(-s, -l), s), m = -h * h + p * (p + 2 * l) + c);
        else p = o > 0 ? -s : s, h = Math.max(0, -(o * p + a)), m = -h * h + p * (p + 2 * l) + c;
        return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(ip).multiplyScalar(p).add(Oy), m
    }
    intersectSphere(e, t) {
        As.subVectors(e.center, this.origin);
        const i = As.dot(this.direction),
            r = As.dot(As) - i * i,
            s = e.radius * e.radius;
        if (r > s) return null;
        const o = Math.sqrt(s - r),
            a = i - o,
            l = i + o;
        return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x,
            d = 1 / this.direction.y,
            h = 1 / this.direction.z,
            p = this.origin;
        return c >= 0 ? (i = (e.min.x - p.x) * c, r = (e.max.x - p.x) * c) : (i = (e.max.x - p.x) * c, r = (e.min.x - p.x) * c), d >= 0 ? (s = (e.min.y - p.y) * d, o = (e.max.y - p.y) * d) : (s = (e.max.y - p.y) * d, o = (e.min.y - p.y) * d), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), h >= 0 ? (a = (e.min.z - p.z) * h, l = (e.max.z - p.z) * h) : (a = (e.max.z - p.z) * h, l = (e.min.z - p.z) * h), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, As) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        Uy.subVectors(t, e), rp.subVectors(i, e), zy.crossVectors(Uy, rp);
        let o = this.direction.dot(zy),
            a;
        if (o > 0) {
            if (r) return null;
            a = 1
        } else if (o < 0) a = -1, o = -o;
        else return null;
        ao.subVectors(this.origin, e);
        const l = a * this.direction.dot(rp.crossVectors(ao, rp));
        if (l < 0) return null;
        const c = a * this.direction.dot(Uy.cross(ao));
        if (c < 0 || l + c > o) return null;
        const d = -a * ao.dot(zy);
        return d < 0 ? null : this.at(d / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class rt {
    constructor() {
        rt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, i, r, s, o, a, l, c, d, h, p, m, v, y, A) {
        const x = this.elements;
        return x[0] = e, x[4] = t, x[8] = i, x[12] = r, x[1] = s, x[5] = o, x[9] = a, x[13] = l, x[2] = c, x[6] = d, x[10] = h, x[14] = p, x[3] = m, x[7] = v, x[11] = y, x[15] = A, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return new rt().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements,
            i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
    }
    copyPosition(e) {
        const t = this.elements,
            i = e.elements;
        return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(e) {
        const t = this.elements,
            i = e.elements,
            r = 1 / Ll.setFromMatrixColumn(e, 0).length(),
            s = 1 / Ll.setFromMatrixColumn(e, 1).length(),
            o = 1 / Ll.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromEuler(e) {
        const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z,
            o = Math.cos(i),
            a = Math.sin(i),
            l = Math.cos(r),
            c = Math.sin(r),
            d = Math.cos(s),
            h = Math.sin(s);
        if (e.order === "XYZ") {
            const p = o * d,
                m = o * h,
                v = a * d,
                y = a * h;
            t[0] = l * d, t[4] = -l * h, t[8] = c, t[1] = m + v * c, t[5] = p - y * c, t[9] = -a * l, t[2] = y - p * c, t[6] = v + m * c, t[10] = o * l
        } else if (e.order === "YXZ") {
            const p = l * d,
                m = l * h,
                v = c * d,
                y = c * h;
            t[0] = p + y * a, t[4] = v * a - m, t[8] = o * c, t[1] = o * h, t[5] = o * d, t[9] = -a, t[2] = m * a - v, t[6] = y + p * a, t[10] = o * l
        } else if (e.order === "ZXY") {
            const p = l * d,
                m = l * h,
                v = c * d,
                y = c * h;
            t[0] = p - y * a, t[4] = -o * h, t[8] = v + m * a, t[1] = m + v * a, t[5] = o * d, t[9] = y - p * a, t[2] = -o * c, t[6] = a, t[10] = o * l
        } else if (e.order === "ZYX") {
            const p = o * d,
                m = o * h,
                v = a * d,
                y = a * h;
            t[0] = l * d, t[4] = v * c - m, t[8] = p * c + y, t[1] = l * h, t[5] = y * c + p, t[9] = m * c - v, t[2] = -c, t[6] = a * l, t[10] = o * l
        } else if (e.order === "YZX") {
            const p = o * l,
                m = o * c,
                v = a * l,
                y = a * c;
            t[0] = l * d, t[4] = y - p * h, t[8] = v * h + m, t[1] = h, t[5] = o * d, t[9] = -a * d, t[2] = -c * d, t[6] = m * h + v, t[10] = p - y * h
        } else if (e.order === "XZY") {
            const p = o * l,
                m = o * c,
                v = a * l,
                y = a * c;
            t[0] = l * d, t[4] = -h, t[8] = c * d, t[1] = p * h + y, t[5] = o * d, t[9] = m * h - v, t[2] = v * h - m, t[6] = a * d, t[10] = y * h + p
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(RN, e, IN)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return Ii.subVectors(e, t), Ii.lengthSq() === 0 && (Ii.z = 1), Ii.normalize(), lo.crossVectors(i, Ii), lo.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ii.x += 1e-4 : Ii.z += 1e-4, Ii.normalize(), lo.crossVectors(i, Ii)), lo.normalize(), sp.crossVectors(Ii, lo), r[0] = lo.x, r[4] = sp.x, r[8] = Ii.x, r[1] = lo.y, r[5] = sp.y, r[9] = Ii.y, r[2] = lo.z, r[6] = sp.z, r[10] = Ii.z, this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[4],
            l = i[8],
            c = i[12],
            d = i[1],
            h = i[5],
            p = i[9],
            m = i[13],
            v = i[2],
            y = i[6],
            A = i[10],
            x = i[14],
            _ = i[3],
            S = i[7],
            M = i[11],
            b = i[15],
            B = r[0],
            R = r[4],
            E = r[8],
            P = r[12],
            I = r[1],
            z = r[5],
            Z = r[9],
            W = r[13],
            G = r[2],
            K = r[6],
            te = r[10],
            se = r[14],
            k = r[3],
            V = r[7],
            J = r[11],
            ie = r[15];
        return s[0] = o * B + a * I + l * G + c * k, s[4] = o * R + a * z + l * K + c * V, s[8] = o * E + a * Z + l * te + c * J, s[12] = o * P + a * W + l * se + c * ie, s[1] = d * B + h * I + p * G + m * k, s[5] = d * R + h * z + p * K + m * V, s[9] = d * E + h * Z + p * te + m * J, s[13] = d * P + h * W + p * se + m * ie, s[2] = v * B + y * I + A * G + x * k, s[6] = v * R + y * z + A * K + x * V, s[10] = v * E + y * Z + A * te + x * J, s[14] = v * P + y * W + A * se + x * ie, s[3] = _ * B + S * I + M * G + b * k, s[7] = _ * R + S * z + M * K + b * V, s[11] = _ * E + S * Z + M * te + b * J, s[15] = _ * P + S * W + M * se + b * ie, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            i = e[4],
            r = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            d = e[2],
            h = e[6],
            p = e[10],
            m = e[14],
            v = e[3],
            y = e[7],
            A = e[11],
            x = e[15];
        return v * (+s * l * h - r * c * h - s * a * p + i * c * p + r * a * m - i * l * m) + y * (+t * l * m - t * c * p + s * o * p - r * o * m + r * c * d - s * l * d) + A * (+t * c * h - t * a * m - s * o * h + i * o * m + s * a * d - i * c * d) + x * (-r * a * d - t * l * h + t * a * p + r * o * h - i * o * p + i * l * d)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this
    }
    invert() {
        const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            d = e[8],
            h = e[9],
            p = e[10],
            m = e[11],
            v = e[12],
            y = e[13],
            A = e[14],
            x = e[15],
            _ = h * A * c - y * p * c + y * l * m - a * A * m - h * l * x + a * p * x,
            S = v * p * c - d * A * c - v * l * m + o * A * m + d * l * x - o * p * x,
            M = d * y * c - v * h * c + v * a * m - o * y * m - d * a * x + o * h * x,
            b = v * h * l - d * y * l - v * a * p + o * y * p + d * a * A - o * h * A,
            B = t * _ + i * S + r * M + s * b;
        if (B === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / B;
        return e[0] = _ * R, e[1] = (y * p * s - h * A * s - y * r * m + i * A * m + h * r * x - i * p * x) * R, e[2] = (a * A * s - y * l * s + y * r * c - i * A * c - a * r * x + i * l * x) * R, e[3] = (h * l * s - a * p * s - h * r * c + i * p * c + a * r * m - i * l * m) * R, e[4] = S * R, e[5] = (d * A * s - v * p * s + v * r * m - t * A * m - d * r * x + t * p * x) * R, e[6] = (v * l * s - o * A * s - v * r * c + t * A * c + o * r * x - t * l * x) * R, e[7] = (o * p * s - d * l * s + d * r * c - t * p * c - o * r * m + t * l * m) * R, e[8] = M * R, e[9] = (v * h * s - d * y * s - v * i * m + t * y * m + d * i * x - t * h * x) * R, e[10] = (o * y * s - v * a * s + v * i * c - t * y * c - o * i * x + t * a * x) * R, e[11] = (d * a * s - o * h * s - d * i * c + t * h * c + o * i * m - t * a * m) * R, e[12] = b * R, e[13] = (d * y * r - v * h * r + v * i * p - t * y * p - d * i * A + t * h * A) * R, e[14] = (v * a * r - o * y * r - v * i * l + t * y * l + o * i * A - t * a * A) * R, e[15] = (o * h * r - d * a * r + d * i * l - t * h * l - o * i * p + t * a * p) * R, this
    }
    scale(e) {
        const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z;
        return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
    }
    makeRotationX(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
    }
    makeRotationY(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(e) {
        const t = Math.cos(e),
            i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t),
            r = Math.sin(t),
            s = 1 - i,
            o = e.x,
            a = e.y,
            l = e.z,
            c = s * o,
            d = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, d * a + i, d * l - r * o, 0, c * l - r * a, d * l + r * o, s * l * l + i, 0, 0, 0, 0, 1), this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this
    }
    compose(e, t, i) {
        const r = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = s + s,
            d = o + o,
            h = a + a,
            p = s * c,
            m = s * d,
            v = s * h,
            y = o * d,
            A = o * h,
            x = a * h,
            _ = l * c,
            S = l * d,
            M = l * h,
            b = i.x,
            B = i.y,
            R = i.z;
        return r[0] = (1 - (y + x)) * b, r[1] = (m + M) * b, r[2] = (v - S) * b, r[3] = 0, r[4] = (m - M) * B, r[5] = (1 - (p + x)) * B, r[6] = (A + _) * B, r[7] = 0, r[8] = (v + S) * R, r[9] = (A - _) * R, r[10] = (1 - (p + y)) * R, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = Ll.set(r[0], r[1], r[2]).length();
        const o = Ll.set(r[4], r[5], r[6]).length(),
            a = Ll.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Mr.copy(this);
        const c = 1 / s,
            d = 1 / o,
            h = 1 / a;
        return Mr.elements[0] *= c, Mr.elements[1] *= c, Mr.elements[2] *= c, Mr.elements[4] *= d, Mr.elements[5] *= d, Mr.elements[6] *= d, Mr.elements[8] *= h, Mr.elements[9] *= h, Mr.elements[10] *= h, t.setFromRotationMatrix(Mr), i.x = s, i.y = o, i.z = a, this
    }
    makePerspective(e, t, i, r, s, o) {
        const a = this.elements,
            l = 2 * s / (t - e),
            c = 2 * s / (i - r),
            d = (t + e) / (t - e),
            h = (i + r) / (i - r),
            p = -(o + s) / (o - s),
            m = -2 * o * s / (o - s);
        return a[0] = l, a[4] = 0, a[8] = d, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = p, a[14] = m, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
    }
    makeOrthographic(e, t, i, r, s, o) {
        const a = this.elements,
            l = 1 / (t - e),
            c = 1 / (i - r),
            d = 1 / (o - s),
            h = (t + e) * l,
            p = (i + r) * c,
            m = (o + s) * d;
        return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -p, a[2] = 0, a[6] = 0, a[10] = -2 * d, a[14] = -m, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
    }
    equals(e) {
        const t = this.elements,
            i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
    }
}
const Ll = new D,
    Mr = new rt,
    RN = new D(0, 0, 0),
    IN = new D(1, 1, 1),
    lo = new D,
    sp = new D,
    Ii = new D,
    AC = new rt,
    xC = new Hn;
class ll {
    constructor(e = 0, t = 0, i = 0, r = ll.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e, this._onChangeCallback()
    }
    set(e, t, i, r = this._order) {
        return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(e, t = this._order, i = !0) {
        const r = e.elements,
            s = r[0],
            o = r[4],
            a = r[8],
            l = r[1],
            c = r[5],
            d = r[9],
            h = r[2],
            p = r[6],
            m = r[10];
        switch (t) {
            case "XYZ":
                this._y = Math.asin(gn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-d, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, c), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-gn(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(gn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-h, m), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
                break;
            case "ZYX":
                this._y = Math.asin(-gn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
                break;
            case "YZX":
                this._z = Math.asin(gn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, m));
                break;
            case "XZY":
                this._z = Math.asin(-gn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, m), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t, i === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(e, t, i) {
        return AC.makeRotationFromQuaternion(e), this.setFromRotationMatrix(AC, t, i)
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return xC.setFromEuler(this), this.setFromQuaternion(xC, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}
ll.DEFAULT_ORDER = "XYZ";
class Ka {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let LN = 0;
const _C = new D,
    Dl = new Hn,
    xs = new rt,
    op = new D,
    Ic = new D,
    DN = new D,
    FN = new Hn,
    wC = new D(1, 0, 0),
    SC = new D(0, 1, 0),
    MC = new D(0, 0, 1),
    kN = {
        type: "added"
    },
    CC = {
        type: "removed"
    };
class Tt extends as {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: LN++
        }), this.uuid = Ui(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Tt.DEFAULT_UP.clone();
        const e = new D,
            t = new ll,
            i = new Hn,
            r = new D(1, 1, 1);

        function s() {
            i.setFromEuler(t, !1)
        }

        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s), i._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new rt
            },
            normalMatrix: {
                value: new li
            }
        }), this.matrix = new rt, this.matrixWorld = new rt, this.matrixAutoUpdate = Tt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Ka, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Dl.setFromAxisAngle(e, t), this.quaternion.multiply(Dl), this
    }
    rotateOnWorldAxis(e, t) {
        return Dl.setFromAxisAngle(e, t), this.quaternion.premultiply(Dl), this
    }
    rotateX(e) {
        return this.rotateOnAxis(wC, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(SC, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(MC, e)
    }
    translateOnAxis(e, t) {
        return _C.copy(e).applyQuaternion(this.quaternion), this.position.add(_C.multiplyScalar(t)), this
    }
    translateX(e) {
        return this.translateOnAxis(wC, e)
    }
    translateY(e) {
        return this.translateOnAxis(SC, e)
    }
    translateZ(e) {
        return this.translateOnAxis(MC, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(xs.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? op.copy(e) : op.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1), Ic.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xs.lookAt(Ic, op, this.up) : xs.lookAt(op, Ic, this.up), this.quaternion.setFromRotationMatrix(xs), r && (xs.extractRotation(r.matrixWorld), Dl.setFromRotationMatrix(xs), this.quaternion.premultiply(Dl.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(kN)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(CC)), this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null, t.dispatchEvent(CC)
        }
        return this.children.length = 0, this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1), xs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), xs.multiply(e.parent.matrixWorld)), e.applyMatrix4(xs), this.add(e), e.updateWorldMatrix(!1, !0), this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0) return o
        }
    }
    getObjectsByProperty(e, t) {
        let i = [];
        this[e] === t && i.push(this);
        for (let r = 0, s = this.children.length; r < s; r++) {
            const o = this.children[r].getObjectsByProperty(e, t);
            o.length > 0 && (i = i.concat(o))
        }
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ic, e, DN), e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ic, FN, e), e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s];
                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string",
            i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, i.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));

        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
        }
        if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, d = l.length; c < d; c++) {
                        const h = l[c];
                        s(e.shapes, h)
                    } else s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++) a.push(s(e.materials, this.material[l]));
                r.material = a
            } else r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++) r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries),
                l = o(e.materials),
                c = o(e.textures),
                d = o(e.images),
                h = o(e.shapes),
                p = o(e.skeletons),
                m = o(e.animations),
                v = o(e.nodes);
            a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), d.length > 0 && (i.images = d), h.length > 0 && (i.shapes = h), p.length > 0 && (i.skeletons = p), m.length > 0 && (i.animations = m), v.length > 0 && (i.nodes = v)
        }
        return i.object = r, i;

        function o(a) {
            const l = [];
            for (const c in a) {
                const d = a[c];
                delete d.metadata, l.push(d)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t = !0) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
Tt.DEFAULT_UP = new D(0, 1, 0);
Tt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Cr = new D,
    _s = new D,
    Gy = new D,
    ws = new D,
    Fl = new D,
    kl = new D,
    EC = new D,
    Hy = new D,
    Vy = new D,
    Wy = new D;
class cr {
    constructor(e = new D, t = new D, i = new D) {
        this.a = e, this.b = t, this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t), Cr.subVectors(e, t), r.cross(Cr);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Cr.subVectors(r, t), _s.subVectors(i, t), Gy.subVectors(e, t);
        const o = Cr.dot(Cr),
            a = Cr.dot(_s),
            l = Cr.dot(Gy),
            c = _s.dot(_s),
            d = _s.dot(Gy),
            h = o * c - a * a;
        if (h === 0) return s.set(-2, -1, -1);
        const p = 1 / h,
            m = (c * l - a * d) * p,
            v = (o * d - a * l) * p;
        return s.set(1 - m - v, v, m)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, ws), ws.x >= 0 && ws.y >= 0 && ws.x + ws.y <= 1
    }
    static getUV(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, ws), l.set(0, 0), l.addScaledVector(s, ws.x), l.addScaledVector(o, ws.y), l.addScaledVector(a, ws.z), l
    }
    static isFrontFacing(e, t, i, r) {
        return Cr.subVectors(i, t), _s.subVectors(e, t), Cr.cross(_s).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
    }
    getArea() {
        return Cr.subVectors(this.c, this.b), _s.subVectors(this.a, this.b), Cr.cross(_s).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return cr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return cr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, i, r, s) {
        return cr.getUV(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return cr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return cr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a,
            r = this.b,
            s = this.c;
        let o, a;
        Fl.subVectors(r, i), kl.subVectors(s, i), Hy.subVectors(e, i);
        const l = Fl.dot(Hy),
            c = kl.dot(Hy);
        if (l <= 0 && c <= 0) return t.copy(i);
        Vy.subVectors(e, r);
        const d = Fl.dot(Vy),
            h = kl.dot(Vy);
        if (d >= 0 && h <= d) return t.copy(r);
        const p = l * h - d * c;
        if (p <= 0 && l >= 0 && d <= 0) return o = l / (l - d), t.copy(i).addScaledVector(Fl, o);
        Wy.subVectors(e, s);
        const m = Fl.dot(Wy),
            v = kl.dot(Wy);
        if (v >= 0 && m <= v) return t.copy(s);
        const y = m * c - l * v;
        if (y <= 0 && c >= 0 && v <= 0) return a = c / (c - v), t.copy(i).addScaledVector(kl, a);
        const A = d * v - m * h;
        if (A <= 0 && h - d >= 0 && m - v >= 0) return EC.subVectors(s, r), a = (h - d) / (h - d + (m - v)), t.copy(r).addScaledVector(EC, a);
        const x = 1 / (A + y + p);
        return o = y * x, a = p * x, t.copy(i).addScaledVector(Fl, o).addScaledVector(kl, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let NN = 0;
class wn extends as {
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: NN++
        }), this.uuid = Ui(), this.name = "", this.type = "Material", this.blending = Wa, this.side = rs, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = X1, this.blendDst = Q1, this.blendEquation = Pa, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Wm, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = DP, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = fm, this.stencilZFail = fm, this.stencilZPass = fm, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Wa && (i.blending = this.blending), this.side !== rs && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);

        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata, o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures),
                o = r(e.images);
            s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s) i[s] = t[s].clone()
        }
        return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class Ni extends wn {
    constructor(e) {
        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ie(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = md, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
const An = new D,
    ap = new me;
class Dt {
    constructor(e, t, i = !1) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Xf, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e, this
    }
    copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
    }
    copyAt(e, t, i) {
        e *= this.itemSize, i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e), this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++) ap.fromBufferAttribute(this, t), ap.applyMatrix3(e), this.setXY(t, ap.x, ap.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++) An.fromBufferAttribute(this, t), An.applyMatrix3(e), this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++) An.fromBufferAttribute(this, t), An.applyMatrix4(e), this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) An.fromBufferAttribute(this, t), An.applyNormalMatrix(e), this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) An.fromBufferAttribute(this, t), An.transformDirection(e), this.setXYZ(t, An.x, An.y, An.z);
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Is(t, this.array)), t
    }
    setX(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize] = t, this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Is(t, this.array)), t
    }
    setY(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 1] = t, this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Is(t, this.array)), t
    }
    setZ(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 2] = t, this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Is(t, this.array)), t
    }
    setW(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 3] = t, this
    }
    setXY(e, t, i) {
        return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== Xf && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class ON extends Dt {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class UN extends Dt {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class zN extends Dt {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class GN extends Dt {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class i_ extends Dt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class HN extends Dt {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class r_ extends Dt {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class VN extends Dt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0
    }
}
class We extends Dt {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
class WN extends Dt {
    constructor(e, t, i) {
        super(new Float64Array(e), t, i)
    }
}
let jN = 0;
const ir = new rt,
    jy = new Tt,
    Nl = new D,
    Li = new Yo,
    Lc = new Yo,
    Fn = new D;
class ut extends as {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: jN++
        }), this.uuid = Ui(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new(kP(e) ? r_ : i_)(e, 1) : this.index = e, this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t, this
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i = 0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new li().getNormalMatrix(e);
            i.applyNormalMatrix(s), i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(e) {
        return ir.makeRotationFromQuaternion(e), this.applyMatrix4(ir), this
    }
    rotateX(e) {
        return ir.makeRotationX(e), this.applyMatrix4(ir), this
    }
    rotateY(e) {
        return ir.makeRotationY(e), this.applyMatrix4(ir), this
    }
    rotateZ(e) {
        return ir.makeRotationZ(e), this.applyMatrix4(ir), this
    }
    translate(e, t, i) {
        return ir.makeTranslation(e, t, i), this.applyMatrix4(ir), this
    }
    scale(e, t, i) {
        return ir.makeScale(e, t, i), this.applyMatrix4(ir), this
    }
    lookAt(e) {
        return jy.lookAt(e), jy.updateMatrix(), this.applyMatrix4(jy.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Nl).negate(), this.translate(Nl.x, Nl.y, Nl.z), this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new We(t, 3)), this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Yo);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new D(-1 / 0, -1 / 0, -1 / 0), new D(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Li.setFromBufferAttribute(s), this.morphTargetsRelative ? (Fn.addVectors(this.boundingBox.min, Li.min), this.boundingBox.expandByPoint(Fn), Fn.addVectors(this.boundingBox.max, Li.max), this.boundingBox.expandByPoint(Fn)) : (this.boundingBox.expandByPoint(Li.min), this.boundingBox.expandByPoint(Li.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Zo);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new D, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Li.setFromBufferAttribute(e), t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Lc.setFromBufferAttribute(a), this.morphTargetsRelative ? (Fn.addVectors(Li.min, Lc.min), Li.expandByPoint(Fn), Fn.addVectors(Li.max, Lc.max), Li.expandByPoint(Fn)) : (Li.expandByPoint(Lc.min), Li.expandByPoint(Lc.max))
                }
            Li.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++) Fn.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(Fn));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s],
                        l = this.morphTargetsRelative;
                    for (let c = 0, d = a.count; c < d; c++) Fn.fromBufferAttribute(a, c), l && (Nl.fromBufferAttribute(e, c), Fn.add(Nl)), r = Math.max(r, i.distanceToSquared(Fn))
                }
            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index,
            t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = e.array,
            r = t.position.array,
            s = t.normal.array,
            o = t.uv.array,
            a = r.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Dt(new Float32Array(4 * a), 4));
        const l = this.getAttribute("tangent").array,
            c = [],
            d = [];
        for (let I = 0; I < a; I++) c[I] = new D, d[I] = new D;
        const h = new D,
            p = new D,
            m = new D,
            v = new me,
            y = new me,
            A = new me,
            x = new D,
            _ = new D;

        function S(I, z, Z) {
            h.fromArray(r, I * 3), p.fromArray(r, z * 3), m.fromArray(r, Z * 3), v.fromArray(o, I * 2), y.fromArray(o, z * 2), A.fromArray(o, Z * 2), p.sub(h), m.sub(h), y.sub(v), A.sub(v);
            const W = 1 / (y.x * A.y - A.x * y.y);
            isFinite(W) && (x.copy(p).multiplyScalar(A.y).addScaledVector(m, -y.y).multiplyScalar(W), _.copy(m).multiplyScalar(y.x).addScaledVector(p, -A.x).multiplyScalar(W), c[I].add(x), c[z].add(x), c[Z].add(x), d[I].add(_), d[z].add(_), d[Z].add(_))
        }
        let M = this.groups;
        M.length === 0 && (M = [{
            start: 0,
            count: i.length
        }]);
        for (let I = 0, z = M.length; I < z; ++I) {
            const Z = M[I],
                W = Z.start,
                G = Z.count;
            for (let K = W, te = W + G; K < te; K += 3) S(i[K + 0], i[K + 1], i[K + 2])
        }
        const b = new D,
            B = new D,
            R = new D,
            E = new D;

        function P(I) {
            R.fromArray(s, I * 3), E.copy(R);
            const z = c[I];
            b.copy(z), b.sub(R.multiplyScalar(R.dot(z))).normalize(), B.crossVectors(E, z);
            const W = B.dot(d[I]) < 0 ? -1 : 1;
            l[I * 4] = b.x, l[I * 4 + 1] = b.y, l[I * 4 + 2] = b.z, l[I * 4 + 3] = W
        }
        for (let I = 0, z = M.length; I < z; ++I) {
            const Z = M[I],
                W = Z.start,
                G = Z.count;
            for (let K = W, te = W + G; K < te; K += 3) P(i[K + 0]), P(i[K + 1]), P(i[K + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index,
            t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new Dt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
            else
                for (let p = 0, m = i.count; p < m; p++) i.setXYZ(p, 0, 0, 0);
            const r = new D,
                s = new D,
                o = new D,
                a = new D,
                l = new D,
                c = new D,
                d = new D,
                h = new D;
            if (e)
                for (let p = 0, m = e.count; p < m; p += 3) {
                    const v = e.getX(p + 0),
                        y = e.getX(p + 1),
                        A = e.getX(p + 2);
                    r.fromBufferAttribute(t, v), s.fromBufferAttribute(t, y), o.fromBufferAttribute(t, A), d.subVectors(o, s), h.subVectors(r, s), d.cross(h), a.fromBufferAttribute(i, v), l.fromBufferAttribute(i, y), c.fromBufferAttribute(i, A), a.add(d), l.add(d), c.add(d), i.setXYZ(v, a.x, a.y, a.z), i.setXYZ(y, l.x, l.y, l.z), i.setXYZ(A, c.x, c.y, c.z)
                } else
                    for (let p = 0, m = t.count; p < m; p += 3) r.fromBufferAttribute(t, p + 0), s.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), d.subVectors(o, s), h.subVectors(r, s), d.cross(h), i.setXYZ(p + 0, d.x, d.y, d.z), i.setXYZ(p + 1, d.x, d.y, d.z), i.setXYZ(p + 2, d.x, d.y, d.z);
            this.normalizeNormals(), i.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++) Fn.fromBufferAttribute(e, t), Fn.normalize(), e.setXYZ(t, Fn.x, Fn.y, Fn.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array,
                d = a.itemSize,
                h = a.normalized,
                p = new c.constructor(l.length * d);
            let m = 0,
                v = 0;
            for (let y = 0, A = l.length; y < A; y++) {
                a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * d;
                for (let x = 0; x < d; x++) p[v++] = c[m++]
            }
            return new Dt(p, d, h)
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const t = new ut,
            i = this.index.array,
            r = this.attributes;
        for (const a in r) {
            const l = r[a],
                c = e(l, i);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = [],
                c = s[a];
            for (let d = 0, h = c.length; d < h; d++) {
                const p = c[d],
                    m = e(p, i);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
                d = [];
            for (let h = 0, p = c.length; h < p; h++) {
                const m = c[h];
                d.push(m.toJSON(e.data))
            }
            d.length > 0 && (r[l] = d, s = !0)
        }
        s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const c in r) {
            const d = r[c];
            this.setAttribute(c, d.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const d = [],
                h = s[c];
            for (let p = 0, m = h.length; p < m; p++) d.push(h[p].clone(t));
            this.morphAttributes[c] = d
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, d = o.length; c < d; c++) {
            const h = o[c];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const bC = new rt,
    Ol = new gd,
    Jy = new Zo,
    Dc = new D,
    Fc = new D,
    kc = new D,
    Xy = new D,
    lp = new D,
    up = new me,
    cp = new me,
    fp = new me,
    Qy = new D,
    dp = new D;
class bn extends Tt {
    constructor(e = new ut, t = new Ni) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry,
            r = i.attributes.position,
            s = i.morphAttributes.position,
            o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            lp.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const d = a[l],
                    h = s[l];
                d !== 0 && (Xy.fromBufferAttribute(h, e), o ? lp.addScaledVector(Xy, d) : lp.addScaledVector(Xy.sub(t), d))
            }
            t.add(lp)
        }
        return this.isSkinnedMesh && this.boneTransform(e, t), t
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.material,
            s = this.matrixWorld;
        if (r === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), Jy.copy(i.boundingSphere), Jy.applyMatrix4(s), e.ray.intersectsSphere(Jy) === !1) || (bC.copy(s).invert(), Ol.copy(e.ray).applyMatrix4(bC), i.boundingBox !== null && Ol.intersectsBox(i.boundingBox) === !1)) return;
        let o;
        const a = i.index,
            l = i.attributes.position,
            c = i.attributes.uv,
            d = i.attributes.uv2,
            h = i.groups,
            p = i.drawRange;
        if (a !== null)
            if (Array.isArray(r))
                for (let m = 0, v = h.length; m < v; m++) {
                    const y = h[m],
                        A = r[y.materialIndex],
                        x = Math.max(y.start, p.start),
                        _ = Math.min(a.count, Math.min(y.start + y.count, p.start + p.count));
                    for (let S = x, M = _; S < M; S += 3) {
                        const b = a.getX(S),
                            B = a.getX(S + 1),
                            R = a.getX(S + 2);
                        o = hp(this, A, e, Ol, c, d, b, B, R), o && (o.faceIndex = Math.floor(S / 3), o.face.materialIndex = y.materialIndex, t.push(o))
                    }
                } else {
                    const m = Math.max(0, p.start),
                        v = Math.min(a.count, p.start + p.count);
                    for (let y = m, A = v; y < A; y += 3) {
                        const x = a.getX(y),
                            _ = a.getX(y + 1),
                            S = a.getX(y + 2);
                        o = hp(this, r, e, Ol, c, d, x, _, S), o && (o.faceIndex = Math.floor(y / 3), t.push(o))
                    }
                } else if (l !== void 0)
                    if (Array.isArray(r))
                        for (let m = 0, v = h.length; m < v; m++) {
                            const y = h[m],
                                A = r[y.materialIndex],
                                x = Math.max(y.start, p.start),
                                _ = Math.min(l.count, Math.min(y.start + y.count, p.start + p.count));
                            for (let S = x, M = _; S < M; S += 3) {
                                const b = S,
                                    B = S + 1,
                                    R = S + 2;
                                o = hp(this, A, e, Ol, c, d, b, B, R), o && (o.faceIndex = Math.floor(S / 3), o.face.materialIndex = y.materialIndex, t.push(o))
                            }
                        } else {
                            const m = Math.max(0, p.start),
                                v = Math.min(l.count, p.start + p.count);
                            for (let y = m, A = v; y < A; y += 3) {
                                const x = y,
                                    _ = y + 1,
                                    S = y + 2;
                                o = hp(this, r, e, Ol, c, d, x, _, S), o && (o.faceIndex = Math.floor(y / 3), t.push(o))
                            }
                        }
    }
}

function JN(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === Ci ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === rs, a), l === null) return null;
    dp.copy(a), dp.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(dp);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: dp.clone(),
        object: n
    }
}

function hp(n, e, t, i, r, s, o, a, l) {
    n.getVertexPosition(o, Dc), n.getVertexPosition(a, Fc), n.getVertexPosition(l, kc);
    const c = JN(n, e, t, i, Dc, Fc, kc, Qy);
    if (c) {
        r && (up.fromBufferAttribute(r, o), cp.fromBufferAttribute(r, a), fp.fromBufferAttribute(r, l), c.uv = cr.getUV(Qy, Dc, Fc, kc, up, cp, fp, new me)), s && (up.fromBufferAttribute(s, o), cp.fromBufferAttribute(s, a), fp.fromBufferAttribute(s, l), c.uv2 = cr.getUV(Qy, Dc, Fc, kc, up, cp, fp, new me));
        const d = {
            a: o,
            b: a,
            c: l,
            normal: new D,
            materialIndex: 0
        };
        cr.getNormal(Dc, Fc, kc, d.normal), c.face = d
    }
    return c
}
class qo extends ut {
    constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
        const l = [],
            c = [],
            d = [],
            h = [];
        let p = 0,
            m = 0;
        v("z", "y", "x", -1, -1, i, t, e, o, s, 0), v("z", "y", "x", 1, -1, i, t, -e, o, s, 1), v("x", "z", "y", 1, 1, e, i, t, r, o, 2), v("x", "z", "y", 1, -1, e, i, -t, r, o, 3), v("x", "y", "z", 1, -1, e, t, i, r, s, 4), v("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new We(c, 3)), this.setAttribute("normal", new We(d, 3)), this.setAttribute("uv", new We(h, 2));

        function v(y, A, x, _, S, M, b, B, R, E, P) {
            const I = M / R,
                z = b / E,
                Z = M / 2,
                W = b / 2,
                G = B / 2,
                K = R + 1,
                te = E + 1;
            let se = 0,
                k = 0;
            const V = new D;
            for (let J = 0; J < te; J++) {
                const ie = J * z - W;
                for (let j = 0; j < K; j++) {
                    const re = j * I - Z;
                    V[y] = re * _, V[A] = ie * S, V[x] = G, c.push(V.x, V.y, V.z), V[y] = 0, V[A] = 0, V[x] = B > 0 ? 1 : -1, d.push(V.x, V.y, V.z), h.push(j / R), h.push(1 - J / E), se += 1
                }
            }
            for (let J = 0; J < E; J++)
                for (let ie = 0; ie < R; ie++) {
                    const j = p + ie + K * J,
                        re = p + ie + K * (J + 1),
                        ve = p + (ie + 1) + K * (J + 1),
                        xe = p + (ie + 1) + K * J;
                    l.push(j, re, xe), l.push(re, ve, xe), k += 6
                }
            a.addGroup(m, k, P), m += k, p += se
        }
    }
    static fromJSON(e) {
        return new qo(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
    }
}

function Fu(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}

function si(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = Fu(n[t]);
        for (const r in i) e[r] = i[r]
    }
    return e
}

function XN(n) {
    const e = [];
    for (let t = 0; t < n.length; t++) e.push(n[t].clone());
    return e
}

function OP(n) {
    return n.getRenderTarget() === null && n.outputEncoding === Ct ? Tr : Du
}
const UP = {
    clone: Fu,
    merge: si
};
var QN = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    KN = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class os extends wn {
    constructor(e) {
        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = QN, this.fragmentShader = KN, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Fu(e.uniforms), this.uniformsGroups = XN(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
        const i = {};
        for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i), t
    }
}
class yd extends Tt {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new rt, this.projectionMatrix = new rt, this.projectionMatrixInverse = new rt
    }
    copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Gt extends yd {
    constructor(e = 50, t = 1, i = .1, r = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Qf * 2 * Math.atan(t), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Xa * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Qf * 2 * Math.atan(Math.tan(Xa * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Xa * .5 * this.fov) / this.zoom,
            i = 2 * t,
            r = this.aspect * i,
            s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
                c = o.fullHeight;
            s += o.offsetX * r / l, t -= o.offsetY * i / c, r *= o.width / l, i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
    }
}
const Ul = -90,
    zl = 1;
class s_ extends Tt {
    constructor(e, t, i) {
        super(), this.type = "CubeCamera", this.renderTarget = i;
        const r = new Gt(Ul, zl, e, t);
        r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r);
        const s = new Gt(Ul, zl, e, t);
        s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s);
        const o = new Gt(Ul, zl, e, t);
        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o);
        const a = new Gt(Ul, zl, e, t);
        a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a);
        const l = new Gt(Ul, zl, e, t);
        l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
        const c = new Gt(Ul, zl, e, t);
        c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, -1), this.add(c)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const i = this.renderTarget,
            [r, s, o, a, l, c] = this.children,
            d = e.getRenderTarget(),
            h = e.toneMapping,
            p = e.xr.enabled;
        e.toneMapping = Dr, e.xr.enabled = !1;
        const m = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, s), e.setRenderTarget(i, 2), e.render(t, o), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = m, e.setRenderTarget(i, 5), e.render(t, c), e.setRenderTarget(d), e.toneMapping = h, e.xr.enabled = p, i.texture.needsPMREMUpdate = !0
    }
}
class vd extends Yt {
    constructor(e, t, i, r, s, o, a, l, c, d) {
        e = e !== void 0 ? e : [], t = t !== void 0 ? t : zo, super(e, t, i, r, s, o, a, l, c, d), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class o_ extends Nr {
    constructor(e = 1, t = {}) {
        super(e, e, t), this.isWebGLCubeRenderTarget = !0;
        const i = {
                width: e,
                height: e,
                depth: 1
            },
            r = [i, i, i, i, i, i];
        this.texture = new vd(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : en
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        const i = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            },
            r = new qo(5, 5, 5),
            s = new os({
                name: "CubemapFromEquirect",
                uniforms: Fu(i.uniforms),
                vertexShader: i.vertexShader,
                fragmentShader: i.fragmentShader,
                side: Ci,
                blending: ks
            });
        s.uniforms.tEquirect.value = t;
        const o = new bn(r, s),
            a = t.minFilter;
        return t.minFilter === ss && (t.minFilter = en), new s_(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const Ky = new D,
    YN = new D,
    ZN = new li;
class vo {
    constructor(e = new D(1, 0, 0), t = 0) {
        this.isPlane = !0, this.normal = e, this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e), this.constant = t, this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i), this.constant = r, this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Ky.subVectors(i, t).cross(YN.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e), this
    }
    copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const i = e.delta(Ky),
            r = this.normal.dot(i);
        if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || ZN.getNormalMatrix(e),
            r = this.coplanarPoint(Ky).applyMatrix4(e),
            s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s), this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal), this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Gl = new Zo,
    pp = new D;
class Pg {
    constructor(e = new vo, t = new vo, i = new vo, r = new vo, s = new vo, o = new vo) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes,
            i = e.elements,
            r = i[0],
            s = i[1],
            o = i[2],
            a = i[3],
            l = i[4],
            c = i[5],
            d = i[6],
            h = i[7],
            p = i[8],
            m = i[9],
            v = i[10],
            y = i[11],
            A = i[12],
            x = i[13],
            _ = i[14],
            S = i[15];
        return t[0].setComponents(a - r, h - l, y - p, S - A).normalize(), t[1].setComponents(a + r, h + l, y + p, S + A).normalize(), t[2].setComponents(a + s, h + c, y + m, S + x).normalize(), t[3].setComponents(a - s, h - c, y - m, S - x).normalize(), t[4].setComponents(a - o, h - d, y - v, S - _).normalize(), t[5].setComponents(a + o, h + d, y + v, S + _).normalize(), this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(), Gl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Gl)
    }
    intersectsSprite(e) {
        return Gl.center.set(0, 0, 0), Gl.radius = .7071067811865476, Gl.applyMatrix4(e.matrixWorld), this.intersectsSphere(Gl)
    }
    intersectsSphere(e) {
        const t = this.planes,
            i = e.center,
            r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r) return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (pp.x = r.normal.x > 0 ? e.max.x : e.min.x, pp.y = r.normal.y > 0 ? e.max.y : e.min.y, pp.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(pp) < 0) return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0) return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}

function zP() {
    let n = null,
        e = !1,
        t = null,
        i = null;

    function r(s, o) {
        t(s, o), i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i), e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}

function qN(n, e) {
    const t = e.isWebGL2,
        i = new WeakMap;

    function r(c, d) {
        const h = c.array,
            p = c.usage,
            m = n.createBuffer();
        n.bindBuffer(d, m), n.bufferData(d, h, p), c.onUploadCallback();
        let v;
        if (h instanceof Float32Array) v = 5126;
        else if (h instanceof Uint16Array)
            if (c.isFloat16BufferAttribute)
                if (t) v = 5131;
                else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        else v = 5123;
        else if (h instanceof Int16Array) v = 5122;
        else if (h instanceof Uint32Array) v = 5125;
        else if (h instanceof Int32Array) v = 5124;
        else if (h instanceof Int8Array) v = 5120;
        else if (h instanceof Uint8Array) v = 5121;
        else if (h instanceof Uint8ClampedArray) v = 5121;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: m,
            type: v,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: c.version
        }
    }

    function s(c, d, h) {
        const p = d.array,
            m = d.updateRange;
        n.bindBuffer(h, c), m.count === -1 ? n.bufferSubData(h, 0, p) : (t ? n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)), m.count = -1), d.onUploadCallback()
    }

    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data), i.get(c)
    }

    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        const d = i.get(c);
        d && (n.deleteBuffer(d.buffer), i.delete(c))
    }

    function l(c, d) {
        if (c.isGLBufferAttribute) {
            const p = i.get(c);
            (!p || p.version < c.version) && i.set(c, {
                buffer: c.buffer,
                type: c.type,
                bytesPerElement: c.elementSize,
                version: c.version
            });
            return
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        const h = i.get(c);
        h === void 0 ? i.set(c, r(c, d)) : h.version < c.version && (s(h.buffer, c, d), h.version = c.version)
    }
    return {
        get: o,
        remove: a,
        update: l
    }
}
class Xu extends ut {
    constructor(e = 1, t = 1, i = 1, r = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2,
            o = t / 2,
            a = Math.floor(i),
            l = Math.floor(r),
            c = a + 1,
            d = l + 1,
            h = e / a,
            p = t / l,
            m = [],
            v = [],
            y = [],
            A = [];
        for (let x = 0; x < d; x++) {
            const _ = x * p - o;
            for (let S = 0; S < c; S++) {
                const M = S * h - s;
                v.push(M, -_, 0), y.push(0, 0, 1), A.push(S / a), A.push(1 - x / l)
            }
        }
        for (let x = 0; x < l; x++)
            for (let _ = 0; _ < a; _++) {
                const S = _ + c * x,
                    M = _ + c * (x + 1),
                    b = _ + 1 + c * (x + 1),
                    B = _ + 1 + c * x;
                m.push(S, M, B), m.push(M, b, B)
            }
        this.setIndex(m), this.setAttribute("position", new We(v, 3)), this.setAttribute("normal", new We(y, 3)), this.setAttribute("uv", new We(A, 2))
    }
    static fromJSON(e) {
        return new Xu(e.width, e.height, e.widthSegments, e.heightSegments)
    }
}
var $N = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
    eO = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    tO = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
    nO = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    iO = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    rO = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    sO = "vec3 transformed = vec3( position );",
    oO = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    aO = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
    lO = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    uO = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    cO = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
    fO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    dO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    hO = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    pO = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    mO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    gO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    yO = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    vO = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
    AO = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    xO = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    _O = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    wO = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
    SO = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    MO = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    CO = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    EO = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    bO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    TO = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif`,
    BO = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    PO = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    RO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    IO = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    LO = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    DO = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    FO = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    kO = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    NO = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    OO = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    UO = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    zO = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    GO = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    HO = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
    VO = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    WO = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    jO = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    JO = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    XO = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
    QO = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    KO = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    YO = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    ZO = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
    qO = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    $O = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    eU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    tU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    nU = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    iU = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    rU = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    sU = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    oU = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    aU = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    lU = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    uU = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    cU = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    fU = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    dU = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
    hU = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    pU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    mU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    gU = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    yU = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
    vU = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
    AU = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
    xU = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
    _U = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    wU = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    SU = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
    MU = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    CU = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    EU = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    bU = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    TU = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    BU = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    PU = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    RU = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    IU = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    LU = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    DU = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    FU = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
    kU = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    NU = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    OU = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    UU = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    zU = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    GU = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    HU = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
    VU = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
    WU = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
    jU = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
    JU = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    XU = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    QU = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
    KU = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
    YU = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const ZU = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    qU = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    $U = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    ez = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    tz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    nz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    iz = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    rz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    sz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    oz = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    az = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    lz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    uz = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    cz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    fz = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    dz = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    hz = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    pz = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    mz = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    gz = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    yz = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    vz = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    Az = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    xz = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    _z = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    wz = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Sz = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Mz = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Cz = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    Ez = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    bz = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Tz = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    Bz = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    Pz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    pt = {
        alphamap_fragment: $N,
        alphamap_pars_fragment: eO,
        alphatest_fragment: tO,
        alphatest_pars_fragment: nO,
        aomap_fragment: iO,
        aomap_pars_fragment: rO,
        begin_vertex: sO,
        beginnormal_vertex: oO,
        bsdfs: aO,
        iridescence_fragment: lO,
        bumpmap_pars_fragment: uO,
        clipping_planes_fragment: cO,
        clipping_planes_pars_fragment: fO,
        clipping_planes_pars_vertex: dO,
        clipping_planes_vertex: hO,
        color_fragment: pO,
        color_pars_fragment: mO,
        color_pars_vertex: gO,
        color_vertex: yO,
        common: vO,
        cube_uv_reflection_fragment: AO,
        defaultnormal_vertex: xO,
        displacementmap_pars_vertex: _O,
        displacementmap_vertex: wO,
        emissivemap_fragment: SO,
        emissivemap_pars_fragment: MO,
        encodings_fragment: CO,
        encodings_pars_fragment: EO,
        envmap_fragment: bO,
        envmap_common_pars_fragment: TO,
        envmap_pars_fragment: BO,
        envmap_pars_vertex: PO,
        envmap_physical_pars_fragment: HO,
        envmap_vertex: RO,
        fog_vertex: IO,
        fog_pars_vertex: LO,
        fog_fragment: DO,
        fog_pars_fragment: FO,
        gradientmap_pars_fragment: kO,
        lightmap_fragment: NO,
        lightmap_pars_fragment: OO,
        lights_lambert_fragment: UO,
        lights_lambert_pars_fragment: zO,
        lights_pars_begin: GO,
        lights_toon_fragment: VO,
        lights_toon_pars_fragment: WO,
        lights_phong_fragment: jO,
        lights_phong_pars_fragment: JO,
        lights_physical_fragment: XO,
        lights_physical_pars_fragment: QO,
        lights_fragment_begin: KO,
        lights_fragment_maps: YO,
        lights_fragment_end: ZO,
        logdepthbuf_fragment: qO,
        logdepthbuf_pars_fragment: $O,
        logdepthbuf_pars_vertex: eU,
        logdepthbuf_vertex: tU,
        map_fragment: nU,
        map_pars_fragment: iU,
        map_particle_fragment: rU,
        map_particle_pars_fragment: sU,
        metalnessmap_fragment: oU,
        metalnessmap_pars_fragment: aU,
        morphcolor_vertex: lU,
        morphnormal_vertex: uU,
        morphtarget_pars_vertex: cU,
        morphtarget_vertex: fU,
        normal_fragment_begin: dU,
        normal_fragment_maps: hU,
        normal_pars_fragment: pU,
        normal_pars_vertex: mU,
        normal_vertex: gU,
        normalmap_pars_fragment: yU,
        clearcoat_normal_fragment_begin: vU,
        clearcoat_normal_fragment_maps: AU,
        clearcoat_pars_fragment: xU,
        iridescence_pars_fragment: _U,
        output_fragment: wU,
        packing: SU,
        premultiplied_alpha_fragment: MU,
        project_vertex: CU,
        dithering_fragment: EU,
        dithering_pars_fragment: bU,
        roughnessmap_fragment: TU,
        roughnessmap_pars_fragment: BU,
        shadowmap_pars_fragment: PU,
        shadowmap_pars_vertex: RU,
        shadowmap_vertex: IU,
        shadowmask_pars_fragment: LU,
        skinbase_vertex: DU,
        skinning_pars_vertex: FU,
        skinning_vertex: kU,
        skinnormal_vertex: NU,
        specularmap_fragment: OU,
        specularmap_pars_fragment: UU,
        tonemapping_fragment: zU,
        tonemapping_pars_fragment: GU,
        transmission_fragment: HU,
        transmission_pars_fragment: VU,
        uv_pars_fragment: WU,
        uv_pars_vertex: jU,
        uv_vertex: JU,
        uv2_pars_fragment: XU,
        uv2_pars_vertex: QU,
        uv2_vertex: KU,
        worldpos_vertex: YU,
        background_vert: ZU,
        background_frag: qU,
        backgroundCube_vert: $U,
        backgroundCube_frag: ez,
        cube_vert: tz,
        cube_frag: nz,
        depth_vert: iz,
        depth_frag: rz,
        distanceRGBA_vert: sz,
        distanceRGBA_frag: oz,
        equirect_vert: az,
        equirect_frag: lz,
        linedashed_vert: uz,
        linedashed_frag: cz,
        meshbasic_vert: fz,
        meshbasic_frag: dz,
        meshlambert_vert: hz,
        meshlambert_frag: pz,
        meshmatcap_vert: mz,
        meshmatcap_frag: gz,
        meshnormal_vert: yz,
        meshnormal_frag: vz,
        meshphong_vert: Az,
        meshphong_frag: xz,
        meshphysical_vert: _z,
        meshphysical_frag: wz,
        meshtoon_vert: Sz,
        meshtoon_frag: Mz,
        points_vert: Cz,
        points_frag: Ez,
        shadow_vert: bz,
        shadow_frag: Tz,
        sprite_vert: Bz,
        sprite_frag: Pz
    },
    Re = {
        common: {
            diffuse: {
                value: new Ie(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new li
            },
            uv2Transform: {
                value: new li
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new me(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Ie(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Ie(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new li
            }
        },
        sprite: {
            diffuse: {
                value: new Ie(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new me(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new li
            }
        }
    },
    Pr = {
        basic: {
            uniforms: si([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]),
            vertexShader: pt.meshbasic_vert,
            fragmentShader: pt.meshbasic_frag
        },
        lambert: {
            uniforms: si([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
                emissive: {
                    value: new Ie(0)
                }
            }]),
            vertexShader: pt.meshlambert_vert,
            fragmentShader: pt.meshlambert_frag
        },
        phong: {
            uniforms: si([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, {
                emissive: {
                    value: new Ie(0)
                },
                specular: {
                    value: new Ie(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: pt.meshphong_vert,
            fragmentShader: pt.meshphong_frag
        },
        standard: {
            uniforms: si([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, {
                emissive: {
                    value: new Ie(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: pt.meshphysical_vert,
            fragmentShader: pt.meshphysical_frag
        },
        toon: {
            uniforms: si([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, {
                emissive: {
                    value: new Ie(0)
                }
            }]),
            vertexShader: pt.meshtoon_vert,
            fragmentShader: pt.meshtoon_frag
        },
        matcap: {
            uniforms: si([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: pt.meshmatcap_vert,
            fragmentShader: pt.meshmatcap_frag
        },
        points: {
            uniforms: si([Re.points, Re.fog]),
            vertexShader: pt.points_vert,
            fragmentShader: pt.points_frag
        },
        dashed: {
            uniforms: si([Re.common, Re.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: pt.linedashed_vert,
            fragmentShader: pt.linedashed_frag
        },
        depth: {
            uniforms: si([Re.common, Re.displacementmap]),
            vertexShader: pt.depth_vert,
            fragmentShader: pt.depth_frag
        },
        normal: {
            uniforms: si([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: pt.meshnormal_vert,
            fragmentShader: pt.meshnormal_frag
        },
        sprite: {
            uniforms: si([Re.sprite, Re.fog]),
            vertexShader: pt.sprite_vert,
            fragmentShader: pt.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new li
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: pt.background_vert,
            fragmentShader: pt.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: pt.backgroundCube_vert,
            fragmentShader: pt.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: pt.cube_vert,
            fragmentShader: pt.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: pt.equirect_vert,
            fragmentShader: pt.equirect_frag
        },
        distanceRGBA: {
            uniforms: si([Re.common, Re.displacementmap, {
                referencePosition: {
                    value: new D
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: pt.distanceRGBA_vert,
            fragmentShader: pt.distanceRGBA_frag
        },
        shadow: {
            uniforms: si([Re.lights, Re.fog, {
                color: {
                    value: new Ie(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: pt.shadow_vert,
            fragmentShader: pt.shadow_frag
        }
    };
Pr.physical = {
    uniforms: si([Pr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new me(1, 1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ie(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new me
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ie(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new Ie(1, 1, 1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: pt.meshphysical_vert,
    fragmentShader: pt.meshphysical_frag
};
const mp = {
    r: 0,
    b: 0,
    g: 0
};

function Rz(n, e, t, i, r, s, o) {
    const a = new Ie(0);
    let l = s === !0 ? 0 : 1,
        c, d, h = null,
        p = 0,
        m = null;

    function v(A, x) {
        let _ = !1,
            S = x.isScene === !0 ? x.background : null;
        S && S.isTexture && (S = (x.backgroundBlurriness > 0 ? t : e).get(S));
        const M = n.xr,
            b = M.getSession && M.getSession();
        b && b.environmentBlendMode === "additive" && (S = null), S === null ? y(a, l) : S && S.isColor && (y(S, 1), _ = !0), (n.autoClear || _) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), S && (S.isCubeTexture || S.mapping === Ju) ? (d === void 0 && (d = new bn(new qo(1, 1, 1), new os({
            name: "BackgroundCubeMaterial",
            uniforms: Fu(Pr.backgroundCube.uniforms),
            vertexShader: Pr.backgroundCube.vertexShader,
            fragmentShader: Pr.backgroundCube.fragmentShader,
            side: Ci,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(B, R, E) {
            this.matrixWorld.copyPosition(E.matrixWorld)
        }, Object.defineProperty(d.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }), r.update(d)), d.material.uniforms.envMap.value = S, d.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, d.material.toneMapped = S.encoding !== Ct, (h !== S || p !== S.version || m !== n.toneMapping) && (d.material.needsUpdate = !0, h = S, p = S.version, m = n.toneMapping), d.layers.enableAll(), A.unshift(d, d.geometry, d.material, 0, 0, null)) : S && S.isTexture && (c === void 0 && (c = new bn(new Xu(2, 2), new os({
            name: "BackgroundMaterial",
            uniforms: Fu(Pr.background.uniforms),
            vertexShader: Pr.background.vertexShader,
            fragmentShader: Pr.background.fragmentShader,
            side: rs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }), r.update(c)), c.material.uniforms.t2D.value = S, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = S.encoding !== Ct, S.matrixAutoUpdate === !0 && S.updateMatrix(), c.material.uniforms.uvTransform.value.copy(S.matrix), (h !== S || p !== S.version || m !== n.toneMapping) && (c.material.needsUpdate = !0, h = S, p = S.version, m = n.toneMapping), c.layers.enableAll(), A.unshift(c, c.geometry, c.material, 0, 0, null))
    }

    function y(A, x) {
        A.getRGB(mp, OP(n)), i.buffers.color.setClear(mp.r, mp.g, mp.b, x, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(A, x = 1) {
            a.set(A), l = x, y(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(A) {
            l = A, y(a, l)
        },
        render: v
    }
}

function Iz(n, e, t, i) {
    const r = n.getParameter(34921),
        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = i.isWebGL2 || s !== null,
        a = {},
        l = A(null);
    let c = l,
        d = !1;

    function h(G, K, te, se, k) {
        let V = !1;
        if (o) {
            const J = y(se, te, K);
            c !== J && (c = J, m(c.object)), V = x(G, se, te, k), V && _(G, se, te, k)
        } else {
            const J = K.wireframe === !0;
            (c.geometry !== se.id || c.program !== te.id || c.wireframe !== J) && (c.geometry = se.id, c.program = te.id, c.wireframe = J, V = !0)
        }
        k !== null && t.update(k, 34963), (V || d) && (d = !1, E(G, K, te, se), k !== null && n.bindBuffer(34963, t.get(k).buffer))
    }

    function p() {
        return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
    }

    function m(G) {
        return i.isWebGL2 ? n.bindVertexArray(G) : s.bindVertexArrayOES(G)
    }

    function v(G) {
        return i.isWebGL2 ? n.deleteVertexArray(G) : s.deleteVertexArrayOES(G)
    }

    function y(G, K, te) {
        const se = te.wireframe === !0;
        let k = a[G.id];
        k === void 0 && (k = {}, a[G.id] = k);
        let V = k[K.id];
        V === void 0 && (V = {}, k[K.id] = V);
        let J = V[se];
        return J === void 0 && (J = A(p()), V[se] = J), J
    }

    function A(G) {
        const K = [],
            te = [],
            se = [];
        for (let k = 0; k < r; k++) K[k] = 0, te[k] = 0, se[k] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: K,
            enabledAttributes: te,
            attributeDivisors: se,
            object: G,
            attributes: {},
            index: null
        }
    }

    function x(G, K, te, se) {
        const k = c.attributes,
            V = K.attributes;
        let J = 0;
        const ie = te.getAttributes();
        for (const j in ie)
            if (ie[j].location >= 0) {
                const ve = k[j];
                let xe = V[j];
                if (xe === void 0 && (j === "instanceMatrix" && G.instanceMatrix && (xe = G.instanceMatrix), j === "instanceColor" && G.instanceColor && (xe = G.instanceColor)), ve === void 0 || ve.attribute !== xe || xe && ve.data !== xe.data) return !0;
                J++
            } return c.attributesNum !== J || c.index !== se
    }

    function _(G, K, te, se) {
        const k = {},
            V = K.attributes;
        let J = 0;
        const ie = te.getAttributes();
        for (const j in ie)
            if (ie[j].location >= 0) {
                let ve = V[j];
                ve === void 0 && (j === "instanceMatrix" && G.instanceMatrix && (ve = G.instanceMatrix), j === "instanceColor" && G.instanceColor && (ve = G.instanceColor));
                const xe = {};
                xe.attribute = ve, ve && ve.data && (xe.data = ve.data), k[j] = xe, J++
            } c.attributes = k, c.attributesNum = J, c.index = se
    }

    function S() {
        const G = c.newAttributes;
        for (let K = 0, te = G.length; K < te; K++) G[K] = 0
    }

    function M(G) {
        b(G, 0)
    }

    function b(G, K) {
        const te = c.newAttributes,
            se = c.enabledAttributes,
            k = c.attributeDivisors;
        te[G] = 1, se[G] === 0 && (n.enableVertexAttribArray(G), se[G] = 1), k[G] !== K && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](G, K), k[G] = K)
    }

    function B() {
        const G = c.newAttributes,
            K = c.enabledAttributes;
        for (let te = 0, se = K.length; te < se; te++) K[te] !== G[te] && (n.disableVertexAttribArray(te), K[te] = 0)
    }

    function R(G, K, te, se, k, V) {
        i.isWebGL2 === !0 && (te === 5124 || te === 5125) ? n.vertexAttribIPointer(G, K, te, k, V) : n.vertexAttribPointer(G, K, te, se, k, V)
    }

    function E(G, K, te, se) {
        if (i.isWebGL2 === !1 && (G.isInstancedMesh || se.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
        S();
        const k = se.attributes,
            V = te.getAttributes(),
            J = K.defaultAttributeValues;
        for (const ie in V) {
            const j = V[ie];
            if (j.location >= 0) {
                let re = k[ie];
                if (re === void 0 && (ie === "instanceMatrix" && G.instanceMatrix && (re = G.instanceMatrix), ie === "instanceColor" && G.instanceColor && (re = G.instanceColor)), re !== void 0) {
                    const ve = re.normalized,
                        xe = re.itemSize,
                        q = t.get(re);
                    if (q === void 0) continue;
                    const Ne = q.buffer,
                        Oe = q.type,
                        He = q.bytesPerElement;
                    if (re.isInterleavedBufferAttribute) {
                        const we = re.data,
                            Le = we.stride,
                            he = re.offset;
                        if (we.isInstancedInterleavedBuffer) {
                            for (let ae = 0; ae < j.locationSize; ae++) b(j.location + ae, we.meshPerAttribute);
                            G.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = we.meshPerAttribute * we.count)
                        } else
                            for (let ae = 0; ae < j.locationSize; ae++) M(j.location + ae);
                        n.bindBuffer(34962, Ne);
                        for (let ae = 0; ae < j.locationSize; ae++) R(j.location + ae, xe / j.locationSize, Oe, ve, Le * He, (he + xe / j.locationSize * ae) * He)
                    } else {
                        if (re.isInstancedBufferAttribute) {
                            for (let we = 0; we < j.locationSize; we++) b(j.location + we, re.meshPerAttribute);
                            G.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = re.meshPerAttribute * re.count)
                        } else
                            for (let we = 0; we < j.locationSize; we++) M(j.location + we);
                        n.bindBuffer(34962, Ne);
                        for (let we = 0; we < j.locationSize; we++) R(j.location + we, xe / j.locationSize, Oe, ve, xe * He, xe / j.locationSize * we * He)
                    }
                } else if (J !== void 0) {
                    const ve = J[ie];
                    if (ve !== void 0) switch (ve.length) {
                        case 2:
                            n.vertexAttrib2fv(j.location, ve);
                            break;
                        case 3:
                            n.vertexAttrib3fv(j.location, ve);
                            break;
                        case 4:
                            n.vertexAttrib4fv(j.location, ve);
                            break;
                        default:
                            n.vertexAttrib1fv(j.location, ve)
                    }
                }
            }
        }
        B()
    }

    function P() {
        Z();
        for (const G in a) {
            const K = a[G];
            for (const te in K) {
                const se = K[te];
                for (const k in se) v(se[k].object), delete se[k];
                delete K[te]
            }
            delete a[G]
        }
    }

    function I(G) {
        if (a[G.id] === void 0) return;
        const K = a[G.id];
        for (const te in K) {
            const se = K[te];
            for (const k in se) v(se[k].object), delete se[k];
            delete K[te]
        }
        delete a[G.id]
    }

    function z(G) {
        for (const K in a) {
            const te = a[K];
            if (te[G.id] === void 0) continue;
            const se = te[G.id];
            for (const k in se) v(se[k].object), delete se[k];
            delete te[G.id]
        }
    }

    function Z() {
        W(), d = !0, c !== l && (c = l, m(c.object))
    }

    function W() {
        l.geometry = null, l.program = null, l.wireframe = !1
    }
    return {
        setup: h,
        reset: Z,
        resetDefaultState: W,
        dispose: P,
        releaseStatesOfGeometry: I,
        releaseStatesOfProgram: z,
        initAttributes: S,
        enableAttribute: M,
        disableUnusedAttributes: B
    }
}

function Lz(n, e, t, i) {
    const r = i.isWebGL2;
    let s;

    function o(c) {
        s = c
    }

    function a(c, d) {
        n.drawArrays(s, c, d), t.update(d, s, 1)
    }

    function l(c, d, h) {
        if (h === 0) return;
        let p, m;
        if (r) p = n, m = "drawArraysInstanced";
        else if (p = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", p === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        p[m](s, c, d, h), t.update(d, s, h)
    }
    this.setMode = o, this.render = a, this.renderInstances = l
}

function Dz(n, e, t) {
    let i;

    function r() {
        if (i !== void 0) return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else i = 0;
        return i
    }

    function s(R) {
        if (R === "highp") {
            if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            R = "mediump"
        }
        return R === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext;
    let a = t.precision !== void 0 ? t.precision : "highp";
    const l = s(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
    const c = o || e.has("WEBGL_draw_buffers"),
        d = t.logarithmicDepthBuffer === !0,
        h = n.getParameter(34930),
        p = n.getParameter(35660),
        m = n.getParameter(3379),
        v = n.getParameter(34076),
        y = n.getParameter(34921),
        A = n.getParameter(36347),
        x = n.getParameter(36348),
        _ = n.getParameter(36349),
        S = p > 0,
        M = o || e.has("OES_texture_float"),
        b = S && M,
        B = o ? n.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: r,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: d,
        maxTextures: h,
        maxVertexTextures: p,
        maxTextureSize: m,
        maxCubemapSize: v,
        maxAttributes: y,
        maxVertexUniforms: A,
        maxVaryings: x,
        maxFragmentUniforms: _,
        vertexTextures: S,
        floatFragmentTextures: M,
        floatVertexTextures: b,
        maxSamples: B
    }
}

function Fz(n) {
    const e = this;
    let t = null,
        i = 0,
        r = !1,
        s = !1;
    const o = new vo,
        a = new li,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, p) {
        const m = h.length !== 0 || p || i !== 0 || r;
        return r = p, i = h.length, m
    }, this.beginShadows = function() {
        s = !0, d(null)
    }, this.endShadows = function() {
        s = !1
    }, this.setGlobalState = function(h, p) {
        t = d(h, p, 0)
    }, this.setState = function(h, p, m) {
        const v = h.clippingPlanes,
            y = h.clipIntersection,
            A = h.clipShadows,
            x = n.get(h);
        if (!r || v === null || v.length === 0 || s && !A) s ? d(null) : c();
        else {
            const _ = s ? 0 : i,
                S = _ * 4;
            let M = x.clippingState || null;
            l.value = M, M = d(v, p, S, m);
            for (let b = 0; b !== S; ++b) M[b] = t[b];
            x.clippingState = M, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _
        }
    };

    function c() {
        l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
    }

    function d(h, p, m, v) {
        const y = h !== null ? h.length : 0;
        let A = null;
        if (y !== 0) {
            if (A = l.value, v !== !0 || A === null) {
                const x = m + y * 4,
                    _ = p.matrixWorldInverse;
                a.getNormalMatrix(_), (A === null || A.length < x) && (A = new Float32Array(x));
                for (let S = 0, M = m; S !== y; ++S, M += 4) o.copy(h[S]).applyMatrix4(_, a), o.normal.toArray(A, M), A[M + 3] = o.constant
            }
            l.value = A, l.needsUpdate = !0
        }
        return e.numPlanes = y, e.numIntersection = 0, A
    }
}

function kz(n) {
    let e = new WeakMap;

    function t(o, a) {
        return a === Vf ? o.mapping = zo : a === Wf && (o.mapping = Go), o
    }

    function i(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            const a = o.mapping;
            if (a === Vf || a === Wf)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new o_(l.height / 2);
                        return c.fromEquirectangularTexture(n, o), e.set(o, c), o.addEventListener("dispose", r), t(c.texture, o.mapping)
                    } else return null
                }
        }
        return o
    }

    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose())
    }

    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class Fr extends yd {
    constructor(e = -1, t = 1, i = 1, r = -1, s = .1, o = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
        let s = i - e,
            o = i + e,
            a = r + t,
            l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX, o = s + c * this.view.width, a -= d * this.view.offsetY, l = a - d * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
    }
}
const uu = 4,
    TC = [.125, .215, .35, .446, .526, .582],
    Ra = 20,
    Yy = new Fr,
    BC = new Ie;
let Zy = null;
const Ea = (1 + Math.sqrt(5)) / 2,
    Hl = 1 / Ea,
    PC = [new D(1, 1, 1), new D(-1, 1, 1), new D(1, 1, -1), new D(-1, 1, -1), new D(0, Ea, Hl), new D(0, Ea, -Hl), new D(Hl, 0, Ea), new D(-Hl, 0, Ea), new D(Ea, Hl, 0), new D(-Ea, Hl, 0)];
class fx {
    constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t = 0, i = .1, r = 100) {
        Zy = this._renderer.getRenderTarget(), this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = LC(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = IC(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Zy), e.scissorTest = !1, gp(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === zo || e.mapping === Go ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Zy = this._renderer.getRenderTarget();
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = {
                magFilter: en,
                minFilter: en,
                generateMipmaps: !1,
                type: Iu,
                format: xi,
                encoding: Ws,
                depthBuffer: !1
            },
            r = RC(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = RC(e, t, i);
            const {
                _lodMax: s
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = Nz(s)), this._blurMaterial = Oz(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new bn(this._lodPlanes[0], e);
        this._renderer.compile(t, Yy)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Gt(90, 1, t, i),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            d = this._renderer,
            h = d.autoClear,
            p = d.toneMapping;
        d.getClearColor(BC), d.toneMapping = Dr, d.autoClear = !1;
        const m = new Ni({
                name: "PMREM.Background",
                side: Ci,
                depthWrite: !1,
                depthTest: !1
            }),
            v = new bn(new qo, m);
        let y = !1;
        const A = e.background;
        A ? A.isColor && (m.color.copy(A), e.background = null, y = !0) : (m.color.copy(BC), y = !0);
        for (let x = 0; x < 6; x++) {
            const _ = x % 3;
            _ === 0 ? (a.up.set(0, l[x], 0), a.lookAt(c[x], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[x]), a.lookAt(0, c[x], 0)) : (a.up.set(0, l[x], 0), a.lookAt(0, 0, c[x]));
            const S = this._cubeSize;
            gp(r, _ * S, x > 2 ? S : 0, S, S), d.setRenderTarget(r), y && d.render(v, a), d.render(e, a)
        }
        v.geometry.dispose(), v.material.dispose(), d.toneMapping = p, d.autoClear = h, e.background = A
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer,
            r = e.mapping === zo || e.mapping === Go;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = LC()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = IC());
        const s = r ? this._cubemapMaterial : this._equirectMaterial,
            o = new bn(this._lodPlanes[0], s),
            a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        gp(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, Yy)
    }
    _applyPMREM(e) {
        const t = this._renderer,
            i = t.autoClear;
        t.autoClear = !1;
        for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
                o = PC[(r - 1) % PC.length];
            this._blur(e, r - 1, r, s, o)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer,
            c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const d = 3,
            h = new bn(this._lodPlanes[r], c),
            p = c.uniforms,
            m = this._sizeLods[i] - 1,
            v = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Ra - 1),
            y = s / v,
            A = isFinite(s) ? 1 + Math.floor(d * y) : Ra;
        A > Ra && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${A} samples when the maximum is set to ${Ra}`);
        const x = [];
        let _ = 0;
        for (let R = 0; R < Ra; ++R) {
            const E = R / y,
                P = Math.exp(-E * E / 2);
            x.push(P), R === 0 ? _ += P : R < A && (_ += 2 * P)
        }
        for (let R = 0; R < x.length; R++) x[R] = x[R] / _;
        p.envMap.value = e.texture, p.samples.value = A, p.weights.value = x, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a);
        const {
            _lodMax: S
        } = this;
        p.dTheta.value = v, p.mipInt.value = S - i;
        const M = this._sizeLods[r],
            b = 3 * M * (r > S - uu ? r - S + uu : 0),
            B = 4 * (this._cubeSize - M);
        gp(t, b, B, 3 * M, 2 * M), l.setRenderTarget(t), l.render(h, Yy)
    }
}

function Nz(n) {
    const e = [],
        t = [],
        i = [];
    let r = n;
    const s = n - uu + 1 + TC.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - uu ? l = TC[o - n + uu - 1] : o === 0 && (l = 0), i.push(l);
        const c = 1 / (a - 2),
            d = -c,
            h = 1 + c,
            p = [d, d, h, d, h, h, d, d, h, h, d, h],
            m = 6,
            v = 6,
            y = 3,
            A = 2,
            x = 1,
            _ = new Float32Array(y * v * m),
            S = new Float32Array(A * v * m),
            M = new Float32Array(x * v * m);
        for (let B = 0; B < m; B++) {
            const R = B % 3 * 2 / 3 - 1,
                E = B > 2 ? 0 : -1,
                P = [R, E, 0, R + 2 / 3, E, 0, R + 2 / 3, E + 1, 0, R, E, 0, R + 2 / 3, E + 1, 0, R, E + 1, 0];
            _.set(P, y * v * B), S.set(p, A * v * B);
            const I = [B, B, B, B, B, B];
            M.set(I, x * v * B)
        }
        const b = new ut;
        b.setAttribute("position", new Dt(_, y)), b.setAttribute("uv", new Dt(S, A)), b.setAttribute("faceIndex", new Dt(M, x)), e.push(b), r > uu && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}

function RC(n, e, t) {
    const i = new Nr(n, e, t);
    return i.texture.mapping = Ju, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
}

function gp(n, e, t, i, r) {
    n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r)
}

function Oz(n, e, t) {
    const i = new Float32Array(Ra),
        r = new D(0, 1, 0);
    return new os({
        name: "SphericalGaussianBlur",
        defines: {
            n: Ra,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: a_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: ks,
        depthTest: !1,
        depthWrite: !1
    })
}

function IC() {
    return new os({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: a_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: ks,
        depthTest: !1,
        depthWrite: !1
    })
}

function LC() {
    return new os({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: a_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: ks,
        depthTest: !1,
        depthWrite: !1
    })
}

function a_() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function Uz(n) {
    let e = new WeakMap,
        t = null;

    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping,
                c = l === Vf || l === Wf,
                d = l === zo || l === Go;
            if (c || d)
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
                    a.needsPMREMUpdate = !1;
                    let h = e.get(a);
                    return t === null && (t = new fx(n)), h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), e.set(a, h), h.texture
                } else {
                    if (e.has(a)) return e.get(a).texture; {
                        const h = a.image;
                        if (c && h && h.height > 0 || d && h && r(h)) {
                            t === null && (t = new fx(n));
                            const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                            return e.set(a, p), a.addEventListener("dispose", s), p.texture
                        } else return null
                    }
                }
        }
        return a
    }

    function r(a) {
        let l = 0;
        const c = 6;
        for (let d = 0; d < c; d++) a[d] !== void 0 && l++;
        return l === c
    }

    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose())
    }

    function o() {
        e = new WeakMap, t !== null && (t.dispose(), t = null)
    }
    return {
        get: i,
        dispose: o
    }
}

function zz(n) {
    const e = {};

    function t(i) {
        if (e[i] !== void 0) return e[i];
        let r;
        switch (i) {
            case "WEBGL_depth_texture":
                r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                r = n.getExtension(i)
        }
        return e[i] = r, r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function(i) {
            i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture")
        },
        get: function(i) {
            const r = t(i);
            return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r
        }
    }
}

function Gz(n, e, t, i) {
    const r = {},
        s = new WeakMap;

    function o(h) {
        const p = h.target;
        p.index !== null && e.remove(p.index);
        for (const v in p.attributes) e.remove(p.attributes[v]);
        p.removeEventListener("dispose", o), delete r[p.id];
        const m = s.get(p);
        m && (e.remove(m), s.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries--
    }

    function a(h, p) {
        return r[p.id] === !0 || (p.addEventListener("dispose", o), r[p.id] = !0, t.memory.geometries++), p
    }

    function l(h) {
        const p = h.attributes;
        for (const v in p) e.update(p[v], 34962);
        const m = h.morphAttributes;
        for (const v in m) {
            const y = m[v];
            for (let A = 0, x = y.length; A < x; A++) e.update(y[A], 34962)
        }
    }

    function c(h) {
        const p = [],
            m = h.index,
            v = h.attributes.position;
        let y = 0;
        if (m !== null) {
            const _ = m.array;
            y = m.version;
            for (let S = 0, M = _.length; S < M; S += 3) {
                const b = _[S + 0],
                    B = _[S + 1],
                    R = _[S + 2];
                p.push(b, B, B, R, R, b)
            }
        } else {
            const _ = v.array;
            y = v.version;
            for (let S = 0, M = _.length / 3 - 1; S < M; S += 3) {
                const b = S + 0,
                    B = S + 1,
                    R = S + 2;
                p.push(b, B, B, R, R, b)
            }
        }
        const A = new(kP(p) ? r_ : i_)(p, 1);
        A.version = y;
        const x = s.get(h);
        x && e.remove(x), s.set(h, A)
    }

    function d(h) {
        const p = s.get(h);
        if (p) {
            const m = h.index;
            m !== null && p.version < m.version && c(h)
        } else c(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: d
    }
}

function Hz(n, e, t, i) {
    const r = i.isWebGL2;
    let s;

    function o(p) {
        s = p
    }
    let a, l;

    function c(p) {
        a = p.type, l = p.bytesPerElement
    }

    function d(p, m) {
        n.drawElements(s, m, a, p * l), t.update(m, s, 1)
    }

    function h(p, m, v) {
        if (v === 0) return;
        let y, A;
        if (r) y = n, A = "drawElementsInstanced";
        else if (y = e.get("ANGLE_instanced_arrays"), A = "drawElementsInstancedANGLE", y === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        y[A](s, m, a, p * l, v), t.update(m, s, v)
    }
    this.setMode = o, this.setIndex = c, this.render = d, this.renderInstances = h
}

function Vz(n) {
    const e = {
            geometries: 0,
            textures: 0
        },
        t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

    function i(s, o, a) {
        switch (t.calls++, o) {
            case 4:
                t.triangles += a * (s / 3);
                break;
            case 1:
                t.lines += a * (s / 2);
                break;
            case 3:
                t.lines += a * (s - 1);
                break;
            case 2:
                t.lines += a * s;
                break;
            case 0:
                t.points += a * s;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break
        }
    }

    function r() {
        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}

function Wz(n, e) {
    return n[0] - e[0]
}

function jz(n, e) {
    return Math.abs(e[1]) - Math.abs(n[1])
}

function Jz(n, e, t) {
    const i = {},
        r = new Float32Array(8),
        s = new WeakMap,
        o = new kt,
        a = [];
    for (let c = 0; c < 8; c++) a[c] = [c, 0];

    function l(c, d, h, p) {
        const m = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            const y = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color,
                A = y !== void 0 ? y.length : 0;
            let x = s.get(d);
            if (x === void 0 || x.count !== A) {
                let te = function() {
                    G.dispose(), s.delete(d), d.removeEventListener("dispose", te)
                };
                var v = te;
                x !== void 0 && x.texture.dispose();
                const M = d.morphAttributes.position !== void 0,
                    b = d.morphAttributes.normal !== void 0,
                    B = d.morphAttributes.color !== void 0,
                    R = d.morphAttributes.position || [],
                    E = d.morphAttributes.normal || [],
                    P = d.morphAttributes.color || [];
                let I = 0;
                M === !0 && (I = 1), b === !0 && (I = 2), B === !0 && (I = 3);
                let z = d.attributes.position.count * I,
                    Z = 1;
                z > e.maxTextureSize && (Z = Math.ceil(z / e.maxTextureSize), z = e.maxTextureSize);
                const W = new Float32Array(z * Z * 4 * A),
                    G = new Bg(W, z, Z, A);
                G.type = Rs, G.needsUpdate = !0;
                const K = I * 4;
                for (let se = 0; se < A; se++) {
                    const k = R[se],
                        V = E[se],
                        J = P[se],
                        ie = z * Z * 4 * se;
                    for (let j = 0; j < k.count; j++) {
                        const re = j * K;
                        M === !0 && (o.fromBufferAttribute(k, j), W[ie + re + 0] = o.x, W[ie + re + 1] = o.y, W[ie + re + 2] = o.z, W[ie + re + 3] = 0), b === !0 && (o.fromBufferAttribute(V, j), W[ie + re + 4] = o.x, W[ie + re + 5] = o.y, W[ie + re + 6] = o.z, W[ie + re + 7] = 0), B === !0 && (o.fromBufferAttribute(J, j), W[ie + re + 8] = o.x, W[ie + re + 9] = o.y, W[ie + re + 10] = o.z, W[ie + re + 11] = J.itemSize === 4 ? o.w : 1)
                    }
                }
                x = {
                    count: A,
                    texture: G,
                    size: new me(z, Z)
                }, s.set(d, x), d.addEventListener("dispose", te)
            }
            let _ = 0;
            for (let M = 0; M < m.length; M++) _ += m[M];
            const S = d.morphTargetsRelative ? 1 : 1 - _;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", S), p.getUniforms().setValue(n, "morphTargetInfluences", m), p.getUniforms().setValue(n, "morphTargetsTexture", x.texture, t), p.getUniforms().setValue(n, "morphTargetsTextureSize", x.size)
        } else {
            const y = m === void 0 ? 0 : m.length;
            let A = i[d.id];
            if (A === void 0 || A.length !== y) {
                A = [];
                for (let b = 0; b < y; b++) A[b] = [b, 0];
                i[d.id] = A
            }
            for (let b = 0; b < y; b++) {
                const B = A[b];
                B[0] = b, B[1] = m[b]
            }
            A.sort(jz);
            for (let b = 0; b < 8; b++) b < y && A[b][1] ? (a[b][0] = A[b][0], a[b][1] = A[b][1]) : (a[b][0] = Number.MAX_SAFE_INTEGER, a[b][1] = 0);
            a.sort(Wz);
            const x = d.morphAttributes.position,
                _ = d.morphAttributes.normal;
            let S = 0;
            for (let b = 0; b < 8; b++) {
                const B = a[b],
                    R = B[0],
                    E = B[1];
                R !== Number.MAX_SAFE_INTEGER && E ? (x && d.getAttribute("morphTarget" + b) !== x[R] && d.setAttribute("morphTarget" + b, x[R]), _ && d.getAttribute("morphNormal" + b) !== _[R] && d.setAttribute("morphNormal" + b, _[R]), r[b] = E, S += E) : (x && d.hasAttribute("morphTarget" + b) === !0 && d.deleteAttribute("morphTarget" + b), _ && d.hasAttribute("morphNormal" + b) === !0 && d.deleteAttribute("morphNormal" + b), r[b] = 0)
            }
            const M = d.morphTargetsRelative ? 1 : 1 - S;
            p.getUniforms().setValue(n, "morphTargetBaseInfluence", M), p.getUniforms().setValue(n, "morphTargetInfluences", r)
        }
    }
    return {
        update: l
    }
}

function Xz(n, e, t, i) {
    let r = new WeakMap;

    function s(l) {
        const c = i.render.frame,
            d = l.geometry,
            h = e.get(l, d);
        return r.get(h) !== c && (e.update(h), r.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), h
    }

    function o() {
        r = new WeakMap
    }

    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
const GP = new Yt,
    HP = new Bg,
    VP = new n_,
    WP = new vd,
    DC = [],
    FC = [],
    kC = new Float32Array(16),
    NC = new Float32Array(9),
    OC = new Float32Array(4);

function Qu(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0) return n;
    const r = e * t;
    let s = DC[r];
    if (s === void 0 && (s = new Float32Array(r), DC[r] = s), e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o) a += t, n[o].toArray(s, a)
    }
    return s
}

function Tn(n, e) {
    if (n.length !== e.length) return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t]) return !1;
    return !0
}

function Bn(n, e) {
    for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}

function Rg(n, e) {
    let t = FC[e];
    t === void 0 && (t = new Int32Array(e), FC[e] = t);
    for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
    return t
}

function Qz(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e)
}

function Kz(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Tn(t, e)) return;
        n.uniform2fv(this.addr, e), Bn(t, e)
    }
}

function Yz(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
        if (Tn(t, e)) return;
        n.uniform3fv(this.addr, e), Bn(t, e)
    }
}

function Zz(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Tn(t, e)) return;
        n.uniform4fv(this.addr, e), Bn(t, e)
    }
}

function qz(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Tn(t, e)) return;
        n.uniformMatrix2fv(this.addr, !1, e), Bn(t, e)
    } else {
        if (Tn(t, i)) return;
        OC.set(i), n.uniformMatrix2fv(this.addr, !1, OC), Bn(t, i)
    }
}

function $z(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Tn(t, e)) return;
        n.uniformMatrix3fv(this.addr, !1, e), Bn(t, e)
    } else {
        if (Tn(t, i)) return;
        NC.set(i), n.uniformMatrix3fv(this.addr, !1, NC), Bn(t, i)
    }
}

function e4(n, e) {
    const t = this.cache,
        i = e.elements;
    if (i === void 0) {
        if (Tn(t, e)) return;
        n.uniformMatrix4fv(this.addr, !1, e), Bn(t, e)
    } else {
        if (Tn(t, i)) return;
        kC.set(i), n.uniformMatrix4fv(this.addr, !1, kC), Bn(t, i)
    }
}

function t4(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e)
}

function n4(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Tn(t, e)) return;
        n.uniform2iv(this.addr, e), Bn(t, e)
    }
}

function i4(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (Tn(t, e)) return;
        n.uniform3iv(this.addr, e), Bn(t, e)
    }
}

function r4(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Tn(t, e)) return;
        n.uniform4iv(this.addr, e), Bn(t, e)
    }
}

function s4(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e)
}

function o4(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Tn(t, e)) return;
        n.uniform2uiv(this.addr, e), Bn(t, e)
    }
}

function a4(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (Tn(t, e)) return;
        n.uniform3uiv(this.addr, e), Bn(t, e)
    }
}

function l4(n, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Tn(t, e)) return;
        n.uniform4uiv(this.addr, e), Bn(t, e)
    }
}

function u4(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2D(e || GP, r)
}

function c4(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || VP, r)
}

function f4(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || WP, r)
}

function d4(n, e, t) {
    const i = this.cache,
        r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || HP, r)
}

function h4(n) {
    switch (n) {
        case 5126:
            return Qz;
        case 35664:
            return Kz;
        case 35665:
            return Yz;
        case 35666:
            return Zz;
        case 35674:
            return qz;
        case 35675:
            return $z;
        case 35676:
            return e4;
        case 5124:
        case 35670:
            return t4;
        case 35667:
        case 35671:
            return n4;
        case 35668:
        case 35672:
            return i4;
        case 35669:
        case 35673:
            return r4;
        case 5125:
            return s4;
        case 36294:
            return o4;
        case 36295:
            return a4;
        case 36296:
            return l4;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return u4;
        case 35679:
        case 36299:
        case 36307:
            return c4;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return f4;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return d4
    }
}

function p4(n, e) {
    n.uniform1fv(this.addr, e)
}

function m4(n, e) {
    const t = Qu(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}

function g4(n, e) {
    const t = Qu(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}

function y4(n, e) {
    const t = Qu(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}

function v4(n, e) {
    const t = Qu(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}

function A4(n, e) {
    const t = Qu(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}

function x4(n, e) {
    const t = Qu(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}

function _4(n, e) {
    n.uniform1iv(this.addr, e)
}

function w4(n, e) {
    n.uniform2iv(this.addr, e)
}

function S4(n, e) {
    n.uniform3iv(this.addr, e)
}

function M4(n, e) {
    n.uniform4iv(this.addr, e)
}

function C4(n, e) {
    n.uniform1uiv(this.addr, e)
}

function E4(n, e) {
    n.uniform2uiv(this.addr, e)
}

function b4(n, e) {
    n.uniform3uiv(this.addr, e)
}

function T4(n, e) {
    n.uniform4uiv(this.addr, e)
}

function B4(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Rg(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || GP, s[o])
}

function P4(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Rg(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || VP, s[o])
}

function R4(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Rg(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
    for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || WP, s[o])
}

function I4(n, e, t) {
    const i = this.cache,
        r = e.length,
        s = Rg(t, r);
    Tn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
    for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || HP, s[o])
}

function L4(n) {
    switch (n) {
        case 5126:
            return p4;
        case 35664:
            return m4;
        case 35665:
            return g4;
        case 35666:
            return y4;
        case 35674:
            return v4;
        case 35675:
            return A4;
        case 35676:
            return x4;
        case 5124:
        case 35670:
            return _4;
        case 35667:
        case 35671:
            return w4;
        case 35668:
        case 35672:
            return S4;
        case 35669:
        case 35673:
            return M4;
        case 5125:
            return C4;
        case 36294:
            return E4;
        case 36295:
            return b4;
        case 36296:
            return T4;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return B4;
        case 35679:
        case 36299:
        case 36307:
            return P4;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return R4;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return I4
    }
}
class D4 {
    constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.setValue = h4(t.type)
    }
}
class F4 {
    constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = L4(t.type)
    }
}
class k4 {
    constructor(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const qy = /(\w+)(\])?(\[|\.)?/g;

function UC(n, e) {
    n.seq.push(e), n.map[e.id] = e
}

function N4(n, e, t) {
    const i = n.name,
        r = i.length;
    for (qy.lastIndex = 0;;) {
        const s = qy.exec(i),
            o = qy.lastIndex;
        let a = s[1];
        const l = s[2] === "]",
            c = s[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === r) {
            UC(t, c === void 0 ? new D4(a, n, e) : new F4(a, n, e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new k4(a), UC(t, h)), t = h
        }
    }
}
class hm {
    constructor(e, t) {
        this.seq = [], this.map = {};
        const i = e.getProgramParameter(t, 35718);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r),
                o = e.getUniformLocation(t, s.name);
            N4(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s],
                l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}

function zC(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t), n.compileShader(i), i
}
let O4 = 0;

function U4(n, e) {
    const t = n.split(`
`),
        i = [],
        r = Math.max(e - 6, 0),
        s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a===e?">":" "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}

function z4(n) {
    switch (n) {
        case Ws:
            return ["Linear", "( value )"];
        case Ct:
            return ["sRGB", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", n), ["Linear", "( value )"]
    }
}

function GC(n, e, t) {
    const i = n.getShaderParameter(e, 35713),
        r = n.getShaderInfoLog(e).trim();
    if (i && r === "") return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + U4(n.getShaderSource(e), o)
    } else return r
}

function G4(n, e) {
    const t = z4(e);
    return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}

function H4(n, e) {
    let t;
    switch (e) {
        case lP:
            t = "Linear";
            break;
        case uP:
            t = "Reinhard";
            break;
        case cP:
            t = "OptimizedCineon";
            break;
        case K1:
            t = "ACESFilmic";
            break;
        case fP:
            t = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}

function V4(n) {
    return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(nf).join(`
`)
}

function W4(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}

function j4(n, e) {
    const t = {},
        i = n.getProgramParameter(e, 35721);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r),
            o = s.name;
        let a = 1;
        s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}

function nf(n) {
    return n !== ""
}

function HC(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function VC(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const J4 = /^[ \t]*#include +<([\w\d./]+)>/gm;

function dx(n) {
    return n.replace(J4, X4)
}

function X4(n, e) {
    const t = pt[e];
    if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
    return dx(t)
}
const Q4 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function WC(n) {
    return n.replace(Q4, K4)
}

function K4(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}

function jC(n) {
    let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function Y4(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === Cg ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === pf ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === ka && (e = "SHADOWMAP_TYPE_VSM"), e
}

function Z4(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap) switch (n.envMapMode) {
        case zo:
        case Go:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Ju:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
    }
    return e
}

function q4(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap) switch (n.envMapMode) {
        case Go:
            e = "ENVMAP_MODE_REFRACTION";
            break
    }
    return e
}

function $4(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap) switch (n.combine) {
        case md:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case oP:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case aP:
            e = "ENVMAP_BLENDING_ADD";
            break
    }
    return e
}

function eG(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2,
        i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}

function tG(n, e, t, i) {
    const r = n.getContext(),
        s = t.defines;
    let o = t.vertexShader,
        a = t.fragmentShader;
    const l = Y4(t),
        c = Z4(t),
        d = q4(t),
        h = $4(t),
        p = eG(t),
        m = t.isWebGL2 ? "" : V4(t),
        v = W4(s),
        y = r.createProgram();
    let A, x, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (A = [v].filter(nf).join(`
`), A.length > 0 && (A += `
`), x = [m, v].filter(nf).join(`
`), x.length > 0 && (x += `
`)) : (A = [jC(t), "#define SHADER_NAME " + t.shaderName, v, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(nf).join(`
`), x = [m, jC(t), "#define SHADER_NAME " + t.shaderName, v, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Dr ? "#define TONE_MAPPING" : "", t.toneMapping !== Dr ? pt.tonemapping_pars_fragment : "", t.toneMapping !== Dr ? H4("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", pt.encodings_pars_fragment, G4("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(nf).join(`
`)), o = dx(o), o = HC(o, t), o = VC(o, t), a = dx(a), a = HC(a, t), a = VC(a, t), o = WC(o), a = WC(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, A = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + A, x = ["#define varying in", t.glslVersion === ux ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === ux ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + x);
    const S = _ + A + o,
        M = _ + x + a,
        b = zC(r, 35633, S),
        B = zC(r, 35632, M);
    if (r.attachShader(y, b), r.attachShader(y, B), t.index0AttributeName !== void 0 ? r.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), n.debug.checkShaderErrors) {
        const P = r.getProgramInfoLog(y).trim(),
            I = r.getShaderInfoLog(b).trim(),
            z = r.getShaderInfoLog(B).trim();
        let Z = !0,
            W = !0;
        if (r.getProgramParameter(y, 35714) === !1) {
            Z = !1;
            const G = GC(r, b, "vertex"),
                K = GC(r, B, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(y, 35715) + `

Program Info Log: ` + P + `
` + G + `
` + K)
        } else P !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", P) : (I === "" || z === "") && (W = !1);
        W && (this.diagnostics = {
            runnable: Z,
            programLog: P,
            vertexShader: {
                log: I,
                prefix: A
            },
            fragmentShader: {
                log: z,
                prefix: x
            }
        })
    }
    r.deleteShader(b), r.deleteShader(B);
    let R;
    this.getUniforms = function() {
        return R === void 0 && (R = new hm(r, y)), R
    };
    let E;
    return this.getAttributes = function() {
        return E === void 0 && (E = j4(r, y)), E
    }, this.destroy = function() {
        i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0
    }, this.name = t.shaderName, this.id = O4++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = b, this.fragmentShader = B, this
}
let nG = 0;
class iG {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader,
            i = e.fragmentShader,
            r = this._getShaderStage(t),
            s = this._getShaderStage(i),
            o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e), this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set, t.set(e, i)), i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new rG(e), t.set(e, i)), i
    }
}
class rG {
    constructor(e) {
        this.id = nG++, this.code = e, this.usedTimes = 0
    }
}

function sG(n, e, t, i, r, s, o) {
    const a = new Ka,
        l = new iG,
        c = [],
        d = r.isWebGL2,
        h = r.logarithmicDepthBuffer,
        p = r.vertexTextures;
    let m = r.precision;
    const v = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function y(E, P, I, z, Z) {
        const W = z.fog,
            G = Z.geometry,
            K = E.isMeshStandardMaterial ? z.environment : null,
            te = (E.isMeshStandardMaterial ? t : e).get(E.envMap || K),
            se = te && te.mapping === Ju ? te.image.height : null,
            k = v[E.type];
        E.precision !== null && (m = r.getMaxPrecision(E.precision), m !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", m, "instead."));
        const V = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color,
            J = V !== void 0 ? V.length : 0;
        let ie = 0;
        G.morphAttributes.position !== void 0 && (ie = 1), G.morphAttributes.normal !== void 0 && (ie = 2), G.morphAttributes.color !== void 0 && (ie = 3);
        let j, re, ve, xe;
        if (k) {
            const Le = Pr[k];
            j = Le.vertexShader, re = Le.fragmentShader
        } else j = E.vertexShader, re = E.fragmentShader, l.update(E), ve = l.getVertexShaderID(E), xe = l.getFragmentShaderID(E);
        const q = n.getRenderTarget(),
            Ne = E.alphaTest > 0,
            Oe = E.clearcoat > 0,
            He = E.iridescence > 0;
        return {
            isWebGL2: d,
            shaderID: k,
            shaderName: E.type,
            vertexShader: j,
            fragmentShader: re,
            defines: E.defines,
            customVertexShaderID: ve,
            customFragmentShaderID: xe,
            isRawShaderMaterial: E.isRawShaderMaterial === !0,
            glslVersion: E.glslVersion,
            precision: m,
            instancing: Z.isInstancedMesh === !0,
            instancingColor: Z.isInstancedMesh === !0 && Z.instanceColor !== null,
            supportsVertexTextures: p,
            outputEncoding: q === null ? n.outputEncoding : q.isXRRenderTarget === !0 ? q.texture.encoding : Ws,
            map: !!E.map,
            matcap: !!E.matcap,
            envMap: !!te,
            envMapMode: te && te.mapping,
            envMapCubeUVHeight: se,
            lightMap: !!E.lightMap,
            aoMap: !!E.aoMap,
            emissiveMap: !!E.emissiveMap,
            bumpMap: !!E.bumpMap,
            normalMap: !!E.normalMap,
            objectSpaceNormalMap: E.normalMapType === LP,
            tangentSpaceNormalMap: E.normalMapType === Xs,
            decodeVideoTexture: !!E.map && E.map.isVideoTexture === !0 && E.map.encoding === Ct,
            clearcoat: Oe,
            clearcoatMap: Oe && !!E.clearcoatMap,
            clearcoatRoughnessMap: Oe && !!E.clearcoatRoughnessMap,
            clearcoatNormalMap: Oe && !!E.clearcoatNormalMap,
            iridescence: He,
            iridescenceMap: He && !!E.iridescenceMap,
            iridescenceThicknessMap: He && !!E.iridescenceThicknessMap,
            displacementMap: !!E.displacementMap,
            roughnessMap: !!E.roughnessMap,
            metalnessMap: !!E.metalnessMap,
            specularMap: !!E.specularMap,
            specularIntensityMap: !!E.specularIntensityMap,
            specularColorMap: !!E.specularColorMap,
            opaque: E.transparent === !1 && E.blending === Wa,
            alphaMap: !!E.alphaMap,
            alphaTest: Ne,
            gradientMap: !!E.gradientMap,
            sheen: E.sheen > 0,
            sheenColorMap: !!E.sheenColorMap,
            sheenRoughnessMap: !!E.sheenRoughnessMap,
            transmission: E.transmission > 0,
            transmissionMap: !!E.transmissionMap,
            thicknessMap: !!E.thicknessMap,
            combine: E.combine,
            vertexTangents: !!E.normalMap && !!G.attributes.tangent,
            vertexColors: E.vertexColors,
            vertexAlphas: E.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
            vertexUvs: !!E.map || !!E.bumpMap || !!E.normalMap || !!E.specularMap || !!E.alphaMap || !!E.emissiveMap || !!E.roughnessMap || !!E.metalnessMap || !!E.clearcoatMap || !!E.clearcoatRoughnessMap || !!E.clearcoatNormalMap || !!E.iridescenceMap || !!E.iridescenceThicknessMap || !!E.displacementMap || !!E.transmissionMap || !!E.thicknessMap || !!E.specularIntensityMap || !!E.specularColorMap || !!E.sheenColorMap || !!E.sheenRoughnessMap,
            uvsVertexOnly: !(E.map || E.bumpMap || E.normalMap || E.specularMap || E.alphaMap || E.emissiveMap || E.roughnessMap || E.metalnessMap || E.clearcoatNormalMap || E.iridescenceMap || E.iridescenceThicknessMap || E.transmission > 0 || E.transmissionMap || E.thicknessMap || E.specularIntensityMap || E.specularColorMap || E.sheen > 0 || E.sheenColorMap || E.sheenRoughnessMap) && !!E.displacementMap,
            fog: !!W,
            useFog: E.fog === !0,
            fogExp2: W && W.isFogExp2,
            flatShading: !!E.flatShading,
            sizeAttenuation: E.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: Z.isSkinnedMesh === !0,
            morphTargets: G.morphAttributes.position !== void 0,
            morphNormals: G.morphAttributes.normal !== void 0,
            morphColors: G.morphAttributes.color !== void 0,
            morphTargetsCount: J,
            morphTextureStride: ie,
            numDirLights: P.directional.length,
            numPointLights: P.point.length,
            numSpotLights: P.spot.length,
            numSpotLightMaps: P.spotLightMap.length,
            numRectAreaLights: P.rectArea.length,
            numHemiLights: P.hemi.length,
            numDirLightShadows: P.directionalShadowMap.length,
            numPointLightShadows: P.pointShadowMap.length,
            numSpotLightShadows: P.spotShadowMap.length,
            numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: E.dithering,
            shadowMapEnabled: n.shadowMap.enabled && I.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: E.toneMapped ? n.toneMapping : Dr,
            physicallyCorrectLights: n.physicallyCorrectLights,
            premultipliedAlpha: E.premultipliedAlpha,
            doubleSided: E.side === Rr,
            flipSided: E.side === Ci,
            useDepthPacking: !!E.depthPacking,
            depthPacking: E.depthPacking || 0,
            index0AttributeName: E.index0AttributeName,
            extensionDerivatives: E.extensions && E.extensions.derivatives,
            extensionFragDepth: E.extensions && E.extensions.fragDepth,
            extensionDrawBuffers: E.extensions && E.extensions.drawBuffers,
            extensionShaderTextureLOD: E.extensions && E.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
            customProgramCacheKey: E.customProgramCacheKey()
        }
    }

    function A(E) {
        const P = [];
        if (E.shaderID ? P.push(E.shaderID) : (P.push(E.customVertexShaderID), P.push(E.customFragmentShaderID)), E.defines !== void 0)
            for (const I in E.defines) P.push(I), P.push(E.defines[I]);
        return E.isRawShaderMaterial === !1 && (x(P, E), _(P, E), P.push(n.outputEncoding)), P.push(E.customProgramCacheKey), P.join()
    }

    function x(E, P) {
        E.push(P.precision), E.push(P.outputEncoding), E.push(P.envMapMode), E.push(P.envMapCubeUVHeight), E.push(P.combine), E.push(P.vertexUvs), E.push(P.fogExp2), E.push(P.sizeAttenuation), E.push(P.morphTargetsCount), E.push(P.morphAttributeCount), E.push(P.numDirLights), E.push(P.numPointLights), E.push(P.numSpotLights), E.push(P.numSpotLightMaps), E.push(P.numHemiLights), E.push(P.numRectAreaLights), E.push(P.numDirLightShadows), E.push(P.numPointLightShadows), E.push(P.numSpotLightShadows), E.push(P.numSpotLightShadowsWithMaps), E.push(P.shadowMapType), E.push(P.toneMapping), E.push(P.numClippingPlanes), E.push(P.numClipIntersection), E.push(P.depthPacking)
    }

    function _(E, P) {
        a.disableAll(), P.isWebGL2 && a.enable(0), P.supportsVertexTextures && a.enable(1), P.instancing && a.enable(2), P.instancingColor && a.enable(3), P.map && a.enable(4), P.matcap && a.enable(5), P.envMap && a.enable(6), P.lightMap && a.enable(7), P.aoMap && a.enable(8), P.emissiveMap && a.enable(9), P.bumpMap && a.enable(10), P.normalMap && a.enable(11), P.objectSpaceNormalMap && a.enable(12), P.tangentSpaceNormalMap && a.enable(13), P.clearcoat && a.enable(14), P.clearcoatMap && a.enable(15), P.clearcoatRoughnessMap && a.enable(16), P.clearcoatNormalMap && a.enable(17), P.iridescence && a.enable(18), P.iridescenceMap && a.enable(19), P.iridescenceThicknessMap && a.enable(20), P.displacementMap && a.enable(21), P.specularMap && a.enable(22), P.roughnessMap && a.enable(23), P.metalnessMap && a.enable(24), P.gradientMap && a.enable(25), P.alphaMap && a.enable(26), P.alphaTest && a.enable(27), P.vertexColors && a.enable(28), P.vertexAlphas && a.enable(29), P.vertexUvs && a.enable(30), P.vertexTangents && a.enable(31), P.uvsVertexOnly && a.enable(32), E.push(a.mask), a.disableAll(), P.fog && a.enable(0), P.useFog && a.enable(1), P.flatShading && a.enable(2), P.logarithmicDepthBuffer && a.enable(3), P.skinning && a.enable(4), P.morphTargets && a.enable(5), P.morphNormals && a.enable(6), P.morphColors && a.enable(7), P.premultipliedAlpha && a.enable(8), P.shadowMapEnabled && a.enable(9), P.physicallyCorrectLights && a.enable(10), P.doubleSided && a.enable(11), P.flipSided && a.enable(12), P.useDepthPacking && a.enable(13), P.dithering && a.enable(14), P.specularIntensityMap && a.enable(15), P.specularColorMap && a.enable(16), P.transmission && a.enable(17), P.transmissionMap && a.enable(18), P.thicknessMap && a.enable(19), P.sheen && a.enable(20), P.sheenColorMap && a.enable(21), P.sheenRoughnessMap && a.enable(22), P.decodeVideoTexture && a.enable(23), P.opaque && a.enable(24), E.push(a.mask)
    }

    function S(E) {
        const P = v[E.type];
        let I;
        if (P) {
            const z = Pr[P];
            I = UP.clone(z.uniforms)
        } else I = E.uniforms;
        return I
    }

    function M(E, P) {
        let I;
        for (let z = 0, Z = c.length; z < Z; z++) {
            const W = c[z];
            if (W.cacheKey === P) {
                I = W, ++I.usedTimes;
                break
            }
        }
        return I === void 0 && (I = new tG(n, P, E, s), c.push(I)), I
    }

    function b(E) {
        if (--E.usedTimes === 0) {
            const P = c.indexOf(E);
            c[P] = c[c.length - 1], c.pop(), E.destroy()
        }
    }

    function B(E) {
        l.remove(E)
    }

    function R() {
        l.dispose()
    }
    return {
        getParameters: y,
        getProgramCacheKey: A,
        getUniforms: S,
        acquireProgram: M,
        releaseProgram: b,
        releaseShaderCache: B,
        programs: c,
        dispose: R
    }
}

function oG() {
    let n = new WeakMap;

    function e(s) {
        let o = n.get(s);
        return o === void 0 && (o = {}, n.set(s, o)), o
    }

    function t(s) {
        n.delete(s)
    }

    function i(s, o, a) {
        n.get(s)[o] = a
    }

    function r() {
        n = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: i,
        dispose: r
    }
}

function aG(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}

function JC(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}

function XC() {
    const n = [];
    let e = 0;
    const t = [],
        i = [],
        r = [];

    function s() {
        e = 0, t.length = 0, i.length = 0, r.length = 0
    }

    function o(h, p, m, v, y, A) {
        let x = n[e];
        return x === void 0 ? (x = {
            id: h.id,
            object: h,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: h.renderOrder,
            z: y,
            group: A
        }, n[e] = x) : (x.id = h.id, x.object = h, x.geometry = p, x.material = m, x.groupOrder = v, x.renderOrder = h.renderOrder, x.z = y, x.group = A), e++, x
    }

    function a(h, p, m, v, y, A) {
        const x = o(h, p, m, v, y, A);
        m.transmission > 0 ? i.push(x) : m.transparent === !0 ? r.push(x) : t.push(x)
    }

    function l(h, p, m, v, y, A) {
        const x = o(h, p, m, v, y, A);
        m.transmission > 0 ? i.unshift(x) : m.transparent === !0 ? r.unshift(x) : t.unshift(x)
    }

    function c(h, p) {
        t.length > 1 && t.sort(h || aG), i.length > 1 && i.sort(p || JC), r.length > 1 && r.sort(p || JC)
    }

    function d() {
        for (let h = e, p = n.length; h < p; h++) {
            const m = n[h];
            if (m.id === null) break;
            m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: d,
        sort: c
    }
}

function lG() {
    let n = new WeakMap;

    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new XC, n.set(i, [o])) : r >= s.length ? (o = new XC, s.push(o)) : o = s[r], o
    }

    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}

function uG() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        direction: new D,
                        color: new Ie
                    };
                    break;
                case "SpotLight":
                    t = {
                        position: new D,
                        direction: new D,
                        color: new Ie,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new D,
                        color: new Ie,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new D,
                        skyColor: new Ie,
                        groundColor: new Ie
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new Ie,
                        position: new D,
                        halfWidth: new D,
                        halfHeight: new D
                    };
                    break
            }
            return n[e.id] = t, t
        }
    }
}

function cG() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new me
                    };
                    break;
                case "SpotLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new me
                    };
                    break;
                case "PointLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new me,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
            }
            return n[e.id] = t, t
        }
    }
}
let fG = 0;

function dG(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}

function hG(n, e) {
    const t = new uG,
        i = cG(),
        r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0
        };
    for (let d = 0; d < 9; d++) r.probe.push(new D);
    const s = new D,
        o = new rt,
        a = new rt;

    function l(d, h) {
        let p = 0,
            m = 0,
            v = 0;
        for (let z = 0; z < 9; z++) r.probe[z].set(0, 0, 0);
        let y = 0,
            A = 0,
            x = 0,
            _ = 0,
            S = 0,
            M = 0,
            b = 0,
            B = 0,
            R = 0,
            E = 0;
        d.sort(dG);
        const P = h !== !0 ? Math.PI : 1;
        for (let z = 0, Z = d.length; z < Z; z++) {
            const W = d[z],
                G = W.color,
                K = W.intensity,
                te = W.distance,
                se = W.shadow && W.shadow.map ? W.shadow.map.texture : null;
            if (W.isAmbientLight) p += G.r * K * P, m += G.g * K * P, v += G.b * K * P;
            else if (W.isLightProbe)
                for (let k = 0; k < 9; k++) r.probe[k].addScaledVector(W.sh.coefficients[k], K);
            else if (W.isDirectionalLight) {
                const k = t.get(W);
                if (k.color.copy(W.color).multiplyScalar(W.intensity * P), W.castShadow) {
                    const V = W.shadow,
                        J = i.get(W);
                    J.shadowBias = V.bias, J.shadowNormalBias = V.normalBias, J.shadowRadius = V.radius, J.shadowMapSize = V.mapSize, r.directionalShadow[y] = J, r.directionalShadowMap[y] = se, r.directionalShadowMatrix[y] = W.shadow.matrix, M++
                }
                r.directional[y] = k, y++
            } else if (W.isSpotLight) {
                const k = t.get(W);
                k.position.setFromMatrixPosition(W.matrixWorld), k.color.copy(G).multiplyScalar(K * P), k.distance = te, k.coneCos = Math.cos(W.angle), k.penumbraCos = Math.cos(W.angle * (1 - W.penumbra)), k.decay = W.decay, r.spot[x] = k;
                const V = W.shadow;
                if (W.map && (r.spotLightMap[R] = W.map, R++, V.updateMatrices(W), W.castShadow && E++), r.spotLightMatrix[x] = V.matrix, W.castShadow) {
                    const J = i.get(W);
                    J.shadowBias = V.bias, J.shadowNormalBias = V.normalBias, J.shadowRadius = V.radius, J.shadowMapSize = V.mapSize, r.spotShadow[x] = J, r.spotShadowMap[x] = se, B++
                }
                x++
            } else if (W.isRectAreaLight) {
                const k = t.get(W);
                k.color.copy(G).multiplyScalar(K), k.halfWidth.set(W.width * .5, 0, 0), k.halfHeight.set(0, W.height * .5, 0), r.rectArea[_] = k, _++
            } else if (W.isPointLight) {
                const k = t.get(W);
                if (k.color.copy(W.color).multiplyScalar(W.intensity * P), k.distance = W.distance, k.decay = W.decay, W.castShadow) {
                    const V = W.shadow,
                        J = i.get(W);
                    J.shadowBias = V.bias, J.shadowNormalBias = V.normalBias, J.shadowRadius = V.radius, J.shadowMapSize = V.mapSize, J.shadowCameraNear = V.camera.near, J.shadowCameraFar = V.camera.far, r.pointShadow[A] = J, r.pointShadowMap[A] = se, r.pointShadowMatrix[A] = W.shadow.matrix, b++
                }
                r.point[A] = k, A++
            } else if (W.isHemisphereLight) {
                const k = t.get(W);
                k.skyColor.copy(W.color).multiplyScalar(K * P), k.groundColor.copy(W.groundColor).multiplyScalar(K * P), r.hemi[S] = k, S++
            }
        }
        _ > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_FLOAT_1, r.rectAreaLTC2 = Re.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_HALF_1, r.rectAreaLTC2 = Re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = m, r.ambient[2] = v;
        const I = r.hash;
        (I.directionalLength !== y || I.pointLength !== A || I.spotLength !== x || I.rectAreaLength !== _ || I.hemiLength !== S || I.numDirectionalShadows !== M || I.numPointShadows !== b || I.numSpotShadows !== B || I.numSpotMaps !== R) && (r.directional.length = y, r.spot.length = x, r.rectArea.length = _, r.point.length = A, r.hemi.length = S, r.directionalShadow.length = M, r.directionalShadowMap.length = M, r.pointShadow.length = b, r.pointShadowMap.length = b, r.spotShadow.length = B, r.spotShadowMap.length = B, r.directionalShadowMatrix.length = M, r.pointShadowMatrix.length = b, r.spotLightMatrix.length = B + R - E, r.spotLightMap.length = R, r.numSpotLightShadowsWithMaps = E, I.directionalLength = y, I.pointLength = A, I.spotLength = x, I.rectAreaLength = _, I.hemiLength = S, I.numDirectionalShadows = M, I.numPointShadows = b, I.numSpotShadows = B, I.numSpotMaps = R, r.version = fG++)
    }

    function c(d, h) {
        let p = 0,
            m = 0,
            v = 0,
            y = 0,
            A = 0;
        const x = h.matrixWorldInverse;
        for (let _ = 0, S = d.length; _ < S; _++) {
            const M = d[_];
            if (M.isDirectionalLight) {
                const b = r.directional[p];
                b.direction.setFromMatrixPosition(M.matrixWorld), s.setFromMatrixPosition(M.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(x), p++
            } else if (M.isSpotLight) {
                const b = r.spot[v];
                b.position.setFromMatrixPosition(M.matrixWorld), b.position.applyMatrix4(x), b.direction.setFromMatrixPosition(M.matrixWorld), s.setFromMatrixPosition(M.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(x), v++
            } else if (M.isRectAreaLight) {
                const b = r.rectArea[y];
                b.position.setFromMatrixPosition(M.matrixWorld), b.position.applyMatrix4(x), a.identity(), o.copy(M.matrixWorld), o.premultiply(x), a.extractRotation(o), b.halfWidth.set(M.width * .5, 0, 0), b.halfHeight.set(0, M.height * .5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), y++
            } else if (M.isPointLight) {
                const b = r.point[m];
                b.position.setFromMatrixPosition(M.matrixWorld), b.position.applyMatrix4(x), m++
            } else if (M.isHemisphereLight) {
                const b = r.hemi[A];
                b.direction.setFromMatrixPosition(M.matrixWorld), b.direction.transformDirection(x), A++
            }
        }
    }
    return {
        setup: l,
        setupView: c,
        state: r
    }
}

function QC(n, e) {
    const t = new hG(n, e),
        i = [],
        r = [];

    function s() {
        i.length = 0, r.length = 0
    }

    function o(h) {
        i.push(h)
    }

    function a(h) {
        r.push(h)
    }

    function l(h) {
        t.setup(i, h)
    }

    function c(h) {
        t.setupView(i, h)
    }
    return {
        init: s,
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: t
        },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a
    }
}

function pG(n, e) {
    let t = new WeakMap;

    function i(s, o = 0) {
        const a = t.get(s);
        let l;
        return a === void 0 ? (l = new QC(n, e), t.set(s, [l])) : o >= a.length ? (l = new QC(n, e), a.push(l)) : l = a[o], l
    }

    function r() {
        t = new WeakMap
    }
    return {
        get: i,
        dispose: r
    }
}
class l_ extends wn {
    constructor(e) {
        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = RP, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }
}
class u_ extends wn {
    constructor(e) {
        super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new D, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }
}
const mG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    gG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function yG(n, e, t) {
    let i = new Pg;
    const r = new me,
        s = new me,
        o = new kt,
        a = new l_({
            depthPacking: IP
        }),
        l = new u_,
        c = {},
        d = t.maxTextureSize,
        h = {
            [rs]: Ci,
            [Ci]: rs,
            [Rr]: Rr
        },
        p = new os({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new me
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: mG,
            fragmentShader: gG
        }),
        m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const v = new ut;
    v.setAttribute("position", new Dt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const y = new bn(v, p),
        A = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Cg, this.render = function(M, b, B) {
        if (A.enabled === !1 || A.autoUpdate === !1 && A.needsUpdate === !1 || M.length === 0) return;
        const R = n.getRenderTarget(),
            E = n.getActiveCubeFace(),
            P = n.getActiveMipmapLevel(),
            I = n.state;
        I.setBlending(ks), I.buffers.color.setClear(1, 1, 1, 1), I.buffers.depth.setTest(!0), I.setScissorTest(!1);
        for (let z = 0, Z = M.length; z < Z; z++) {
            const W = M[z],
                G = W.shadow;
            if (G === void 0) {
                console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
                continue
            }
            if (G.autoUpdate === !1 && G.needsUpdate === !1) continue;
            r.copy(G.mapSize);
            const K = G.getFrameExtents();
            if (r.multiply(K), s.copy(G.mapSize), (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / K.x), r.x = s.x * K.x, G.mapSize.x = s.x), r.y > d && (s.y = Math.floor(d / K.y), r.y = s.y * K.y, G.mapSize.y = s.y)), G.map === null) {
                const se = this.type !== ka ? {
                    minFilter: fn,
                    magFilter: fn
                } : {};
                G.map = new Nr(r.x, r.y, se), G.map.texture.name = W.name + ".shadowMap", G.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(G.map), n.clear();
            const te = G.getViewportCount();
            for (let se = 0; se < te; se++) {
                const k = G.getViewport(se);
                o.set(s.x * k.x, s.y * k.y, s.x * k.z, s.y * k.w), I.viewport(o), G.updateMatrices(W, se), i = G.getFrustum(), S(b, B, G.camera, W, this.type)
            }
            G.isPointLightShadow !== !0 && this.type === ka && x(G, B), G.needsUpdate = !1
        }
        A.needsUpdate = !1, n.setRenderTarget(R, E, P)
    };

    function x(M, b) {
        const B = e.update(y);
        p.defines.VSM_SAMPLES !== M.blurSamples && (p.defines.VSM_SAMPLES = M.blurSamples, m.defines.VSM_SAMPLES = M.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), M.mapPass === null && (M.mapPass = new Nr(r.x, r.y)), p.uniforms.shadow_pass.value = M.map.texture, p.uniforms.resolution.value = M.mapSize, p.uniforms.radius.value = M.radius, n.setRenderTarget(M.mapPass), n.clear(), n.renderBufferDirect(b, null, B, p, y, null), m.uniforms.shadow_pass.value = M.mapPass.texture, m.uniforms.resolution.value = M.mapSize, m.uniforms.radius.value = M.radius, n.setRenderTarget(M.map), n.clear(), n.renderBufferDirect(b, null, B, m, y, null)
    }

    function _(M, b, B, R, E, P) {
        let I = null;
        const z = B.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
        if (z !== void 0) I = z;
        else if (I = B.isPointLight === !0 ? l : a, n.localClippingEnabled && b.clipShadows === !0 && Array.isArray(b.clippingPlanes) && b.clippingPlanes.length !== 0 || b.displacementMap && b.displacementScale !== 0 || b.alphaMap && b.alphaTest > 0 || b.map && b.alphaTest > 0) {
            const Z = I.uuid,
                W = b.uuid;
            let G = c[Z];
            G === void 0 && (G = {}, c[Z] = G);
            let K = G[W];
            K === void 0 && (K = I.clone(), G[W] = K), I = K
        }
        return I.visible = b.visible, I.wireframe = b.wireframe, P === ka ? I.side = b.shadowSide !== null ? b.shadowSide : b.side : I.side = b.shadowSide !== null ? b.shadowSide : h[b.side], I.alphaMap = b.alphaMap, I.alphaTest = b.alphaTest, I.map = b.map, I.clipShadows = b.clipShadows, I.clippingPlanes = b.clippingPlanes, I.clipIntersection = b.clipIntersection, I.displacementMap = b.displacementMap, I.displacementScale = b.displacementScale, I.displacementBias = b.displacementBias, I.wireframeLinewidth = b.wireframeLinewidth, I.linewidth = b.linewidth, B.isPointLight === !0 && I.isMeshDistanceMaterial === !0 && (I.referencePosition.setFromMatrixPosition(B.matrixWorld), I.nearDistance = R, I.farDistance = E), I
    }

    function S(M, b, B, R, E) {
        if (M.visible === !1) return;
        if (M.layers.test(b.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && E === ka) && (!M.frustumCulled || i.intersectsObject(M))) {
            M.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, M.matrixWorld);
            const z = e.update(M),
                Z = M.material;
            if (Array.isArray(Z)) {
                const W = z.groups;
                for (let G = 0, K = W.length; G < K; G++) {
                    const te = W[G],
                        se = Z[te.materialIndex];
                    if (se && se.visible) {
                        const k = _(M, se, R, B.near, B.far, E);
                        n.renderBufferDirect(B, null, z, k, M, te)
                    }
                }
            } else if (Z.visible) {
                const W = _(M, Z, R, B.near, B.far, E);
                n.renderBufferDirect(B, null, z, W, M, null)
            }
        }
        const I = M.children;
        for (let z = 0, Z = I.length; z < Z; z++) S(I[z], b, B, R, E)
    }
}

function vG(n, e, t) {
    const i = t.isWebGL2;

    function r() {
        let Q = !1;
        const fe = new kt;
        let Ae = null;
        const Ue = new kt(0, 0, 0, 0);
        return {
            setMask: function(Ke) {
                Ae !== Ke && !Q && (n.colorMask(Ke, Ke, Ke, Ke), Ae = Ke)
            },
            setLocked: function(Ke) {
                Q = Ke
            },
            setClear: function(Ke, Bt, dn, Pn, Gr) {
                Gr === !0 && (Ke *= Pn, Bt *= Pn, dn *= Pn), fe.set(Ke, Bt, dn, Pn), Ue.equals(fe) === !1 && (n.clearColor(Ke, Bt, dn, Pn), Ue.copy(fe))
            },
            reset: function() {
                Q = !1, Ae = null, Ue.set(-1, 0, 0, 0)
            }
        }
    }

    function s() {
        let Q = !1,
            fe = null,
            Ae = null,
            Ue = null;
        return {
            setTest: function(Ke) {
                Ke ? Ne(2929) : Oe(2929)
            },
            setMask: function(Ke) {
                fe !== Ke && !Q && (n.depthMask(Ke), fe = Ke)
            },
            setFunc: function(Ke) {
                if (Ae !== Ke) {
                    switch (Ke) {
                        case $B:
                            n.depthFunc(512);
                            break;
                        case eP:
                            n.depthFunc(519);
                            break;
                        case tP:
                            n.depthFunc(513);
                            break;
                        case Wm:
                            n.depthFunc(515);
                            break;
                        case nP:
                            n.depthFunc(514);
                            break;
                        case iP:
                            n.depthFunc(518);
                            break;
                        case rP:
                            n.depthFunc(516);
                            break;
                        case sP:
                            n.depthFunc(517);
                            break;
                        default:
                            n.depthFunc(515)
                    }
                    Ae = Ke
                }
            },
            setLocked: function(Ke) {
                Q = Ke
            },
            setClear: function(Ke) {
                Ue !== Ke && (n.clearDepth(Ke), Ue = Ke)
            },
            reset: function() {
                Q = !1, fe = null, Ae = null, Ue = null
            }
        }
    }

    function o() {
        let Q = !1,
            fe = null,
            Ae = null,
            Ue = null,
            Ke = null,
            Bt = null,
            dn = null,
            Pn = null,
            Gr = null;
        return {
            setTest: function(Ot) {
                Q || (Ot ? Ne(2960) : Oe(2960))
            },
            setMask: function(Ot) {
                fe !== Ot && !Q && (n.stencilMask(Ot), fe = Ot)
            },
            setFunc: function(Ot, ji, pi) {
                (Ae !== Ot || Ue !== ji || Ke !== pi) && (n.stencilFunc(Ot, ji, pi), Ae = Ot, Ue = ji, Ke = pi)
            },
            setOp: function(Ot, ji, pi) {
                (Bt !== Ot || dn !== ji || Pn !== pi) && (n.stencilOp(Ot, ji, pi), Bt = Ot, dn = ji, Pn = pi)
            },
            setLocked: function(Ot) {
                Q = Ot
            },
            setClear: function(Ot) {
                Gr !== Ot && (n.clearStencil(Ot), Gr = Ot)
            },
            reset: function() {
                Q = !1, fe = null, Ae = null, Ue = null, Ke = null, Bt = null, dn = null, Pn = null, Gr = null
            }
        }
    }
    const a = new r,
        l = new s,
        c = new o,
        d = new WeakMap,
        h = new WeakMap;
    let p = {},
        m = {},
        v = new WeakMap,
        y = [],
        A = null,
        x = !1,
        _ = null,
        S = null,
        M = null,
        b = null,
        B = null,
        R = null,
        E = null,
        P = !1,
        I = null,
        z = null,
        Z = null,
        W = null,
        G = null;
    const K = n.getParameter(35661);
    let te = !1,
        se = 0;
    const k = n.getParameter(7938);
    k.indexOf("WebGL") !== -1 ? (se = parseFloat(/^WebGL (\d)/.exec(k)[1]), te = se >= 1) : k.indexOf("OpenGL ES") !== -1 && (se = parseFloat(/^OpenGL ES (\d)/.exec(k)[1]), te = se >= 2);
    let V = null,
        J = {};
    const ie = n.getParameter(3088),
        j = n.getParameter(2978),
        re = new kt().fromArray(ie),
        ve = new kt().fromArray(j);

    function xe(Q, fe, Ae) {
        const Ue = new Uint8Array(4),
            Ke = n.createTexture();
        n.bindTexture(Q, Ke), n.texParameteri(Q, 10241, 9728), n.texParameteri(Q, 10240, 9728);
        for (let Bt = 0; Bt < Ae; Bt++) n.texImage2D(fe + Bt, 0, 6408, 1, 1, 0, 6408, 5121, Ue);
        return Ke
    }
    const q = {};
    q[3553] = xe(3553, 3553, 1), q[34067] = xe(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), Ne(2929), l.setFunc(Wm), Pe(!1), Ze(DA), Ne(2884), Ce(ks);

    function Ne(Q) {
        p[Q] !== !0 && (n.enable(Q), p[Q] = !0)
    }

    function Oe(Q) {
        p[Q] !== !1 && (n.disable(Q), p[Q] = !1)
    }

    function He(Q, fe) {
        return m[Q] !== fe ? (n.bindFramebuffer(Q, fe), m[Q] = fe, i && (Q === 36009 && (m[36160] = fe), Q === 36160 && (m[36009] = fe)), !0) : !1
    }

    function we(Q, fe) {
        let Ae = y,
            Ue = !1;
        if (Q)
            if (Ae = v.get(fe), Ae === void 0 && (Ae = [], v.set(fe, Ae)), Q.isWebGLMultipleRenderTargets) {
                const Ke = Q.texture;
                if (Ae.length !== Ke.length || Ae[0] !== 36064) {
                    for (let Bt = 0, dn = Ke.length; Bt < dn; Bt++) Ae[Bt] = 36064 + Bt;
                    Ae.length = Ke.length, Ue = !0
                }
            } else Ae[0] !== 36064 && (Ae[0] = 36064, Ue = !0);
        else Ae[0] !== 1029 && (Ae[0] = 1029, Ue = !0);
        Ue && (t.isWebGL2 ? n.drawBuffers(Ae) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ae))
    }

    function Le(Q) {
        return A !== Q ? (n.useProgram(Q), A = Q, !0) : !1
    }
    const he = {
        [Pa]: 32774,
        [HB]: 32778,
        [VB]: 32779
    };
    if (i) he[OA] = 32775, he[UA] = 32776;
    else {
        const Q = e.get("EXT_blend_minmax");
        Q !== null && (he[OA] = Q.MIN_EXT, he[UA] = Q.MAX_EXT)
    }
    const ae = {
        [WB]: 0,
        [jB]: 1,
        [JB]: 768,
        [X1]: 770,
        [qB]: 776,
        [YB]: 774,
        [QB]: 772,
        [XB]: 769,
        [Q1]: 771,
        [ZB]: 775,
        [KB]: 773
    };

    function Ce(Q, fe, Ae, Ue, Ke, Bt, dn, Pn) {
        if (Q === ks) {
            x === !0 && (Oe(3042), x = !1);
            return
        }
        if (x === !1 && (Ne(3042), x = !0), Q !== GB) {
            if (Q !== _ || Pn !== P) {
                if ((S !== Pa || B !== Pa) && (n.blendEquation(32774), S = Pa, B = Pa), Pn) switch (Q) {
                    case Wa:
                        n.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case FA:
                        n.blendFunc(1, 1);
                        break;
                    case kA:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case NA:
                        n.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Q);
                        break
                } else switch (Q) {
                    case Wa:
                        n.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case FA:
                        n.blendFunc(770, 1);
                        break;
                    case kA:
                        n.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case NA:
                        n.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Q);
                        break
                }
                M = null, b = null, R = null, E = null, _ = Q, P = Pn
            }
            return
        }
        Ke = Ke || fe, Bt = Bt || Ae, dn = dn || Ue, (fe !== S || Ke !== B) && (n.blendEquationSeparate(he[fe], he[Ke]), S = fe, B = Ke), (Ae !== M || Ue !== b || Bt !== R || dn !== E) && (n.blendFuncSeparate(ae[Ae], ae[Ue], ae[Bt], ae[dn]), M = Ae, b = Ue, R = Bt, E = dn), _ = Q, P = !1
    }

    function ze(Q, fe) {
        Q.side === Rr ? Oe(2884) : Ne(2884);
        let Ae = Q.side === Ci;
        fe && (Ae = !Ae), Pe(Ae), Q.blending === Wa && Q.transparent === !1 ? Ce(ks) : Ce(Q.blending, Q.blendEquation, Q.blendSrc, Q.blendDst, Q.blendEquationAlpha, Q.blendSrcAlpha, Q.blendDstAlpha, Q.premultipliedAlpha), l.setFunc(Q.depthFunc), l.setTest(Q.depthTest), l.setMask(Q.depthWrite), a.setMask(Q.colorWrite);
        const Ue = Q.stencilWrite;
        c.setTest(Ue), Ue && (c.setMask(Q.stencilWriteMask), c.setFunc(Q.stencilFunc, Q.stencilRef, Q.stencilFuncMask), c.setOp(Q.stencilFail, Q.stencilZFail, Q.stencilZPass)), je(Q.polygonOffset, Q.polygonOffsetFactor, Q.polygonOffsetUnits), Q.alphaToCoverage === !0 ? Ne(32926) : Oe(32926)
    }

    function Pe(Q) {
        I !== Q && (Q ? n.frontFace(2304) : n.frontFace(2305), I = Q)
    }

    function Ze(Q) {
        Q !== OB ? (Ne(2884), Q !== z && (Q === DA ? n.cullFace(1029) : Q === UB ? n.cullFace(1028) : n.cullFace(1032))) : Oe(2884), z = Q
    }

    function Je(Q) {
        Q !== Z && (te && n.lineWidth(Q), Z = Q)
    }

    function je(Q, fe, Ae) {
        Q ? (Ne(32823), (W !== fe || G !== Ae) && (n.polygonOffset(fe, Ae), W = fe, G = Ae)) : Oe(32823)
    }

    function vt(Q) {
        Q ? Ne(3089) : Oe(3089)
    }

    function St(Q) {
        Q === void 0 && (Q = 33984 + K - 1), V !== Q && (n.activeTexture(Q), V = Q)
    }

    function O(Q, fe, Ae) {
        Ae === void 0 && (V === null ? Ae = 33984 + K - 1 : Ae = V);
        let Ue = J[Ae];
        Ue === void 0 && (Ue = {
            type: void 0,
            texture: void 0
        }, J[Ae] = Ue), (Ue.type !== Q || Ue.texture !== fe) && (V !== Ae && (n.activeTexture(Ae), V = Ae), n.bindTexture(Q, fe || q[Q]), Ue.type = Q, Ue.texture = fe)
    }

    function L() {
        const Q = J[V];
        Q !== void 0 && Q.type !== void 0 && (n.bindTexture(Q.type, null), Q.type = void 0, Q.texture = void 0)
    }

    function oe() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function Se() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function Ee() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function Be() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function tt() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function De() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function ge() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function Xe() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function H() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function ue() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (Q) {
            console.error("THREE.WebGLState:", Q)
        }
    }

    function _e(Q) {
        re.equals(Q) === !1 && (n.scissor(Q.x, Q.y, Q.z, Q.w), re.copy(Q))
    }

    function Te(Q) {
        ve.equals(Q) === !1 && (n.viewport(Q.x, Q.y, Q.z, Q.w), ve.copy(Q))
    }

    function $e(Q, fe) {
        let Ae = h.get(fe);
        Ae === void 0 && (Ae = new WeakMap, h.set(fe, Ae));
        let Ue = Ae.get(Q);
        Ue === void 0 && (Ue = n.getUniformBlockIndex(fe, Q.name), Ae.set(Q, Ue))
    }

    function yt(Q, fe) {
        const Ue = h.get(fe).get(Q);
        d.get(fe) !== Ue && (n.uniformBlockBinding(fe, Ue, Q.__bindingPointIndex), d.set(fe, Ue))
    }

    function Vt() {
        n.disable(3042), n.disable(2884), n.disable(2929), n.disable(32823), n.disable(3089), n.disable(2960), n.disable(32926), n.blendEquation(32774), n.blendFunc(1, 0), n.blendFuncSeparate(1, 0, 1, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(513), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(519, 0, 4294967295), n.stencilOp(7680, 7680, 7680), n.clearStencil(0), n.cullFace(1029), n.frontFace(2305), n.polygonOffset(0, 0), n.activeTexture(33984), n.bindFramebuffer(36160, null), i === !0 && (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), p = {}, V = null, J = {}, m = {}, v = new WeakMap, y = [], A = null, x = !1, _ = null, S = null, M = null, b = null, B = null, R = null, E = null, P = !1, I = null, z = null, Z = null, W = null, G = null, re.set(0, 0, n.canvas.width, n.canvas.height), ve.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), c.reset()
    }
    return {
        buffers: {
            color: a,
            depth: l,
            stencil: c
        },
        enable: Ne,
        disable: Oe,
        bindFramebuffer: He,
        drawBuffers: we,
        useProgram: Le,
        setBlending: Ce,
        setMaterial: ze,
        setFlipSided: Pe,
        setCullFace: Ze,
        setLineWidth: Je,
        setPolygonOffset: je,
        setScissorTest: vt,
        activeTexture: St,
        bindTexture: O,
        unbindTexture: L,
        compressedTexImage2D: oe,
        compressedTexImage3D: Se,
        texImage2D: H,
        texImage3D: ue,
        updateUBOMapping: $e,
        uniformBlockBinding: yt,
        texStorage2D: ge,
        texStorage3D: Xe,
        texSubImage2D: Ee,
        texSubImage3D: Be,
        compressedTexSubImage2D: tt,
        compressedTexSubImage3D: De,
        scissor: _e,
        viewport: Te,
        reset: Vt
    }
}

function AG(n, e, t, i, r, s, o) {
    const a = r.isWebGL2,
        l = r.maxTextures,
        c = r.maxCubemapSize,
        d = r.maxTextureSize,
        h = r.maxSamples,
        p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
        m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        v = new WeakMap;
    let y;
    const A = new WeakMap;
    let x = !1;
    try {
        x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {}

    function _(O, L) {
        return x ? new OffscreenCanvas(O, L) : Kf("canvas")
    }

    function S(O, L, oe, Se) {
        let Ee = 1;
        if ((O.width > Se || O.height > Se) && (Ee = Se / Math.max(O.width, O.height)), Ee < 1 || L === !0)
            if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap) {
                const Be = L ? Jm : Math.floor,
                    tt = Be(Ee * O.width),
                    De = Be(Ee * O.height);
                y === void 0 && (y = _(tt, De));
                const ge = oe ? _(tt, De) : y;
                return ge.width = tt, ge.height = De, ge.getContext("2d").drawImage(O, 0, 0, tt, De), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + O.width + "x" + O.height + ") to (" + tt + "x" + De + ")."), ge
            } else return "data" in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width + "x" + O.height + ")."), O;
        return O
    }

    function M(O) {
        return cx(O.width) && cx(O.height)
    }

    function b(O) {
        return a ? !1 : O.wrapS !== zn || O.wrapT !== zn || O.minFilter !== fn && O.minFilter !== en
    }

    function B(O, L) {
        return O.generateMipmaps && L && O.minFilter !== fn && O.minFilter !== en
    }

    function R(O) {
        n.generateMipmap(O)
    }

    function E(O, L, oe, Se, Ee = !1) {
        if (a === !1) return L;
        if (O !== null) {
            if (n[O] !== void 0) return n[O];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'")
        }
        let Be = L;
        return L === 6403 && (oe === 5126 && (Be = 33326), oe === 5131 && (Be = 33325), oe === 5121 && (Be = 33321)), L === 33319 && (oe === 5126 && (Be = 33328), oe === 5131 && (Be = 33327), oe === 5121 && (Be = 33323)), L === 6408 && (oe === 5126 && (Be = 34836), oe === 5131 && (Be = 34842), oe === 5121 && (Be = Se === Ct && Ee === !1 ? 35907 : 32856), oe === 32819 && (Be = 32854), oe === 32820 && (Be = 32855)), (Be === 33325 || Be === 33326 || Be === 33327 || Be === 33328 || Be === 34842 || Be === 34836) && e.get("EXT_color_buffer_float"), Be
    }

    function P(O, L, oe) {
        return B(O, oe) === !0 || O.isFramebufferTexture && O.minFilter !== fn && O.minFilter !== en ? Math.log2(Math.max(L.width, L.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? L.mipmaps.length : 1
    }

    function I(O) {
        return O === fn || O === jf || O === _u ? 9728 : 9729
    }

    function z(O) {
        const L = O.target;
        L.removeEventListener("dispose", z), W(L), L.isVideoTexture && v.delete(L)
    }

    function Z(O) {
        const L = O.target;
        L.removeEventListener("dispose", Z), K(L)
    }

    function W(O) {
        const L = i.get(O);
        if (L.__webglInit === void 0) return;
        const oe = O.source,
            Se = A.get(oe);
        if (Se) {
            const Ee = Se[L.__cacheKey];
            Ee.usedTimes--, Ee.usedTimes === 0 && G(O), Object.keys(Se).length === 0 && A.delete(oe)
        }
        i.remove(O)
    }

    function G(O) {
        const L = i.get(O);
        n.deleteTexture(L.__webglTexture);
        const oe = O.source,
            Se = A.get(oe);
        delete Se[L.__cacheKey], o.memory.textures--
    }

    function K(O) {
        const L = O.texture,
            oe = i.get(O),
            Se = i.get(L);
        if (Se.__webglTexture !== void 0 && (n.deleteTexture(Se.__webglTexture), o.memory.textures--), O.depthTexture && O.depthTexture.dispose(), O.isWebGLCubeRenderTarget)
            for (let Ee = 0; Ee < 6; Ee++) n.deleteFramebuffer(oe.__webglFramebuffer[Ee]), oe.__webglDepthbuffer && n.deleteRenderbuffer(oe.__webglDepthbuffer[Ee]);
        else {
            if (n.deleteFramebuffer(oe.__webglFramebuffer), oe.__webglDepthbuffer && n.deleteRenderbuffer(oe.__webglDepthbuffer), oe.__webglMultisampledFramebuffer && n.deleteFramebuffer(oe.__webglMultisampledFramebuffer), oe.__webglColorRenderbuffer)
                for (let Ee = 0; Ee < oe.__webglColorRenderbuffer.length; Ee++) oe.__webglColorRenderbuffer[Ee] && n.deleteRenderbuffer(oe.__webglColorRenderbuffer[Ee]);
            oe.__webglDepthRenderbuffer && n.deleteRenderbuffer(oe.__webglDepthRenderbuffer)
        }
        if (O.isWebGLMultipleRenderTargets)
            for (let Ee = 0, Be = L.length; Ee < Be; Ee++) {
                const tt = i.get(L[Ee]);
                tt.__webglTexture && (n.deleteTexture(tt.__webglTexture), o.memory.textures--), i.remove(L[Ee])
            }
        i.remove(L), i.remove(O)
    }
    let te = 0;

    function se() {
        te = 0
    }

    function k() {
        const O = te;
        return O >= l && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + l), te += 1, O
    }

    function V(O) {
        const L = [];
        return L.push(O.wrapS), L.push(O.wrapT), L.push(O.wrapR || 0), L.push(O.magFilter), L.push(O.minFilter), L.push(O.anisotropy), L.push(O.internalFormat), L.push(O.format), L.push(O.type), L.push(O.generateMipmaps), L.push(O.premultiplyAlpha), L.push(O.flipY), L.push(O.unpackAlignment), L.push(O.encoding), L.join()
    }

    function J(O, L) {
        const oe = i.get(O);
        if (O.isVideoTexture && vt(O), O.isRenderTargetTexture === !1 && O.version > 0 && oe.__version !== O.version) {
            const Se = O.image;
            if (Se === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Se.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                Oe(oe, O, L);
                return
            }
        }
        t.bindTexture(3553, oe.__webglTexture, 33984 + L)
    }

    function ie(O, L) {
        const oe = i.get(O);
        if (O.version > 0 && oe.__version !== O.version) {
            Oe(oe, O, L);
            return
        }
        t.bindTexture(35866, oe.__webglTexture, 33984 + L)
    }

    function j(O, L) {
        const oe = i.get(O);
        if (O.version > 0 && oe.__version !== O.version) {
            Oe(oe, O, L);
            return
        }
        t.bindTexture(32879, oe.__webglTexture, 33984 + L)
    }

    function re(O, L) {
        const oe = i.get(O);
        if (O.version > 0 && oe.__version !== O.version) {
            He(oe, O, L);
            return
        }
        t.bindTexture(34067, oe.__webglTexture, 33984 + L)
    }
    const ve = {
            [Ho]: 10497,
            [zn]: 33071,
            [Ru]: 33648
        },
        xe = {
            [fn]: 9728,
            [jf]: 9984,
            [_u]: 9986,
            [en]: 9729,
            [bg]: 9985,
            [ss]: 9987
        };

    function q(O, L, oe) {
        if (oe ? (n.texParameteri(O, 10242, ve[L.wrapS]), n.texParameteri(O, 10243, ve[L.wrapT]), (O === 32879 || O === 35866) && n.texParameteri(O, 32882, ve[L.wrapR]), n.texParameteri(O, 10240, xe[L.magFilter]), n.texParameteri(O, 10241, xe[L.minFilter])) : (n.texParameteri(O, 10242, 33071), n.texParameteri(O, 10243, 33071), (O === 32879 || O === 35866) && n.texParameteri(O, 32882, 33071), (L.wrapS !== zn || L.wrapT !== zn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(O, 10240, I(L.magFilter)), n.texParameteri(O, 10241, I(L.minFilter)), L.minFilter !== fn && L.minFilter !== en && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
            const Se = e.get("EXT_texture_filter_anisotropic");
            if (L.magFilter === fn || L.minFilter !== _u && L.minFilter !== ss || L.type === Rs && e.has("OES_texture_float_linear") === !1 || a === !1 && L.type === Iu && e.has("OES_texture_half_float_linear") === !1) return;
            (L.anisotropy > 1 || i.get(L).__currentAnisotropy) && (n.texParameterf(O, Se.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, r.getMaxAnisotropy())), i.get(L).__currentAnisotropy = L.anisotropy)
        }
    }

    function Ne(O, L) {
        let oe = !1;
        O.__webglInit === void 0 && (O.__webglInit = !0, L.addEventListener("dispose", z));
        const Se = L.source;
        let Ee = A.get(Se);
        Ee === void 0 && (Ee = {}, A.set(Se, Ee));
        const Be = V(L);
        if (Be !== O.__cacheKey) {
            Ee[Be] === void 0 && (Ee[Be] = {
                texture: n.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, oe = !0), Ee[Be].usedTimes++;
            const tt = Ee[O.__cacheKey];
            tt !== void 0 && (Ee[O.__cacheKey].usedTimes--, tt.usedTimes === 0 && G(L)), O.__cacheKey = Be, O.__webglTexture = Ee[Be].texture
        }
        return oe
    }

    function Oe(O, L, oe) {
        let Se = 3553;
        (L.isDataArrayTexture || L.isCompressedArrayTexture) && (Se = 35866), L.isData3DTexture && (Se = 32879);
        const Ee = Ne(O, L),
            Be = L.source;
        t.bindTexture(Se, O.__webglTexture, 33984 + oe);
        const tt = i.get(Be);
        if (Be.version !== tt.__version || Ee === !0) {
            t.activeTexture(33984 + oe), n.pixelStorei(37440, L.flipY), n.pixelStorei(37441, L.premultiplyAlpha), n.pixelStorei(3317, L.unpackAlignment), n.pixelStorei(37443, 0);
            const De = b(L) && M(L.image) === !1;
            let ge = S(L.image, De, !1, d);
            ge = St(L, ge);
            const Xe = M(ge) || a,
                H = s.convert(L.format, L.encoding);
            let ue = s.convert(L.type),
                _e = E(L.internalFormat, H, ue, L.encoding, L.isVideoTexture);
            q(Se, L, Xe);
            let Te;
            const $e = L.mipmaps,
                yt = a && L.isVideoTexture !== !0,
                Vt = tt.__version === void 0 || Ee === !0,
                Q = P(L, ge, Xe);
            if (L.isDepthTexture) _e = 6402, a ? L.type === Rs ? _e = 36012 : L.type === Mo ? _e = 33190 : L.type === ja ? _e = 35056 : _e = 33189 : L.type === Rs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), L.format === ko && _e === 6402 && L.type !== Y1 && L.type !== Mo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), L.type = Mo, ue = s.convert(L.type)), L.format === nl && _e === 6402 && (_e = 34041, L.type !== ja && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), L.type = ja, ue = s.convert(L.type))), Vt && (yt ? t.texStorage2D(3553, 1, _e, ge.width, ge.height) : t.texImage2D(3553, 0, _e, ge.width, ge.height, 0, H, ue, null));
            else if (L.isDataTexture)
                if ($e.length > 0 && Xe) {
                    yt && Vt && t.texStorage2D(3553, Q, _e, $e[0].width, $e[0].height);
                    for (let fe = 0, Ae = $e.length; fe < Ae; fe++) Te = $e[fe], yt ? t.texSubImage2D(3553, fe, 0, 0, Te.width, Te.height, H, ue, Te.data) : t.texImage2D(3553, fe, _e, Te.width, Te.height, 0, H, ue, Te.data);
                    L.generateMipmaps = !1
                } else yt ? (Vt && t.texStorage2D(3553, Q, _e, ge.width, ge.height), t.texSubImage2D(3553, 0, 0, 0, ge.width, ge.height, H, ue, ge.data)) : t.texImage2D(3553, 0, _e, ge.width, ge.height, 0, H, ue, ge.data);
            else if (L.isCompressedTexture)
                if (L.isCompressedArrayTexture) {
                    yt && Vt && t.texStorage3D(35866, Q, _e, $e[0].width, $e[0].height, ge.depth);
                    for (let fe = 0, Ae = $e.length; fe < Ae; fe++) Te = $e[fe], L.format !== xi ? H !== null ? yt ? t.compressedTexSubImage3D(35866, fe, 0, 0, 0, Te.width, Te.height, ge.depth, H, Te.data, 0, 0) : t.compressedTexImage3D(35866, fe, _e, Te.width, Te.height, ge.depth, 0, Te.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt ? t.texSubImage3D(35866, fe, 0, 0, 0, Te.width, Te.height, ge.depth, H, ue, Te.data) : t.texImage3D(35866, fe, _e, Te.width, Te.height, ge.depth, 0, H, ue, Te.data)
                } else {
                    yt && Vt && t.texStorage2D(3553, Q, _e, $e[0].width, $e[0].height);
                    for (let fe = 0, Ae = $e.length; fe < Ae; fe++) Te = $e[fe], L.format !== xi ? H !== null ? yt ? t.compressedTexSubImage2D(3553, fe, 0, 0, Te.width, Te.height, H, Te.data) : t.compressedTexImage2D(3553, fe, _e, Te.width, Te.height, 0, Te.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt ? t.texSubImage2D(3553, fe, 0, 0, Te.width, Te.height, H, ue, Te.data) : t.texImage2D(3553, fe, _e, Te.width, Te.height, 0, H, ue, Te.data)
                }
            else if (L.isDataArrayTexture) yt ? (Vt && t.texStorage3D(35866, Q, _e, ge.width, ge.height, ge.depth), t.texSubImage3D(35866, 0, 0, 0, 0, ge.width, ge.height, ge.depth, H, ue, ge.data)) : t.texImage3D(35866, 0, _e, ge.width, ge.height, ge.depth, 0, H, ue, ge.data);
            else if (L.isData3DTexture) yt ? (Vt && t.texStorage3D(32879, Q, _e, ge.width, ge.height, ge.depth), t.texSubImage3D(32879, 0, 0, 0, 0, ge.width, ge.height, ge.depth, H, ue, ge.data)) : t.texImage3D(32879, 0, _e, ge.width, ge.height, ge.depth, 0, H, ue, ge.data);
            else if (L.isFramebufferTexture) {
                if (Vt)
                    if (yt) t.texStorage2D(3553, Q, _e, ge.width, ge.height);
                    else {
                        let fe = ge.width,
                            Ae = ge.height;
                        for (let Ue = 0; Ue < Q; Ue++) t.texImage2D(3553, Ue, _e, fe, Ae, 0, H, ue, null), fe >>= 1, Ae >>= 1
                    }
            } else if ($e.length > 0 && Xe) {
                yt && Vt && t.texStorage2D(3553, Q, _e, $e[0].width, $e[0].height);
                for (let fe = 0, Ae = $e.length; fe < Ae; fe++) Te = $e[fe], yt ? t.texSubImage2D(3553, fe, 0, 0, H, ue, Te) : t.texImage2D(3553, fe, _e, H, ue, Te);
                L.generateMipmaps = !1
            } else yt ? (Vt && t.texStorage2D(3553, Q, _e, ge.width, ge.height), t.texSubImage2D(3553, 0, 0, 0, H, ue, ge)) : t.texImage2D(3553, 0, _e, H, ue, ge);
            B(L, Xe) && R(Se), tt.__version = Be.version, L.onUpdate && L.onUpdate(L)
        }
        O.__version = L.version
    }

    function He(O, L, oe) {
        if (L.image.length !== 6) return;
        const Se = Ne(O, L),
            Ee = L.source;
        t.bindTexture(34067, O.__webglTexture, 33984 + oe);
        const Be = i.get(Ee);
        if (Ee.version !== Be.__version || Se === !0) {
            t.activeTexture(33984 + oe), n.pixelStorei(37440, L.flipY), n.pixelStorei(37441, L.premultiplyAlpha), n.pixelStorei(3317, L.unpackAlignment), n.pixelStorei(37443, 0);
            const tt = L.isCompressedTexture || L.image[0].isCompressedTexture,
                De = L.image[0] && L.image[0].isDataTexture,
                ge = [];
            for (let fe = 0; fe < 6; fe++) !tt && !De ? ge[fe] = S(L.image[fe], !1, !0, c) : ge[fe] = De ? L.image[fe].image : L.image[fe], ge[fe] = St(L, ge[fe]);
            const Xe = ge[0],
                H = M(Xe) || a,
                ue = s.convert(L.format, L.encoding),
                _e = s.convert(L.type),
                Te = E(L.internalFormat, ue, _e, L.encoding),
                $e = a && L.isVideoTexture !== !0,
                yt = Be.__version === void 0 || Se === !0;
            let Vt = P(L, Xe, H);
            q(34067, L, H);
            let Q;
            if (tt) {
                $e && yt && t.texStorage2D(34067, Vt, Te, Xe.width, Xe.height);
                for (let fe = 0; fe < 6; fe++) {
                    Q = ge[fe].mipmaps;
                    for (let Ae = 0; Ae < Q.length; Ae++) {
                        const Ue = Q[Ae];
                        L.format !== xi ? ue !== null ? $e ? t.compressedTexSubImage2D(34069 + fe, Ae, 0, 0, Ue.width, Ue.height, ue, Ue.data) : t.compressedTexImage2D(34069 + fe, Ae, Te, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : $e ? t.texSubImage2D(34069 + fe, Ae, 0, 0, Ue.width, Ue.height, ue, _e, Ue.data) : t.texImage2D(34069 + fe, Ae, Te, Ue.width, Ue.height, 0, ue, _e, Ue.data)
                    }
                }
            } else {
                Q = L.mipmaps, $e && yt && (Q.length > 0 && Vt++, t.texStorage2D(34067, Vt, Te, ge[0].width, ge[0].height));
                for (let fe = 0; fe < 6; fe++)
                    if (De) {
                        $e ? t.texSubImage2D(34069 + fe, 0, 0, 0, ge[fe].width, ge[fe].height, ue, _e, ge[fe].data) : t.texImage2D(34069 + fe, 0, Te, ge[fe].width, ge[fe].height, 0, ue, _e, ge[fe].data);
                        for (let Ae = 0; Ae < Q.length; Ae++) {
                            const Ke = Q[Ae].image[fe].image;
                            $e ? t.texSubImage2D(34069 + fe, Ae + 1, 0, 0, Ke.width, Ke.height, ue, _e, Ke.data) : t.texImage2D(34069 + fe, Ae + 1, Te, Ke.width, Ke.height, 0, ue, _e, Ke.data)
                        }
                    } else {
                        $e ? t.texSubImage2D(34069 + fe, 0, 0, 0, ue, _e, ge[fe]) : t.texImage2D(34069 + fe, 0, Te, ue, _e, ge[fe]);
                        for (let Ae = 0; Ae < Q.length; Ae++) {
                            const Ue = Q[Ae];
                            $e ? t.texSubImage2D(34069 + fe, Ae + 1, 0, 0, ue, _e, Ue.image[fe]) : t.texImage2D(34069 + fe, Ae + 1, Te, ue, _e, Ue.image[fe])
                        }
                    }
            }
            B(L, H) && R(34067), Be.__version = Ee.version, L.onUpdate && L.onUpdate(L)
        }
        O.__version = L.version
    }

    function we(O, L, oe, Se, Ee) {
        const Be = s.convert(oe.format, oe.encoding),
            tt = s.convert(oe.type),
            De = E(oe.internalFormat, Be, tt, oe.encoding);
        i.get(L).__hasExternalTextures || (Ee === 32879 || Ee === 35866 ? t.texImage3D(Ee, 0, De, L.width, L.height, L.depth, 0, Be, tt, null) : t.texImage2D(Ee, 0, De, L.width, L.height, 0, Be, tt, null)), t.bindFramebuffer(36160, O), je(L) ? p.framebufferTexture2DMultisampleEXT(36160, Se, Ee, i.get(oe).__webglTexture, 0, Je(L)) : (Ee === 3553 || Ee >= 34069 && Ee <= 34074) && n.framebufferTexture2D(36160, Se, Ee, i.get(oe).__webglTexture, 0), t.bindFramebuffer(36160, null)
    }

    function Le(O, L, oe) {
        if (n.bindRenderbuffer(36161, O), L.depthBuffer && !L.stencilBuffer) {
            let Se = 33189;
            if (oe || je(L)) {
                const Ee = L.depthTexture;
                Ee && Ee.isDepthTexture && (Ee.type === Rs ? Se = 36012 : Ee.type === Mo && (Se = 33190));
                const Be = Je(L);
                je(L) ? p.renderbufferStorageMultisampleEXT(36161, Be, Se, L.width, L.height) : n.renderbufferStorageMultisample(36161, Be, Se, L.width, L.height)
            } else n.renderbufferStorage(36161, Se, L.width, L.height);
            n.framebufferRenderbuffer(36160, 36096, 36161, O)
        } else if (L.depthBuffer && L.stencilBuffer) {
            const Se = Je(L);
            oe && je(L) === !1 ? n.renderbufferStorageMultisample(36161, Se, 35056, L.width, L.height) : je(L) ? p.renderbufferStorageMultisampleEXT(36161, Se, 35056, L.width, L.height) : n.renderbufferStorage(36161, 34041, L.width, L.height), n.framebufferRenderbuffer(36160, 33306, 36161, O)
        } else {
            const Se = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
            for (let Ee = 0; Ee < Se.length; Ee++) {
                const Be = Se[Ee],
                    tt = s.convert(Be.format, Be.encoding),
                    De = s.convert(Be.type),
                    ge = E(Be.internalFormat, tt, De, Be.encoding),
                    Xe = Je(L);
                oe && je(L) === !1 ? n.renderbufferStorageMultisample(36161, Xe, ge, L.width, L.height) : je(L) ? p.renderbufferStorageMultisampleEXT(36161, Xe, ge, L.width, L.height) : n.renderbufferStorage(36161, ge, L.width, L.height)
            }
        }
        n.bindRenderbuffer(36161, null)
    }

    function he(O, L) {
        if (L && L.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, O), !(L.depthTexture && L.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width, L.depthTexture.image.height = L.height, L.depthTexture.needsUpdate = !0), J(L.depthTexture, 0);
        const Se = i.get(L.depthTexture).__webglTexture,
            Ee = Je(L);
        if (L.depthTexture.format === ko) je(L) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Se, 0, Ee) : n.framebufferTexture2D(36160, 36096, 3553, Se, 0);
        else if (L.depthTexture.format === nl) je(L) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Se, 0, Ee) : n.framebufferTexture2D(36160, 33306, 3553, Se, 0);
        else throw new Error("Unknown depthTexture format")
    }

    function ae(O) {
        const L = i.get(O),
            oe = O.isWebGLCubeRenderTarget === !0;
        if (O.depthTexture && !L.__autoAllocateDepthBuffer) {
            if (oe) throw new Error("target.depthTexture not supported in Cube render targets");
            he(L.__webglFramebuffer, O)
        } else if (oe) {
            L.__webglDepthbuffer = [];
            for (let Se = 0; Se < 6; Se++) t.bindFramebuffer(36160, L.__webglFramebuffer[Se]), L.__webglDepthbuffer[Se] = n.createRenderbuffer(), Le(L.__webglDepthbuffer[Se], O, !1)
        } else t.bindFramebuffer(36160, L.__webglFramebuffer), L.__webglDepthbuffer = n.createRenderbuffer(), Le(L.__webglDepthbuffer, O, !1);
        t.bindFramebuffer(36160, null)
    }

    function Ce(O, L, oe) {
        const Se = i.get(O);
        L !== void 0 && we(Se.__webglFramebuffer, O, O.texture, 36064, 3553), oe !== void 0 && ae(O)
    }

    function ze(O) {
        const L = O.texture,
            oe = i.get(O),
            Se = i.get(L);
        O.addEventListener("dispose", Z), O.isWebGLMultipleRenderTargets !== !0 && (Se.__webglTexture === void 0 && (Se.__webglTexture = n.createTexture()), Se.__version = L.version, o.memory.textures++);
        const Ee = O.isWebGLCubeRenderTarget === !0,
            Be = O.isWebGLMultipleRenderTargets === !0,
            tt = M(O) || a;
        if (Ee) {
            oe.__webglFramebuffer = [];
            for (let De = 0; De < 6; De++) oe.__webglFramebuffer[De] = n.createFramebuffer()
        } else {
            if (oe.__webglFramebuffer = n.createFramebuffer(), Be)
                if (r.drawBuffers) {
                    const De = O.texture;
                    for (let ge = 0, Xe = De.length; ge < Xe; ge++) {
                        const H = i.get(De[ge]);
                        H.__webglTexture === void 0 && (H.__webglTexture = n.createTexture(), o.memory.textures++)
                    }
                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (a && O.samples > 0 && je(O) === !1) {
                const De = Be ? L : [L];
                oe.__webglMultisampledFramebuffer = n.createFramebuffer(), oe.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, oe.__webglMultisampledFramebuffer);
                for (let ge = 0; ge < De.length; ge++) {
                    const Xe = De[ge];
                    oe.__webglColorRenderbuffer[ge] = n.createRenderbuffer(), n.bindRenderbuffer(36161, oe.__webglColorRenderbuffer[ge]);
                    const H = s.convert(Xe.format, Xe.encoding),
                        ue = s.convert(Xe.type),
                        _e = E(Xe.internalFormat, H, ue, Xe.encoding, O.isXRRenderTarget === !0),
                        Te = Je(O);
                    n.renderbufferStorageMultisample(36161, Te, _e, O.width, O.height), n.framebufferRenderbuffer(36160, 36064 + ge, 36161, oe.__webglColorRenderbuffer[ge])
                }
                n.bindRenderbuffer(36161, null), O.depthBuffer && (oe.__webglDepthRenderbuffer = n.createRenderbuffer(), Le(oe.__webglDepthRenderbuffer, O, !0)), t.bindFramebuffer(36160, null)
            }
        }
        if (Ee) {
            t.bindTexture(34067, Se.__webglTexture), q(34067, L, tt);
            for (let De = 0; De < 6; De++) we(oe.__webglFramebuffer[De], O, L, 36064, 34069 + De);
            B(L, tt) && R(34067), t.unbindTexture()
        } else if (Be) {
            const De = O.texture;
            for (let ge = 0, Xe = De.length; ge < Xe; ge++) {
                const H = De[ge],
                    ue = i.get(H);
                t.bindTexture(3553, ue.__webglTexture), q(3553, H, tt), we(oe.__webglFramebuffer, O, H, 36064 + ge, 3553), B(H, tt) && R(3553)
            }
            t.unbindTexture()
        } else {
            let De = 3553;
            (O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (a ? De = O.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(De, Se.__webglTexture), q(De, L, tt), we(oe.__webglFramebuffer, O, L, 36064, De), B(L, tt) && R(De), t.unbindTexture()
        }
        O.depthBuffer && ae(O)
    }

    function Pe(O) {
        const L = M(O) || a,
            oe = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
        for (let Se = 0, Ee = oe.length; Se < Ee; Se++) {
            const Be = oe[Se];
            if (B(Be, L)) {
                const tt = O.isWebGLCubeRenderTarget ? 34067 : 3553,
                    De = i.get(Be).__webglTexture;
                t.bindTexture(tt, De), R(tt), t.unbindTexture()
            }
        }
    }

    function Ze(O) {
        if (a && O.samples > 0 && je(O) === !1) {
            const L = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture],
                oe = O.width,
                Se = O.height;
            let Ee = 16384;
            const Be = [],
                tt = O.stencilBuffer ? 33306 : 36096,
                De = i.get(O),
                ge = O.isWebGLMultipleRenderTargets === !0;
            if (ge)
                for (let Xe = 0; Xe < L.length; Xe++) t.bindFramebuffer(36160, De.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + Xe, 36161, null), t.bindFramebuffer(36160, De.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + Xe, 3553, null, 0);
            t.bindFramebuffer(36008, De.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, De.__webglFramebuffer);
            for (let Xe = 0; Xe < L.length; Xe++) {
                Be.push(36064 + Xe), O.depthBuffer && Be.push(tt);
                const H = De.__ignoreDepthValues !== void 0 ? De.__ignoreDepthValues : !1;
                if (H === !1 && (O.depthBuffer && (Ee |= 256), O.stencilBuffer && (Ee |= 1024)), ge && n.framebufferRenderbuffer(36008, 36064, 36161, De.__webglColorRenderbuffer[Xe]), H === !0 && (n.invalidateFramebuffer(36008, [tt]), n.invalidateFramebuffer(36009, [tt])), ge) {
                    const ue = i.get(L[Xe]).__webglTexture;
                    n.framebufferTexture2D(36009, 36064, 3553, ue, 0)
                }
                n.blitFramebuffer(0, 0, oe, Se, 0, 0, oe, Se, Ee, 9728), m && n.invalidateFramebuffer(36008, Be)
            }
            if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), ge)
                for (let Xe = 0; Xe < L.length; Xe++) {
                    t.bindFramebuffer(36160, De.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + Xe, 36161, De.__webglColorRenderbuffer[Xe]);
                    const H = i.get(L[Xe]).__webglTexture;
                    t.bindFramebuffer(36160, De.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + Xe, 3553, H, 0)
                }
            t.bindFramebuffer(36009, De.__webglMultisampledFramebuffer)
        }
    }

    function Je(O) {
        return Math.min(h, O.samples)
    }

    function je(O) {
        const L = i.get(O);
        return a && O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1
    }

    function vt(O) {
        const L = o.render.frame;
        v.get(O) !== L && (v.set(O, L), O.update())
    }

    function St(O, L) {
        const oe = O.encoding,
            Se = O.format,
            Ee = O.type;
        return O.isCompressedTexture === !0 || O.isVideoTexture === !0 || O.format === jm || oe !== Ws && (oe === Ct ? a === !1 ? e.has("EXT_sRGB") === !0 && Se === xi ? (O.format = jm, O.minFilter = en, O.generateMipmaps = !1) : L = t_.sRGBToLinear(L) : (Se !== xi || Ee !== Vs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", oe)), L
    }
    this.allocateTextureUnit = k, this.resetTextureUnits = se, this.setTexture2D = J, this.setTexture2DArray = ie, this.setTexture3D = j, this.setTextureCube = re, this.rebindTextures = Ce, this.setupRenderTarget = ze, this.updateRenderTargetMipmap = Pe, this.updateMultisampleRenderTarget = Ze, this.setupDepthRenderbuffer = ae, this.setupFrameBufferTexture = we, this.useMultisampledRTT = je
}

function jP(n, e, t) {
    const i = t.isWebGL2;

    function r(s, o = null) {
        let a;
        if (s === Vs) return 5121;
        if (s === mP) return 32819;
        if (s === gP) return 32820;
        if (s === dP) return 5120;
        if (s === hP) return 5122;
        if (s === Y1) return 5123;
        if (s === pP) return 5124;
        if (s === Mo) return 5125;
        if (s === Rs) return 5126;
        if (s === Iu) return i ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
        if (s === yP) return 6406;
        if (s === xi) return 6408;
        if (s === vP) return 6409;
        if (s === AP) return 6410;
        if (s === ko) return 6402;
        if (s === nl) return 34041;
        if (s === jm) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
        if (s === xP) return 6403;
        if (s === _P) return 36244;
        if (s === wP) return 33319;
        if (s === SP) return 33320;
        if (s === MP) return 36249;
        if (s === sm || s === om || s === am || s === lm)
            if (o === Ct)
                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
                    if (s === sm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (s === om) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (s === am) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (s === lm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else return null;
        else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
            if (s === sm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (s === om) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (s === am) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (s === lm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null;
        if (s === zA || s === GA || s === HA || s === VA)
            if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
                if (s === zA) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === GA) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === HA) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === VA) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
        if (s === CP) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (s === WA || s === jA)
            if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
                if (s === WA) return o === Ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                if (s === jA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
        if (s === JA || s === XA || s === QA || s === KA || s === YA || s === ZA || s === qA || s === $A || s === ex || s === tx || s === nx || s === ix || s === rx || s === sx)
            if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
                if (s === JA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (s === XA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (s === QA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (s === KA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (s === YA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (s === ZA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (s === qA) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (s === $A) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (s === ex) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (s === tx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (s === nx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (s === ix) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (s === rx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (s === sx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
        if (s === um)
            if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
                if (s === um) return o === Ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else return null;
        if (s === EP || s === ox || s === ax || s === lx)
            if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
                if (s === um) return a.COMPRESSED_RED_RGTC1_EXT;
                if (s === ox) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (s === ax) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (s === lx) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
        return s === ja ? i ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null
    }
    return {
        convert: r
    }
}
class JP extends Gt {
    constructor(e = []) {
        super(), this.isArrayCamera = !0, this.cameras = e
    }
}
class Ls extends Tt {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
}
const xG = {
    type: "move"
};
class $y {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Ls, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Ls, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new D, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new D), this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Ls, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new D, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new D), this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values()) this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }), this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(e, t, i) {
        let r = null,
            s = null,
            o = null;
        const a = this._targetRay,
            l = this._grip,
            c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const y of e.hand.values()) {
                    const A = t.getJointPose(y, i),
                        x = this._getHandJoint(c, y);
                    A !== null && (x.matrix.fromArray(A.transform.matrix), x.matrix.decompose(x.position, x.rotation, x.scale), x.jointRadius = A.radius), x.visible = A !== null
                }
                const d = c.joints["index-finger-tip"],
                    h = c.joints["thumb-tip"],
                    p = d.position.distanceTo(h.position),
                    m = .02,
                    v = .005;
                c.inputState.pinching && p > m + v ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && p <= m - v && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(xG)))
        }
        return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new Ls;
            i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i)
        }
        return e.joints[t.jointName]
    }
}
class XP extends Yt {
    constructor(e, t, i, r, s, o, a, l, c, d) {
        if (d = d !== void 0 ? d : ko, d !== ko && d !== nl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && d === ko && (i = Mo), i === void 0 && d === nl && (i = ja), super(null, r, s, o, a, l, d, i, c), this.isDepthTexture = !0, this.image = {
            width: e,
            height: t
        }, this.magFilter = a !== void 0 ? a : fn, this.minFilter = l !== void 0 ? l : fn, this.flipY = !1, this.generateMipmaps = !1
    }
}
class _G extends as {
    constructor(e, t) {
        super();
        const i = this;
        let r = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            d = null,
            h = null,
            p = null,
            m = null,
            v = null;
        const y = t.getContextAttributes();
        let A = null,
            x = null;
        const _ = [],
            S = [],
            M = new Set,
            b = new Map,
            B = new Gt;
        B.layers.enable(1), B.viewport = new kt;
        const R = new Gt;
        R.layers.enable(2), R.viewport = new kt;
        const E = [B, R],
            P = new JP;
        P.layers.enable(1), P.layers.enable(2);
        let I = null,
            z = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(j) {
            let re = _[j];
            return re === void 0 && (re = new $y, _[j] = re), re.getTargetRaySpace()
        }, this.getControllerGrip = function(j) {
            let re = _[j];
            return re === void 0 && (re = new $y, _[j] = re), re.getGripSpace()
        }, this.getHand = function(j) {
            let re = _[j];
            return re === void 0 && (re = new $y, _[j] = re), re.getHandSpace()
        };

        function Z(j) {
            const re = S.indexOf(j.inputSource);
            if (re === -1) return;
            const ve = _[re];
            ve !== void 0 && ve.dispatchEvent({
                type: j.type,
                data: j.inputSource
            })
        }

        function W() {
            r.removeEventListener("select", Z), r.removeEventListener("selectstart", Z), r.removeEventListener("selectend", Z), r.removeEventListener("squeeze", Z), r.removeEventListener("squeezestart", Z), r.removeEventListener("squeezeend", Z), r.removeEventListener("end", W), r.removeEventListener("inputsourceschange", G);
            for (let j = 0; j < _.length; j++) {
                const re = S[j];
                re !== null && (S[j] = null, _[j].disconnect(re))
            }
            I = null, z = null, e.setRenderTarget(A), m = null, p = null, h = null, r = null, x = null, ie.stop(), i.isPresenting = !1, i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(j) {
            s = j, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(j) {
            a = j, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return c || o
        }, this.setReferenceSpace = function(j) {
            c = j
        }, this.getBaseLayer = function() {
            return p !== null ? p : m
        }, this.getBinding = function() {
            return h
        }, this.getFrame = function() {
            return v
        }, this.getSession = function() {
            return r
        }, this.setSession = async function(j) {
            if (r = j, r !== null) {
                if (A = e.getRenderTarget(), r.addEventListener("select", Z), r.addEventListener("selectstart", Z), r.addEventListener("selectend", Z), r.addEventListener("squeeze", Z), r.addEventListener("squeezestart", Z), r.addEventListener("squeezeend", Z), r.addEventListener("end", W), r.addEventListener("inputsourceschange", G), y.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    const re = {
                        antialias: r.renderState.layers === void 0 ? y.antialias : !0,
                        alpha: y.alpha,
                        depth: y.depth,
                        stencil: y.stencil,
                        framebufferScaleFactor: s
                    };
                    m = new XRWebGLLayer(r, t, re), r.updateRenderState({
                        baseLayer: m
                    }), x = new Nr(m.framebufferWidth, m.framebufferHeight, {
                        format: xi,
                        type: Vs,
                        encoding: e.outputEncoding,
                        stencilBuffer: y.stencil
                    })
                } else {
                    let re = null,
                        ve = null,
                        xe = null;
                    y.depth && (xe = y.stencil ? 35056 : 33190, re = y.stencil ? nl : ko, ve = y.stencil ? ja : Mo);
                    const q = {
                        colorFormat: 32856,
                        depthFormat: xe,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r, t), p = h.createProjectionLayer(q), r.updateRenderState({
                        layers: [p]
                    }), x = new Nr(p.textureWidth, p.textureHeight, {
                        format: xi,
                        type: Vs,
                        depthTexture: new XP(p.textureWidth, p.textureHeight, ve, void 0, void 0, void 0, void 0, void 0, void 0, re),
                        stencilBuffer: y.stencil,
                        encoding: e.outputEncoding,
                        samples: y.antialias ? 4 : 0
                    });
                    const Ne = e.properties.get(x);
                    Ne.__ignoreDepthValues = p.ignoreDepthValues
                }
                x.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await r.requestReferenceSpace(a), ie.setContext(r), ie.start(), i.isPresenting = !0, i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        };

        function G(j) {
            for (let re = 0; re < j.removed.length; re++) {
                const ve = j.removed[re],
                    xe = S.indexOf(ve);
                xe >= 0 && (S[xe] = null, _[xe].disconnect(ve))
            }
            for (let re = 0; re < j.added.length; re++) {
                const ve = j.added[re];
                let xe = S.indexOf(ve);
                if (xe === -1) {
                    for (let Ne = 0; Ne < _.length; Ne++)
                        if (Ne >= S.length) {
                            S.push(ve), xe = Ne;
                            break
                        } else if (S[Ne] === null) {
                        S[Ne] = ve, xe = Ne;
                        break
                    }
                    if (xe === -1) break
                }
                const q = _[xe];
                q && q.connect(ve)
            }
        }
        const K = new D,
            te = new D;

        function se(j, re, ve) {
            K.setFromMatrixPosition(re.matrixWorld), te.setFromMatrixPosition(ve.matrixWorld);
            const xe = K.distanceTo(te),
                q = re.projectionMatrix.elements,
                Ne = ve.projectionMatrix.elements,
                Oe = q[14] / (q[10] - 1),
                He = q[14] / (q[10] + 1),
                we = (q[9] + 1) / q[5],
                Le = (q[9] - 1) / q[5],
                he = (q[8] - 1) / q[0],
                ae = (Ne[8] + 1) / Ne[0],
                Ce = Oe * he,
                ze = Oe * ae,
                Pe = xe / (-he + ae),
                Ze = Pe * -he;
            re.matrixWorld.decompose(j.position, j.quaternion, j.scale), j.translateX(Ze), j.translateZ(Pe), j.matrixWorld.compose(j.position, j.quaternion, j.scale), j.matrixWorldInverse.copy(j.matrixWorld).invert();
            const Je = Oe + Pe,
                je = He + Pe,
                vt = Ce - Ze,
                St = ze + (xe - Ze),
                O = we * He / je * Je,
                L = Le * He / je * Je;
            j.projectionMatrix.makePerspective(vt, St, O, L, Je, je)
        }

        function k(j, re) {
            re === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(re.matrixWorld, j.matrix), j.matrixWorldInverse.copy(j.matrixWorld).invert()
        }
        this.updateCamera = function(j) {
            if (r === null) return;
            P.near = R.near = B.near = j.near, P.far = R.far = B.far = j.far, (I !== P.near || z !== P.far) && (r.updateRenderState({
                depthNear: P.near,
                depthFar: P.far
            }), I = P.near, z = P.far);
            const re = j.parent,
                ve = P.cameras;
            k(P, re);
            for (let q = 0; q < ve.length; q++) k(ve[q], re);
            P.matrixWorld.decompose(P.position, P.quaternion, P.scale), j.matrix.copy(P.matrix), j.matrix.decompose(j.position, j.quaternion, j.scale);
            const xe = j.children;
            for (let q = 0, Ne = xe.length; q < Ne; q++) xe[q].updateMatrixWorld(!0);
            ve.length === 2 ? se(P, B, R) : P.projectionMatrix.copy(B.projectionMatrix)
        }, this.getCamera = function() {
            return P
        }, this.getFoveation = function() {
            if (!(p === null && m === null)) return l
        }, this.setFoveation = function(j) {
            l = j, p !== null && (p.fixedFoveation = j), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = j)
        }, this.getPlanes = function() {
            return M
        };
        let V = null;

        function J(j, re) {
            if (d = re.getViewerPose(c || o), v = re, d !== null) {
                const ve = d.views;
                m !== null && (e.setRenderTargetFramebuffer(x, m.framebuffer), e.setRenderTarget(x));
                let xe = !1;
                ve.length !== P.cameras.length && (P.cameras.length = 0, xe = !0);
                for (let q = 0; q < ve.length; q++) {
                    const Ne = ve[q];
                    let Oe = null;
                    if (m !== null) Oe = m.getViewport(Ne);
                    else {
                        const we = h.getViewSubImage(p, Ne);
                        Oe = we.viewport, q === 0 && (e.setRenderTargetTextures(x, we.colorTexture, p.ignoreDepthValues ? void 0 : we.depthStencilTexture), e.setRenderTarget(x))
                    }
                    let He = E[q];
                    He === void 0 && (He = new Gt, He.layers.enable(q), He.viewport = new kt, E[q] = He), He.matrix.fromArray(Ne.transform.matrix), He.projectionMatrix.fromArray(Ne.projectionMatrix), He.viewport.set(Oe.x, Oe.y, Oe.width, Oe.height), q === 0 && P.matrix.copy(He.matrix), xe === !0 && P.cameras.push(He)
                }
            }
            for (let ve = 0; ve < _.length; ve++) {
                const xe = S[ve],
                    q = _[ve];
                xe !== null && q !== void 0 && q.update(xe, re, c || o)
            }
            if (V && V(j, re), re.detectedPlanes) {
                i.dispatchEvent({
                    type: "planesdetected",
                    data: re.detectedPlanes
                });
                let ve = null;
                for (const xe of M) re.detectedPlanes.has(xe) || (ve === null && (ve = []), ve.push(xe));
                if (ve !== null)
                    for (const xe of ve) M.delete(xe), b.delete(xe), i.dispatchEvent({
                        type: "planeremoved",
                        data: xe
                    });
                for (const xe of re.detectedPlanes)
                    if (!M.has(xe)) M.add(xe), b.set(xe, re.lastChangedTime), i.dispatchEvent({
                        type: "planeadded",
                        data: xe
                    });
                    else {
                        const q = b.get(xe);
                        xe.lastChangedTime > q && (b.set(xe, xe.lastChangedTime), i.dispatchEvent({
                            type: "planechanged",
                            data: xe
                        }))
                    }
            }
            v = null
        }
        const ie = new zP;
        ie.setAnimationLoop(J), this.setAnimationLoop = function(j) {
            V = j
        }, this.dispose = function() {}
    }
}

function wG(n, e) {
    function t(y, A) {
        A.color.getRGB(y.fogColor.value, OP(n)), A.isFog ? (y.fogNear.value = A.near, y.fogFar.value = A.far) : A.isFogExp2 && (y.fogDensity.value = A.density)
    }

    function i(y, A, x, _, S) {
        A.isMeshBasicMaterial || A.isMeshLambertMaterial ? r(y, A) : A.isMeshToonMaterial ? (r(y, A), d(y, A)) : A.isMeshPhongMaterial ? (r(y, A), c(y, A)) : A.isMeshStandardMaterial ? (r(y, A), h(y, A), A.isMeshPhysicalMaterial && p(y, A, S)) : A.isMeshMatcapMaterial ? (r(y, A), m(y, A)) : A.isMeshDepthMaterial ? r(y, A) : A.isMeshDistanceMaterial ? (r(y, A), v(y, A)) : A.isMeshNormalMaterial ? r(y, A) : A.isLineBasicMaterial ? (s(y, A), A.isLineDashedMaterial && o(y, A)) : A.isPointsMaterial ? a(y, A, x, _) : A.isSpriteMaterial ? l(y, A) : A.isShadowMaterial ? (y.color.value.copy(A.color), y.opacity.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = !1)
    }

    function r(y, A) {
        y.opacity.value = A.opacity, A.color && y.diffuse.value.copy(A.color), A.emissive && y.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity), A.map && (y.map.value = A.map), A.alphaMap && (y.alphaMap.value = A.alphaMap), A.bumpMap && (y.bumpMap.value = A.bumpMap, y.bumpScale.value = A.bumpScale, A.side === Ci && (y.bumpScale.value *= -1)), A.displacementMap && (y.displacementMap.value = A.displacementMap, y.displacementScale.value = A.displacementScale, y.displacementBias.value = A.displacementBias), A.emissiveMap && (y.emissiveMap.value = A.emissiveMap), A.normalMap && (y.normalMap.value = A.normalMap, y.normalScale.value.copy(A.normalScale), A.side === Ci && y.normalScale.value.negate()), A.specularMap && (y.specularMap.value = A.specularMap), A.alphaTest > 0 && (y.alphaTest.value = A.alphaTest);
        const x = e.get(A).envMap;
        if (x && (y.envMap.value = x, y.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = A.reflectivity, y.ior.value = A.ior, y.refractionRatio.value = A.refractionRatio), A.lightMap) {
            y.lightMap.value = A.lightMap;
            const M = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
            y.lightMapIntensity.value = A.lightMapIntensity * M
        }
        A.aoMap && (y.aoMap.value = A.aoMap, y.aoMapIntensity.value = A.aoMapIntensity);
        let _;
        A.map ? _ = A.map : A.specularMap ? _ = A.specularMap : A.displacementMap ? _ = A.displacementMap : A.normalMap ? _ = A.normalMap : A.bumpMap ? _ = A.bumpMap : A.roughnessMap ? _ = A.roughnessMap : A.metalnessMap ? _ = A.metalnessMap : A.alphaMap ? _ = A.alphaMap : A.emissiveMap ? _ = A.emissiveMap : A.clearcoatMap ? _ = A.clearcoatMap : A.clearcoatNormalMap ? _ = A.clearcoatNormalMap : A.clearcoatRoughnessMap ? _ = A.clearcoatRoughnessMap : A.iridescenceMap ? _ = A.iridescenceMap : A.iridescenceThicknessMap ? _ = A.iridescenceThicknessMap : A.specularIntensityMap ? _ = A.specularIntensityMap : A.specularColorMap ? _ = A.specularColorMap : A.transmissionMap ? _ = A.transmissionMap : A.thicknessMap ? _ = A.thicknessMap : A.sheenColorMap ? _ = A.sheenColorMap : A.sheenRoughnessMap && (_ = A.sheenRoughnessMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), y.uvTransform.value.copy(_.matrix));
        let S;
        A.aoMap ? S = A.aoMap : A.lightMap && (S = A.lightMap), S !== void 0 && (S.isWebGLRenderTarget && (S = S.texture), S.matrixAutoUpdate === !0 && S.updateMatrix(), y.uv2Transform.value.copy(S.matrix))
    }

    function s(y, A) {
        y.diffuse.value.copy(A.color), y.opacity.value = A.opacity
    }

    function o(y, A) {
        y.dashSize.value = A.dashSize, y.totalSize.value = A.dashSize + A.gapSize, y.scale.value = A.scale
    }

    function a(y, A, x, _) {
        y.diffuse.value.copy(A.color), y.opacity.value = A.opacity, y.size.value = A.size * x, y.scale.value = _ * .5, A.map && (y.map.value = A.map), A.alphaMap && (y.alphaMap.value = A.alphaMap), A.alphaTest > 0 && (y.alphaTest.value = A.alphaTest);
        let S;
        A.map ? S = A.map : A.alphaMap && (S = A.alphaMap), S !== void 0 && (S.matrixAutoUpdate === !0 && S.updateMatrix(), y.uvTransform.value.copy(S.matrix))
    }

    function l(y, A) {
        y.diffuse.value.copy(A.color), y.opacity.value = A.opacity, y.rotation.value = A.rotation, A.map && (y.map.value = A.map), A.alphaMap && (y.alphaMap.value = A.alphaMap), A.alphaTest > 0 && (y.alphaTest.value = A.alphaTest);
        let x;
        A.map ? x = A.map : A.alphaMap && (x = A.alphaMap), x !== void 0 && (x.matrixAutoUpdate === !0 && x.updateMatrix(), y.uvTransform.value.copy(x.matrix))
    }

    function c(y, A) {
        y.specular.value.copy(A.specular), y.shininess.value = Math.max(A.shininess, 1e-4)
    }

    function d(y, A) {
        A.gradientMap && (y.gradientMap.value = A.gradientMap)
    }

    function h(y, A) {
        y.roughness.value = A.roughness, y.metalness.value = A.metalness, A.roughnessMap && (y.roughnessMap.value = A.roughnessMap), A.metalnessMap && (y.metalnessMap.value = A.metalnessMap), e.get(A).envMap && (y.envMapIntensity.value = A.envMapIntensity)
    }

    function p(y, A, x) {
        y.ior.value = A.ior, A.sheen > 0 && (y.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), y.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (y.sheenColorMap.value = A.sheenColorMap), A.sheenRoughnessMap && (y.sheenRoughnessMap.value = A.sheenRoughnessMap)), A.clearcoat > 0 && (y.clearcoat.value = A.clearcoat, y.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (y.clearcoatMap.value = A.clearcoatMap), A.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap), A.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), y.clearcoatNormalMap.value = A.clearcoatNormalMap, A.side === Ci && y.clearcoatNormalScale.value.negate())), A.iridescence > 0 && (y.iridescence.value = A.iridescence, y.iridescenceIOR.value = A.iridescenceIOR, y.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (y.iridescenceMap.value = A.iridescenceMap), A.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = A.iridescenceThicknessMap)), A.transmission > 0 && (y.transmission.value = A.transmission, y.transmissionSamplerMap.value = x.texture, y.transmissionSamplerSize.value.set(x.width, x.height), A.transmissionMap && (y.transmissionMap.value = A.transmissionMap), y.thickness.value = A.thickness, A.thicknessMap && (y.thicknessMap.value = A.thicknessMap), y.attenuationDistance.value = A.attenuationDistance, y.attenuationColor.value.copy(A.attenuationColor)), y.specularIntensity.value = A.specularIntensity, y.specularColor.value.copy(A.specularColor), A.specularIntensityMap && (y.specularIntensityMap.value = A.specularIntensityMap), A.specularColorMap && (y.specularColorMap.value = A.specularColorMap)
    }

    function m(y, A) {
        A.matcap && (y.matcap.value = A.matcap)
    }

    function v(y, A) {
        y.referencePosition.value.copy(A.referencePosition), y.nearDistance.value = A.nearDistance, y.farDistance.value = A.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: i
    }
}

function SG(n, e, t, i) {
    let r = {},
        s = {},
        o = [];
    const a = t.isWebGL2 ? n.getParameter(35375) : 0;

    function l(_, S) {
        const M = S.program;
        i.uniformBlockBinding(_, M)
    }

    function c(_, S) {
        let M = r[_.id];
        M === void 0 && (v(_), M = d(_), r[_.id] = M, _.addEventListener("dispose", A));
        const b = S.program;
        i.updateUBOMapping(_, b);
        const B = e.render.frame;
        s[_.id] !== B && (p(_), s[_.id] = B)
    }

    function d(_) {
        const S = h();
        _.__bindingPointIndex = S;
        const M = n.createBuffer(),
            b = _.__size,
            B = _.usage;
        return n.bindBuffer(35345, M), n.bufferData(35345, b, B), n.bindBuffer(35345, null), n.bindBufferBase(35345, S, M), M
    }

    function h() {
        for (let _ = 0; _ < a; _++)
            if (o.indexOf(_) === -1) return o.push(_), _;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function p(_) {
        const S = r[_.id],
            M = _.uniforms,
            b = _.__cache;
        n.bindBuffer(35345, S);
        for (let B = 0, R = M.length; B < R; B++) {
            const E = M[B];
            if (m(E, B, b) === !0) {
                const P = E.__offset,
                    I = Array.isArray(E.value) ? E.value : [E.value];
                let z = 0;
                for (let Z = 0; Z < I.length; Z++) {
                    const W = I[Z],
                        G = y(W);
                    typeof W == "number" ? (E.__data[0] = W, n.bufferSubData(35345, P + z, E.__data)) : W.isMatrix3 ? (E.__data[0] = W.elements[0], E.__data[1] = W.elements[1], E.__data[2] = W.elements[2], E.__data[3] = W.elements[0], E.__data[4] = W.elements[3], E.__data[5] = W.elements[4], E.__data[6] = W.elements[5], E.__data[7] = W.elements[0], E.__data[8] = W.elements[6], E.__data[9] = W.elements[7], E.__data[10] = W.elements[8], E.__data[11] = W.elements[0]) : (W.toArray(E.__data, z), z += G.storage / Float32Array.BYTES_PER_ELEMENT)
                }
                n.bufferSubData(35345, P, E.__data)
            }
        }
        n.bindBuffer(35345, null)
    }

    function m(_, S, M) {
        const b = _.value;
        if (M[S] === void 0) {
            if (typeof b == "number") M[S] = b;
            else {
                const B = Array.isArray(b) ? b : [b],
                    R = [];
                for (let E = 0; E < B.length; E++) R.push(B[E].clone());
                M[S] = R
            }
            return !0
        } else if (typeof b == "number") {
            if (M[S] !== b) return M[S] = b, !0
        } else {
            const B = Array.isArray(M[S]) ? M[S] : [M[S]],
                R = Array.isArray(b) ? b : [b];
            for (let E = 0; E < B.length; E++) {
                const P = B[E];
                if (P.equals(R[E]) === !1) return P.copy(R[E]), !0
            }
        }
        return !1
    }

    function v(_) {
        const S = _.uniforms;
        let M = 0;
        const b = 16;
        let B = 0;
        for (let R = 0, E = S.length; R < E; R++) {
            const P = S[R],
                I = {
                    boundary: 0,
                    storage: 0
                },
                z = Array.isArray(P.value) ? P.value : [P.value];
            for (let Z = 0, W = z.length; Z < W; Z++) {
                const G = z[Z],
                    K = y(G);
                I.boundary += K.boundary, I.storage += K.storage
            }
            if (P.__data = new Float32Array(I.storage / Float32Array.BYTES_PER_ELEMENT), P.__offset = M, R > 0) {
                B = M % b;
                const Z = b - B;
                B !== 0 && Z - I.boundary < 0 && (M += b - B, P.__offset = M)
            }
            M += I.storage
        }
        return B = M % b, B > 0 && (M += b - B), _.__size = M, _.__cache = {}, this
    }

    function y(_) {
        const S = {
            boundary: 0,
            storage: 0
        };
        return typeof _ == "number" ? (S.boundary = 4, S.storage = 4) : _.isVector2 ? (S.boundary = 8, S.storage = 8) : _.isVector3 || _.isColor ? (S.boundary = 16, S.storage = 12) : _.isVector4 ? (S.boundary = 16, S.storage = 16) : _.isMatrix3 ? (S.boundary = 48, S.storage = 48) : _.isMatrix4 ? (S.boundary = 64, S.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), S
    }

    function A(_) {
        const S = _.target;
        S.removeEventListener("dispose", A);
        const M = o.indexOf(S.__bindingPointIndex);
        o.splice(M, 1), n.deleteBuffer(r[S.id]), delete r[S.id], delete s[S.id]
    }

    function x() {
        for (const _ in r) n.deleteBuffer(r[_]);
        o = [], r = {}, s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: x
    }
}

function MG() {
    const n = Kf("canvas");
    return n.style.display = "block", n
}

function c_(n = {}) {
    this.isWebGLRenderer = !0;
    const e = n.canvas !== void 0 ? n.canvas : MG(),
        t = n.context !== void 0 ? n.context : null,
        i = n.depth !== void 0 ? n.depth : !0,
        r = n.stencil !== void 0 ? n.stencil : !0,
        s = n.antialias !== void 0 ? n.antialias : !1,
        o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0,
        a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1,
        l = n.powerPreference !== void 0 ? n.powerPreference : "default",
        c = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1;
    let d;
    t !== null ? d = t.getContextAttributes().alpha : d = n.alpha !== void 0 ? n.alpha : !1;
    let h = null,
        p = null;
    const m = [],
        v = [];
    this.domElement = e, this.debug = {
        checkShaderErrors: !0
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Ws, this.physicallyCorrectLights = !1, this.toneMapping = Dr, this.toneMappingExposure = 1;
    const y = this;
    let A = !1,
        x = 0,
        _ = 0,
        S = null,
        M = -1,
        b = null;
    const B = new kt,
        R = new kt;
    let E = null,
        P = e.width,
        I = e.height,
        z = 1,
        Z = null,
        W = null;
    const G = new kt(0, 0, P, I),
        K = new kt(0, 0, P, I);
    let te = !1;
    const se = new Pg;
    let k = !1,
        V = !1,
        J = null;
    const ie = new rt,
        j = new me,
        re = new D,
        ve = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };

    function xe() {
        return S === null ? z : 1
    }
    let q = t;

    function Ne(F, ee) {
        for (let pe = 0; pe < F.length; pe++) {
            const $ = F[pe],
                ye = e.getContext($, ee);
            if (ye !== null) return ye
        }
        return null
    }
    try {
        const F = {
            alpha: !0,
            depth: i,
            stencil: r,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: a,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Mg}`), e.addEventListener("webglcontextlost", _e, !1), e.addEventListener("webglcontextrestored", Te, !1), e.addEventListener("webglcontextcreationerror", $e, !1), q === null) {
            const ee = ["webgl2", "webgl", "experimental-webgl"];
            if (y.isWebGL1Renderer === !0 && ee.shift(), q = Ne(ee, F), q === null) throw Ne(ee) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        q.getShaderPrecisionFormat === void 0 && (q.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        })
    } catch (F) {
        throw console.error("THREE.WebGLRenderer: " + F.message), F
    }
    let Oe, He, we, Le, he, ae, Ce, ze, Pe, Ze, Je, je, vt, St, O, L, oe, Se, Ee, Be, tt, De, ge, Xe;

    function H() {
        Oe = new zz(q), He = new Dz(q, Oe, n), Oe.init(He), De = new jP(q, Oe, He), we = new vG(q, Oe, He), Le = new Vz, he = new oG, ae = new AG(q, Oe, we, he, He, De, Le), Ce = new kz(y), ze = new Uz(y), Pe = new qN(q, He), ge = new Iz(q, Oe, Pe, He), Ze = new Gz(q, Pe, Le, ge), Je = new Xz(q, Ze, Pe, Le), Ee = new Jz(q, He, ae), L = new Fz(he), je = new sG(y, Ce, ze, Oe, He, ge, L), vt = new wG(y, he), St = new lG, O = new pG(Oe, He), Se = new Rz(y, Ce, ze, we, Je, d, o), oe = new yG(y, Je, He), Xe = new SG(q, Le, He, we), Be = new Lz(q, Oe, Le, He), tt = new Hz(q, Oe, Le, He), Le.programs = je.programs, y.capabilities = He, y.extensions = Oe, y.properties = he, y.renderLists = St, y.shadowMap = oe, y.state = we, y.info = Le
    }
    H();
    const ue = new _G(y, q);
    this.xr = ue, this.getContext = function() {
        return q
    }, this.getContextAttributes = function() {
        return q.getContextAttributes()
    }, this.forceContextLoss = function() {
        const F = Oe.get("WEBGL_lose_context");
        F && F.loseContext()
    }, this.forceContextRestore = function() {
        const F = Oe.get("WEBGL_lose_context");
        F && F.restoreContext()
    }, this.getPixelRatio = function() {
        return z
    }, this.setPixelRatio = function(F) {
        F !== void 0 && (z = F, this.setSize(P, I, !1))
    }, this.getSize = function(F) {
        return F.set(P, I)
    }, this.setSize = function(F, ee, pe) {
        if (ue.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        P = F, I = ee, e.width = Math.floor(F * z), e.height = Math.floor(ee * z), pe !== !1 && (e.style.width = F + "px", e.style.height = ee + "px"), this.setViewport(0, 0, F, ee)
    }, this.getDrawingBufferSize = function(F) {
        return F.set(P * z, I * z).floor()
    }, this.setDrawingBufferSize = function(F, ee, pe) {
        P = F, I = ee, z = pe, e.width = Math.floor(F * pe), e.height = Math.floor(ee * pe), this.setViewport(0, 0, F, ee)
    }, this.getCurrentViewport = function(F) {
        return F.copy(B)
    }, this.getViewport = function(F) {
        return F.copy(G)
    }, this.setViewport = function(F, ee, pe, $) {
        F.isVector4 ? G.set(F.x, F.y, F.z, F.w) : G.set(F, ee, pe, $), we.viewport(B.copy(G).multiplyScalar(z).floor())
    }, this.getScissor = function(F) {
        return F.copy(K)
    }, this.setScissor = function(F, ee, pe, $) {
        F.isVector4 ? K.set(F.x, F.y, F.z, F.w) : K.set(F, ee, pe, $), we.scissor(R.copy(K).multiplyScalar(z).floor())
    }, this.getScissorTest = function() {
        return te
    }, this.setScissorTest = function(F) {
        we.setScissorTest(te = F)
    }, this.setOpaqueSort = function(F) {
        Z = F
    }, this.setTransparentSort = function(F) {
        W = F
    }, this.getClearColor = function(F) {
        return F.copy(Se.getClearColor())
    }, this.setClearColor = function() {
        Se.setClearColor.apply(Se, arguments)
    }, this.getClearAlpha = function() {
        return Se.getClearAlpha()
    }, this.setClearAlpha = function() {
        Se.setClearAlpha.apply(Se, arguments)
    }, this.clear = function(F = !0, ee = !0, pe = !0) {
        let $ = 0;
        F && ($ |= 16384), ee && ($ |= 256), pe && ($ |= 1024), q.clear($)
    }, this.clearColor = function() {
        this.clear(!0, !1, !1)
    }, this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }, this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }, this.dispose = function() {
        e.removeEventListener("webglcontextlost", _e, !1), e.removeEventListener("webglcontextrestored", Te, !1), e.removeEventListener("webglcontextcreationerror", $e, !1), St.dispose(), O.dispose(), he.dispose(), Ce.dispose(), ze.dispose(), Je.dispose(), ge.dispose(), Xe.dispose(), je.dispose(), ue.dispose(), ue.removeEventListener("sessionstart", Ue), ue.removeEventListener("sessionend", Ke), J && (J.dispose(), J = null), Bt.stop()
    };

    function _e(F) {
        F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), A = !0
    }

    function Te() {
        console.log("THREE.WebGLRenderer: Context Restored."), A = !1;
        const F = Le.autoReset,
            ee = oe.enabled,
            pe = oe.autoUpdate,
            $ = oe.needsUpdate,
            ye = oe.type;
        H(), Le.autoReset = F, oe.enabled = ee, oe.autoUpdate = pe, oe.needsUpdate = $, oe.type = ye
    }

    function $e(F) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage)
    }

    function yt(F) {
        const ee = F.target;
        ee.removeEventListener("dispose", yt), Vt(ee)
    }

    function Vt(F) {
        Q(F), he.remove(F)
    }

    function Q(F) {
        const ee = he.get(F).programs;
        ee !== void 0 && (ee.forEach(function(pe) {
            je.releaseProgram(pe)
        }), F.isShaderMaterial && je.releaseShaderCache(F))
    }
    this.renderBufferDirect = function(F, ee, pe, $, ye, qe) {
        ee === null && (ee = ve);
        const st = ye.isMesh && ye.matrixWorld.determinant() < 0,
            ft = Zg(F, ee, pe, $, ye);
        we.setMaterial($, st);
        let mt = pe.index,
            Mt = 1;
        $.wireframe === !0 && (mt = Ze.getWireframeAttribute(pe), Mt = 2);
        const xt = pe.drawRange,
            _t = pe.attributes.position;
        let on = xt.start * Mt,
            ti = (xt.start + xt.count) * Mt;
        qe !== null && (on = Math.max(on, qe.start * Mt), ti = Math.min(ti, (qe.start + qe.count) * Mt)), mt !== null ? (on = Math.max(on, 0), ti = Math.min(ti, mt.count)) : _t != null && (on = Math.max(on, 0), ti = Math.min(ti, _t.count));
        const vr = ti - on;
        if (vr < 0 || vr === 1 / 0) return;
        ge.setup(ye, $, ft, pe, mt);
        let ls, Jt = Be;
        if (mt !== null && (ls = Pe.get(mt), Jt = tt, Jt.setIndex(ls)), ye.isMesh) $.wireframe === !0 ? (we.setLineWidth($.wireframeLinewidth * xe()), Jt.setMode(1)) : Jt.setMode(4);
        else if (ye.isLine) {
            let dt = $.linewidth;
            dt === void 0 && (dt = 1), we.setLineWidth(dt * xe()), ye.isLineSegments ? Jt.setMode(1) : ye.isLineLoop ? Jt.setMode(2) : Jt.setMode(3)
        } else ye.isPoints ? Jt.setMode(0) : ye.isSprite && Jt.setMode(4);
        if (ye.isInstancedMesh) Jt.renderInstances(on, vr, ye.count);
        else if (pe.isInstancedBufferGeometry) {
            const dt = pe._maxInstanceCount !== void 0 ? pe._maxInstanceCount : 1 / 0,
                na = Math.min(pe.instanceCount, dt);
            Jt.renderInstances(on, vr, na)
        } else Jt.render(on, vr)
    }, this.compile = function(F, ee) {
        function pe($, ye, qe) {
            $.transparent === !0 && $.side === Rr && $.forceSinglePass === !1 ? ($.side = Ci, $.needsUpdate = !0, pi($, ye, qe), $.side = rs, $.needsUpdate = !0, pi($, ye, qe), $.side = Rr) : pi($, ye, qe)
        }
        p = O.get(F), p.init(), v.push(p), F.traverseVisible(function($) {
            $.isLight && $.layers.test(ee.layers) && (p.pushLight($), $.castShadow && p.pushShadow($))
        }), p.setupLights(y.physicallyCorrectLights), F.traverse(function($) {
            const ye = $.material;
            if (ye)
                if (Array.isArray(ye))
                    for (let qe = 0; qe < ye.length; qe++) {
                        const st = ye[qe];
                        pe(st, F, $)
                    } else pe(ye, F, $)
        }), v.pop(), p = null
    };
    let fe = null;

    function Ae(F) {
        fe && fe(F)
    }

    function Ue() {
        Bt.stop()
    }

    function Ke() {
        Bt.start()
    }
    const Bt = new zP;
    Bt.setAnimationLoop(Ae), typeof self < "u" && Bt.setContext(self), this.setAnimationLoop = function(F) {
        fe = F, ue.setAnimationLoop(F), F === null ? Bt.stop() : Bt.start()
    }, ue.addEventListener("sessionstart", Ue), ue.addEventListener("sessionend", Ke), this.render = function(F, ee) {
        if (ee !== void 0 && ee.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (A === !0) return;
        F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), ee.parent === null && ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(), ue.enabled === !0 && ue.isPresenting === !0 && (ue.cameraAutoUpdate === !0 && ue.updateCamera(ee), ee = ue.getCamera()), F.isScene === !0 && F.onBeforeRender(y, F, ee, S), p = O.get(F, v.length), p.init(), v.push(p), ie.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse), se.setFromProjectionMatrix(ie), V = this.localClippingEnabled, k = L.init(this.clippingPlanes, V), h = St.get(F, m.length), h.init(), m.push(h), dn(F, ee, 0, y.sortObjects), h.finish(), y.sortObjects === !0 && h.sort(Z, W), k === !0 && L.beginShadows();
        const pe = p.state.shadowsArray;
        if (oe.render(pe, F, ee), k === !0 && L.endShadows(), this.info.autoReset === !0 && this.info.reset(), Se.render(h, F), p.setupLights(y.physicallyCorrectLights), ee.isArrayCamera) {
            const $ = ee.cameras;
            for (let ye = 0, qe = $.length; ye < qe; ye++) {
                const st = $[ye];
                Pn(h, F, st, st.viewport)
            }
        } else Pn(h, F, ee);
        S !== null && (ae.updateMultisampleRenderTarget(S), ae.updateRenderTargetMipmap(S)), F.isScene === !0 && F.onAfterRender(y, F, ee), ge.resetDefaultState(), M = -1, b = null, v.pop(), v.length > 0 ? p = v[v.length - 1] : p = null, m.pop(), m.length > 0 ? h = m[m.length - 1] : h = null
    };

    function dn(F, ee, pe, $) {
        if (F.visible === !1) return;
        if (F.layers.test(ee.layers)) {
            if (F.isGroup) pe = F.renderOrder;
            else if (F.isLOD) F.autoUpdate === !0 && F.update(ee);
            else if (F.isLight) p.pushLight(F), F.castShadow && p.pushShadow(F);
            else if (F.isSprite) {
                if (!F.frustumCulled || se.intersectsSprite(F)) {
                    $ && re.setFromMatrixPosition(F.matrixWorld).applyMatrix4(ie);
                    const st = Je.update(F),
                        ft = F.material;
                    ft.visible && h.push(F, st, ft, pe, re.z, null)
                }
            } else if ((F.isMesh || F.isLine || F.isPoints) && (F.isSkinnedMesh && F.skeleton.frame !== Le.render.frame && (F.skeleton.update(), F.skeleton.frame = Le.render.frame), !F.frustumCulled || se.intersectsObject(F))) {
                $ && re.setFromMatrixPosition(F.matrixWorld).applyMatrix4(ie);
                const st = Je.update(F),
                    ft = F.material;
                if (Array.isArray(ft)) {
                    const mt = st.groups;
                    for (let Mt = 0, xt = mt.length; Mt < xt; Mt++) {
                        const _t = mt[Mt],
                            on = ft[_t.materialIndex];
                        on && on.visible && h.push(F, st, on, pe, re.z, _t)
                    }
                } else ft.visible && h.push(F, st, ft, pe, re.z, null)
            }
        }
        const qe = F.children;
        for (let st = 0, ft = qe.length; st < ft; st++) dn(qe[st], ee, pe, $)
    }

    function Pn(F, ee, pe, $) {
        const ye = F.opaque,
            qe = F.transmissive,
            st = F.transparent;
        p.setupLightsView(pe), k === !0 && L.setGlobalState(y.clippingPlanes, pe), qe.length > 0 && Gr(ye, ee, pe), $ && we.viewport(B.copy($)), ye.length > 0 && Ot(ye, ee, pe), qe.length > 0 && Ot(qe, ee, pe), st.length > 0 && Ot(st, ee, pe), we.buffers.depth.setTest(!0), we.buffers.depth.setMask(!0), we.buffers.color.setMask(!0), we.setPolygonOffset(!1)
    }

    function Gr(F, ee, pe) {
        const $ = He.isWebGL2;
        J === null && (J = new Nr(1, 1, {
            generateMipmaps: !0,
            type: Oe.has("EXT_color_buffer_half_float") ? Iu : Vs,
            minFilter: ss,
            samples: $ && s === !0 ? 4 : 0
        })), y.getDrawingBufferSize(j), $ ? J.setSize(j.x, j.y) : J.setSize(Jm(j.x), Jm(j.y));
        const ye = y.getRenderTarget();
        y.setRenderTarget(J), y.clear();
        const qe = y.toneMapping;
        y.toneMapping = Dr, Ot(F, ee, pe), y.toneMapping = qe, ae.updateMultisampleRenderTarget(J), ae.updateRenderTargetMipmap(J), y.setRenderTarget(ye)
    }

    function Ot(F, ee, pe) {
        const $ = ee.isScene === !0 ? ee.overrideMaterial : null;
        for (let ye = 0, qe = F.length; ye < qe; ye++) {
            const st = F[ye],
                ft = st.object,
                mt = st.geometry,
                Mt = $ === null ? st.material : $,
                xt = st.group;
            ft.layers.test(pe.layers) && ji(ft, ee, pe, mt, Mt, xt)
        }
    }

    function ji(F, ee, pe, $, ye, qe) {
        F.onBeforeRender(y, ee, pe, $, ye, qe), F.modelViewMatrix.multiplyMatrices(pe.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), ye.onBeforeRender(y, ee, pe, $, F, qe), ye.transparent === !0 && ye.side === Rr && ye.forceSinglePass === !1 ? (ye.side = Ci, ye.needsUpdate = !0, y.renderBufferDirect(pe, ee, $, ye, F, qe), ye.side = rs, ye.needsUpdate = !0, y.renderBufferDirect(pe, ee, $, ye, F, qe), ye.side = Rr) : y.renderBufferDirect(pe, ee, $, ye, F, qe), F.onAfterRender(y, ee, pe, $, ye, qe)
    }

    function pi(F, ee, pe) {
        ee.isScene !== !0 && (ee = ve);
        const $ = he.get(F),
            ye = p.state.lights,
            qe = p.state.shadowsArray,
            st = ye.state.version,
            ft = je.getParameters(F, ye.state, qe, ee, pe),
            mt = je.getProgramCacheKey(ft);
        let Mt = $.programs;
        $.environment = F.isMeshStandardMaterial ? ee.environment : null, $.fog = ee.fog, $.envMap = (F.isMeshStandardMaterial ? ze : Ce).get(F.envMap || $.environment), Mt === void 0 && (F.addEventListener("dispose", yt), Mt = new Map, $.programs = Mt);
        let xt = Mt.get(mt);
        if (xt !== void 0) {
            if ($.currentProgram === xt && $.lightsStateVersion === st) return zd(F, ft), xt
        } else ft.uniforms = je.getUniforms(F), F.onBuild(pe, ft, y), F.onBeforeCompile(ft, y), xt = je.acquireProgram(ft, mt), Mt.set(mt, xt), $.uniforms = ft.uniforms;
        const _t = $.uniforms;
        (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (_t.clippingPlanes = L.uniform), zd(F, ft), $.needsLights = nc(F), $.lightsStateVersion = st, $.needsLights && (_t.ambientLightColor.value = ye.state.ambient, _t.lightProbe.value = ye.state.probe, _t.directionalLights.value = ye.state.directional, _t.directionalLightShadows.value = ye.state.directionalShadow, _t.spotLights.value = ye.state.spot, _t.spotLightShadows.value = ye.state.spotShadow, _t.rectAreaLights.value = ye.state.rectArea, _t.ltc_1.value = ye.state.rectAreaLTC1, _t.ltc_2.value = ye.state.rectAreaLTC2, _t.pointLights.value = ye.state.point, _t.pointLightShadows.value = ye.state.pointShadow, _t.hemisphereLights.value = ye.state.hemi, _t.directionalShadowMap.value = ye.state.directionalShadowMap, _t.directionalShadowMatrix.value = ye.state.directionalShadowMatrix, _t.spotShadowMap.value = ye.state.spotShadowMap, _t.spotLightMatrix.value = ye.state.spotLightMatrix, _t.spotLightMap.value = ye.state.spotLightMap, _t.pointShadowMap.value = ye.state.pointShadowMap, _t.pointShadowMatrix.value = ye.state.pointShadowMatrix);
        const on = xt.getUniforms(),
            ti = hm.seqWithValue(on.seq, _t);
        return $.currentProgram = xt, $.uniformsList = ti, xt
    }

    function zd(F, ee) {
        const pe = he.get(F);
        pe.outputEncoding = ee.outputEncoding, pe.instancing = ee.instancing, pe.skinning = ee.skinning, pe.morphTargets = ee.morphTargets, pe.morphNormals = ee.morphNormals, pe.morphColors = ee.morphColors, pe.morphTargetsCount = ee.morphTargetsCount, pe.numClippingPlanes = ee.numClippingPlanes, pe.numIntersection = ee.numClipIntersection, pe.vertexAlphas = ee.vertexAlphas, pe.vertexTangents = ee.vertexTangents, pe.toneMapping = ee.toneMapping
    }

    function Zg(F, ee, pe, $, ye) {
        ee.isScene !== !0 && (ee = ve), ae.resetTextureUnits();
        const qe = ee.fog,
            st = $.isMeshStandardMaterial ? ee.environment : null,
            ft = S === null ? y.outputEncoding : S.isXRRenderTarget === !0 ? S.texture.encoding : Ws,
            mt = ($.isMeshStandardMaterial ? ze : Ce).get($.envMap || st),
            Mt = $.vertexColors === !0 && !!pe.attributes.color && pe.attributes.color.itemSize === 4,
            xt = !!$.normalMap && !!pe.attributes.tangent,
            _t = !!pe.morphAttributes.position,
            on = !!pe.morphAttributes.normal,
            ti = !!pe.morphAttributes.color,
            vr = $.toneMapped ? y.toneMapping : Dr,
            ls = pe.morphAttributes.position || pe.morphAttributes.normal || pe.morphAttributes.color,
            Jt = ls !== void 0 ? ls.length : 0,
            dt = he.get($),
            na = p.state.lights;
        if (k === !0 && (V === !0 || F !== b)) {
            const Ft = F === b && $.id === M;
            L.setState($, F, Ft)
        }
        let an = !1;
        $.version === dt.__version ? (dt.needsLights && dt.lightsStateVersion !== na.state.version || dt.outputEncoding !== ft || ye.isInstancedMesh && dt.instancing === !1 || !ye.isInstancedMesh && dt.instancing === !0 || ye.isSkinnedMesh && dt.skinning === !1 || !ye.isSkinnedMesh && dt.skinning === !0 || dt.envMap !== mt || $.fog === !0 && dt.fog !== qe || dt.numClippingPlanes !== void 0 && (dt.numClippingPlanes !== L.numPlanes || dt.numIntersection !== L.numIntersection) || dt.vertexAlphas !== Mt || dt.vertexTangents !== xt || dt.morphTargets !== _t || dt.morphNormals !== on || dt.morphColors !== ti || dt.toneMapping !== vr || He.isWebGL2 === !0 && dt.morphTargetsCount !== Jt) && (an = !0) : (an = !0, dt.__version = $.version);
        let us = dt.currentProgram;
        an === !0 && (us = pi($, ee, ye));
        let ml = !1,
            Ji = !1,
            Xi = !1;
        const ct = us.getUniforms(),
            Et = dt.uniforms;
        if (we.useProgram(us.program) && (ml = !0, Ji = !0, Xi = !0), $.id !== M && (M = $.id, Ji = !0), ml || b !== F) {
            if (ct.setValue(q, "projectionMatrix", F.projectionMatrix), He.logarithmicDepthBuffer && ct.setValue(q, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)), b !== F && (b = F, Ji = !0, Xi = !0), $.isShaderMaterial || $.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshStandardMaterial || $.envMap) {
                const Ft = ct.map.cameraPosition;
                Ft !== void 0 && Ft.setValue(q, re.setFromMatrixPosition(F.matrixWorld))
            }($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial) && ct.setValue(q, "isOrthographic", F.isOrthographicCamera === !0), ($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial || $.isShadowMaterial || ye.isSkinnedMesh) && ct.setValue(q, "viewMatrix", F.matrixWorldInverse)
        }
        if (ye.isSkinnedMesh) {
            ct.setOptional(q, ye, "bindMatrix"), ct.setOptional(q, ye, "bindMatrixInverse");
            const Ft = ye.skeleton;
            Ft && (He.floatVertexTextures ? (Ft.boneTexture === null && Ft.computeBoneTexture(), ct.setValue(q, "boneTexture", Ft.boneTexture, ae), ct.setValue(q, "boneTextureSize", Ft.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
        }
        const Qi = pe.morphAttributes;
        if ((Qi.position !== void 0 || Qi.normal !== void 0 || Qi.color !== void 0 && He.isWebGL2 === !0) && Ee.update(ye, pe, $, us), (Ji || dt.receiveShadow !== ye.receiveShadow) && (dt.receiveShadow = ye.receiveShadow, ct.setValue(q, "receiveShadow", ye.receiveShadow)), $.isMeshGouraudMaterial && $.envMap !== null && (Et.envMap.value = mt, Et.flipEnvMap.value = mt.isCubeTexture && mt.isRenderTargetTexture === !1 ? -1 : 1), Ji && (ct.setValue(q, "toneMappingExposure", y.toneMappingExposure), dt.needsLights && Gd(Et, Xi), qe && $.fog === !0 && vt.refreshFogUniforms(Et, qe), vt.refreshMaterialUniforms(Et, $, z, I, J), hm.upload(q, dt.uniformsList, Et, ae)), $.isShaderMaterial && $.uniformsNeedUpdate === !0 && (hm.upload(q, dt.uniformsList, Et, ae), $.uniformsNeedUpdate = !1), $.isSpriteMaterial && ct.setValue(q, "center", ye.center), ct.setValue(q, "modelViewMatrix", ye.modelViewMatrix), ct.setValue(q, "normalMatrix", ye.normalMatrix), ct.setValue(q, "modelMatrix", ye.matrixWorld), $.isShaderMaterial || $.isRawShaderMaterial) {
            const Ft = $.uniformsGroups;
            for (let Rn = 0, cs = Ft.length; Rn < cs; Rn++)
                if (He.isWebGL2) {
                    const fs = Ft[Rn];
                    Xe.update(fs, us), Xe.bind(fs, us)
                } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
        }
        return us
    }

    function Gd(F, ee) {
        F.ambientLightColor.needsUpdate = ee, F.lightProbe.needsUpdate = ee, F.directionalLights.needsUpdate = ee, F.directionalLightShadows.needsUpdate = ee, F.pointLights.needsUpdate = ee, F.pointLightShadows.needsUpdate = ee, F.spotLights.needsUpdate = ee, F.spotLightShadows.needsUpdate = ee, F.rectAreaLights.needsUpdate = ee, F.hemisphereLights.needsUpdate = ee
    }

    function nc(F) {
        return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0
    }
    this.getActiveCubeFace = function() {
        return x
    }, this.getActiveMipmapLevel = function() {
        return _
    }, this.getRenderTarget = function() {
        return S
    }, this.setRenderTargetTextures = function(F, ee, pe) {
        he.get(F.texture).__webglTexture = ee, he.get(F.depthTexture).__webglTexture = pe;
        const $ = he.get(F);
        $.__hasExternalTextures = !0, $.__hasExternalTextures && ($.__autoAllocateDepthBuffer = pe === void 0, $.__autoAllocateDepthBuffer || Oe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), $.__useRenderToTexture = !1))
    }, this.setRenderTargetFramebuffer = function(F, ee) {
        const pe = he.get(F);
        pe.__webglFramebuffer = ee, pe.__useDefaultFramebuffer = ee === void 0
    }, this.setRenderTarget = function(F, ee = 0, pe = 0) {
        S = F, x = ee, _ = pe;
        let $ = !0,
            ye = null,
            qe = !1,
            st = !1;
        if (F) {
            const mt = he.get(F);
            mt.__useDefaultFramebuffer !== void 0 ? (we.bindFramebuffer(36160, null), $ = !1) : mt.__webglFramebuffer === void 0 ? ae.setupRenderTarget(F) : mt.__hasExternalTextures && ae.rebindTextures(F, he.get(F.texture).__webglTexture, he.get(F.depthTexture).__webglTexture);
            const Mt = F.texture;
            (Mt.isData3DTexture || Mt.isDataArrayTexture || Mt.isCompressedArrayTexture) && (st = !0);
            const xt = he.get(F).__webglFramebuffer;
            F.isWebGLCubeRenderTarget ? (ye = xt[ee], qe = !0) : He.isWebGL2 && F.samples > 0 && ae.useMultisampledRTT(F) === !1 ? ye = he.get(F).__webglMultisampledFramebuffer : ye = xt, B.copy(F.viewport), R.copy(F.scissor), E = F.scissorTest
        } else B.copy(G).multiplyScalar(z).floor(), R.copy(K).multiplyScalar(z).floor(), E = te;
        if (we.bindFramebuffer(36160, ye) && He.drawBuffers && $ && we.drawBuffers(F, ye), we.viewport(B), we.scissor(R), we.setScissorTest(E), qe) {
            const mt = he.get(F.texture);
            q.framebufferTexture2D(36160, 36064, 34069 + ee, mt.__webglTexture, pe)
        } else if (st) {
            const mt = he.get(F.texture),
                Mt = ee || 0;
            q.framebufferTextureLayer(36160, 36064, mt.__webglTexture, pe || 0, Mt)
        }
        M = -1
    }, this.readRenderTargetPixels = function(F, ee, pe, $, ye, qe, st) {
        if (!(F && F.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let ft = he.get(F).__webglFramebuffer;
        if (F.isWebGLCubeRenderTarget && st !== void 0 && (ft = ft[st]), ft) {
            we.bindFramebuffer(36160, ft);
            try {
                const mt = F.texture,
                    Mt = mt.format,
                    xt = mt.type;
                if (Mt !== xi && De.convert(Mt) !== q.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                const _t = xt === Iu && (Oe.has("EXT_color_buffer_half_float") || He.isWebGL2 && Oe.has("EXT_color_buffer_float"));
                if (xt !== Vs && De.convert(xt) !== q.getParameter(35738) && !(xt === Rs && (He.isWebGL2 || Oe.has("OES_texture_float") || Oe.has("WEBGL_color_buffer_float"))) && !_t) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                ee >= 0 && ee <= F.width - $ && pe >= 0 && pe <= F.height - ye && q.readPixels(ee, pe, $, ye, De.convert(Mt), De.convert(xt), qe)
            } finally {
                const mt = S !== null ? he.get(S).__webglFramebuffer : null;
                we.bindFramebuffer(36160, mt)
            }
        }
    }, this.copyFramebufferToTexture = function(F, ee, pe = 0) {
        const $ = Math.pow(2, -pe),
            ye = Math.floor(ee.image.width * $),
            qe = Math.floor(ee.image.height * $);
        ae.setTexture2D(ee, 0), q.copyTexSubImage2D(3553, pe, 0, 0, F.x, F.y, ye, qe), we.unbindTexture()
    }, this.copyTextureToTexture = function(F, ee, pe, $ = 0) {
        const ye = ee.image.width,
            qe = ee.image.height,
            st = De.convert(pe.format),
            ft = De.convert(pe.type);
        ae.setTexture2D(pe, 0), q.pixelStorei(37440, pe.flipY), q.pixelStorei(37441, pe.premultiplyAlpha), q.pixelStorei(3317, pe.unpackAlignment), ee.isDataTexture ? q.texSubImage2D(3553, $, F.x, F.y, ye, qe, st, ft, ee.image.data) : ee.isCompressedTexture ? q.compressedTexSubImage2D(3553, $, F.x, F.y, ee.mipmaps[0].width, ee.mipmaps[0].height, st, ee.mipmaps[0].data) : q.texSubImage2D(3553, $, F.x, F.y, st, ft, ee.image), $ === 0 && pe.generateMipmaps && q.generateMipmap(3553), we.unbindTexture()
    }, this.copyTextureToTexture3D = function(F, ee, pe, $, ye = 0) {
        if (y.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        const qe = F.max.x - F.min.x + 1,
            st = F.max.y - F.min.y + 1,
            ft = F.max.z - F.min.z + 1,
            mt = De.convert($.format),
            Mt = De.convert($.type);
        let xt;
        if ($.isData3DTexture) ae.setTexture3D($, 0), xt = 32879;
        else if ($.isDataArrayTexture) ae.setTexture2DArray($, 0), xt = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        q.pixelStorei(37440, $.flipY), q.pixelStorei(37441, $.premultiplyAlpha), q.pixelStorei(3317, $.unpackAlignment);
        const _t = q.getParameter(3314),
            on = q.getParameter(32878),
            ti = q.getParameter(3316),
            vr = q.getParameter(3315),
            ls = q.getParameter(32877),
            Jt = pe.isCompressedTexture ? pe.mipmaps[0] : pe.image;
        q.pixelStorei(3314, Jt.width), q.pixelStorei(32878, Jt.height), q.pixelStorei(3316, F.min.x), q.pixelStorei(3315, F.min.y), q.pixelStorei(32877, F.min.z), pe.isDataTexture || pe.isData3DTexture ? q.texSubImage3D(xt, ye, ee.x, ee.y, ee.z, qe, st, ft, mt, Mt, Jt.data) : pe.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), q.compressedTexSubImage3D(xt, ye, ee.x, ee.y, ee.z, qe, st, ft, mt, Jt.data)) : q.texSubImage3D(xt, ye, ee.x, ee.y, ee.z, qe, st, ft, mt, Mt, Jt), q.pixelStorei(3314, _t), q.pixelStorei(32878, on), q.pixelStorei(3316, ti), q.pixelStorei(3315, vr), q.pixelStorei(32877, ls), ye === 0 && $.generateMipmaps && q.generateMipmap(xt), we.unbindTexture()
    }, this.initTexture = function(F) {
        F.isCubeTexture ? ae.setTextureCube(F, 0) : F.isData3DTexture ? ae.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? ae.setTexture2DArray(F, 0) : ae.setTexture2D(F, 0), we.unbindTexture()
    }, this.resetState = function() {
        x = 0, _ = 0, S = null, we.reset(), ge.reset()
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
    }))
}
class QP extends c_ {}
QP.prototype.isWebGL1Renderer = !0;
class Ig {
    constructor(e, t = 25e-5) {
        this.isFogExp2 = !0, this.name = "", this.color = new Ie(e), this.density = t
    }
    clone() {
        return new Ig(this.color, this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class Lg {
    constructor(e, t = 1, i = 1e3) {
        this.isFog = !0, this.name = "", this.color = new Ie(e), this.near = t, this.far = i
    }
    clone() {
        return new Lg(this.color, this.near, this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class f_ extends Tt {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e
    }
}
class Ad {
    constructor(e, t) {
        this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Xf, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = Ui()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e, this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
    }
    copyAt(e, t, i) {
        e *= this.stride, i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ui()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ui()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const ri = new D;
class Vo {
    constructor(e, t, i, r = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++) ri.fromBufferAttribute(this, t), ri.applyMatrix4(e), this.setXYZ(t, ri.x, ri.y, ri.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) ri.fromBufferAttribute(this, t), ri.applyNormalMatrix(e), this.setXYZ(t, ri.x, ri.y, ri.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) ri.fromBufferAttribute(this, t), ri.transformDirection(e), this.setXYZ(t, ri.x, ri.y, ri.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
    }
    setY(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
    }
    setZ(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
    }
    setW(e, t) {
        return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Is(t, this.array)), t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Is(t, this.array)), t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Is(t, this.array)), t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Is(t, this.array)), t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
            }
            return new Dt(new this.array.constructor(t), this.itemSize, this.normalized)
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Vo(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class d_ extends wn {
    constructor(e) {
        super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Ie(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
let Vl;
const Nc = new D,
    Wl = new D,
    jl = new D,
    Jl = new me,
    Oc = new me,
    KP = new rt,
    yp = new D,
    Uc = new D,
    vp = new D,
    KC = new me,
    ev = new me,
    YC = new me;
class YP extends Tt {
    constructor(e) {
        if (super(), this.isSprite = !0, this.type = "Sprite", Vl === void 0) {
            Vl = new ut;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                i = new Ad(t, 5);
            Vl.setIndex([0, 1, 2, 0, 2, 3]), Vl.setAttribute("position", new Vo(i, 3, 0, !1)), Vl.setAttribute("uv", new Vo(i, 2, 3, !1))
        }
        this.geometry = Vl, this.material = e !== void 0 ? e : new d_, this.center = new me(.5, .5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Wl.setFromMatrixScale(this.matrixWorld), KP.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), jl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Wl.multiplyScalar(-jl.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i), r = Math.sin(i));
        const o = this.center;
        Ap(yp.set(-.5, -.5, 0), jl, o, Wl, r, s), Ap(Uc.set(.5, -.5, 0), jl, o, Wl, r, s), Ap(vp.set(.5, .5, 0), jl, o, Wl, r, s), KC.set(0, 0), ev.set(1, 0), YC.set(1, 1);
        let a = e.ray.intersectTriangle(yp, Uc, vp, !1, Nc);
        if (a === null && (Ap(Uc.set(-.5, .5, 0), jl, o, Wl, r, s), ev.set(0, 1), a = e.ray.intersectTriangle(yp, vp, Uc, !1, Nc), a === null)) return;
        const l = e.ray.origin.distanceTo(Nc);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: Nc.clone(),
            uv: cr.getUV(Nc, yp, Uc, vp, KC, ev, YC, new me),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
    }
}

function Ap(n, e, t, i, r, s) {
    Jl.subVectors(n, t).addScalar(.5).multiply(i), r !== void 0 ? (Oc.x = s * Jl.x - r * Jl.y, Oc.y = r * Jl.x + s * Jl.y) : Oc.copy(Jl), n.copy(e), n.x += Oc.x, n.y += Oc.y, n.applyMatrix4(KP)
}
const xp = new D,
    ZC = new D;
class ZP extends Tt {
    constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }), this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate, this
    }
    addLevel(e, t = 0, i = 0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++);
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }), this.add(e), this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1, r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s) break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            xp.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(xp);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            xp.setFromMatrixPosition(e.matrixWorld), ZC.setFromMatrixPosition(this.matrixWorld);
            const i = xp.distanceTo(ZC) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1, s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                else break
            }
            for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const qC = new D,
    $C = new kt,
    eE = new kt,
    CG = new D,
    tE = new rt;
class h_ extends bn {
    constructor(e, t) {
        super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new rt, this.bindMatrixInverse = new rt
    }
    copy(e, t) {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
    }
    bind(e, t) {
        this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new kt,
            t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        const i = this.skeleton,
            r = this.geometry;
        $C.fromBufferAttribute(r.attributes.skinIndex, e), eE.fromBufferAttribute(r.attributes.skinWeight, e), qC.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = eE.getComponent(s);
            if (o !== 0) {
                const a = $C.getComponent(s);
                tE.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(CG.copy(qC).applyMatrix4(tE), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class Dg extends Tt {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class wu extends Yt {
    constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = fn, d = fn, h, p) {
        super(null, o, a, l, c, d, r, s, h, p), this.isDataTexture = !0, this.image = {
            data: e,
            width: t,
            height: i
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const nE = new rt,
    EG = new rt;
class xd {
    constructor(e = [], t = []) {
        this.uuid = Ui(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
    }
    init() {
        const e = this.bones,
            t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new rt)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new rt;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones,
            t = this.boneInverses,
            i = this.boneMatrices,
            r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : EG;
            nE.multiplyMatrices(a, t[s]), nE.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new xd(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = FP(e), e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new wu(t, e, e, xi, Rs);
        return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e) return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Dg), this.bones.push(o), this.boneInverses.push(new rt().fromArray(e.boneInverses[i]))
        }
        return this.init(), this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones,
            i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class ku extends Dt {
    constructor(e, t, i, r = 1) {
        super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
    }
}
const iE = new rt,
    rE = new rt,
    _p = [],
    bG = new rt,
    zc = new bn;
class qP extends bn {
    constructor(e, t, i) {
        super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new ku(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1;
        for (let r = 0; r < i; r++) this.setMatrixAt(r, bG)
    }
    copy(e, t) {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        const i = this.matrixWorld,
            r = this.count;
        if (zc.geometry = this.geometry, zc.material = this.material, zc.material !== void 0)
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, iE), rE.multiplyMatrices(i, iE), zc.matrixWorld = rE, zc.raycast(e, _p);
                for (let o = 0, a = _p.length; o < a; o++) {
                    const l = _p[o];
                    l.instanceId = s, l.object = this, t.push(l)
                }
                _p.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new ku(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class ei extends wn {
    constructor(e) {
        super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Ie(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
    }
}
const sE = new D,
    oE = new D,
    aE = new rt,
    tv = new gd,
    wp = new Zo;
class js extends Tt {
    constructor(e = new ut, t = new ei) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [0];
            for (let r = 1, s = t.count; r < s; r++) sE.fromBufferAttribute(t, r - 1), oE.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += sE.distanceTo(oE);
            e.setAttribute("lineDistance", new We(i, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Line.threshold,
            o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), wp.copy(i.boundingSphere), wp.applyMatrix4(r), wp.radius += s, e.ray.intersectsSphere(wp) === !1) return;
        aE.copy(r).invert(), tv.copy(e.ray).applyMatrix4(aE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new D,
            d = new D,
            h = new D,
            p = new D,
            m = this.isLineSegments ? 2 : 1,
            v = i.index,
            A = i.attributes.position;
        if (v !== null) {
            const x = Math.max(0, o.start),
                _ = Math.min(v.count, o.start + o.count);
            for (let S = x, M = _ - 1; S < M; S += m) {
                const b = v.getX(S),
                    B = v.getX(S + 1);
                if (c.fromBufferAttribute(A, b), d.fromBufferAttribute(A, B), tv.distanceSqToSegment(c, d, p, h) > l) continue;
                p.applyMatrix4(this.matrixWorld);
                const E = e.ray.origin.distanceTo(p);
                E < e.near || E > e.far || t.push({
                    distance: E,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: S,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            const x = Math.max(0, o.start),
                _ = Math.min(A.count, o.start + o.count);
            for (let S = x, M = _ - 1; S < M; S += m) {
                if (c.fromBufferAttribute(A, S), d.fromBufferAttribute(A, S + 1), tv.distanceSqToSegment(c, d, p, h) > l) continue;
                p.applyMatrix4(this.matrixWorld);
                const B = e.ray.origin.distanceTo(p);
                B < e.near || B > e.far || t.push({
                    distance: B,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: S,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
const lE = new D,
    uE = new D;
class Or extends js {
    constructor(e, t) {
        super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                i = [];
            for (let r = 0, s = t.count; r < s; r += 2) lE.fromBufferAttribute(t, r), uE.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + lE.distanceTo(uE);
            e.setAttribute("lineDistance", new We(i, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class p_ extends js {
    constructor(e, t) {
        super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class _d extends wn {
    constructor(e) {
        super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Ie(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
const cE = new rt,
    hx = new gd,
    Sp = new Zo,
    Mp = new D;
let m_ = class extends Tt {
    constructor(e = new ut, t = new _d) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
    }
    raycast(e, t) {
        const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Points.threshold,
            o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), Sp.copy(i.boundingSphere), Sp.applyMatrix4(r), Sp.radius += s, e.ray.intersectsSphere(Sp) === !1) return;
        cE.copy(r).invert(), hx.copy(e.ray).applyMatrix4(cE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = i.index,
            h = i.attributes.position;
        if (c !== null) {
            const p = Math.max(0, o.start),
                m = Math.min(c.count, o.start + o.count);
            for (let v = p, y = m; v < y; v++) {
                const A = c.getX(v);
                Mp.fromBufferAttribute(h, A), fE(Mp, A, l, r, e, t, this)
            }
        } else {
            const p = Math.max(0, o.start),
                m = Math.min(h.count, o.start + o.count);
            for (let v = p, y = m; v < y; v++) Mp.fromBufferAttribute(h, v), fE(Mp, v, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
};

function fE(n, e, t, i, r, s, o) {
    const a = hx.distanceSqToPoint(n);
    if (a < t) {
        const l = new D;
        hx.closestPointToPoint(n, l), l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far) return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class TG extends Yt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : en, this.magFilter = s !== void 0 ? s : en, this.generateMipmaps = !1;
        const d = this;

        function h() {
            d.needsUpdate = !0, e.requestVideoFrameCallback(h)
        }
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class BG extends Yt {
    constructor(e, t, i) {
        super({
            width: e,
            height: t
        }), this.isFramebufferTexture = !0, this.format = i, this.magFilter = fn, this.minFilter = fn, this.generateMipmaps = !1, this.needsUpdate = !0
    }
}
class g_ extends Yt {
    constructor(e, t, i, r, s, o, a, l, c, d, h, p) {
        super(null, o, a, l, c, d, r, s, h, p), this.isCompressedTexture = !0, this.image = {
            width: t,
            height: i
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }
}
class PG extends g_ {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = zn
    }
}
class RG extends Yt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class Ur {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0),
            s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++) i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i;
        return this.cacheArcLengths = t, t
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0,
            l = s - 1,
            c;
        for (; a <= l;)
            if (r = Math.floor(a + (l - a) / 2), c = i[r] - o, c < 0) a = r + 1;
            else if (c > 0) l = r - 1;
        else {
            l = r;
            break
        }
        if (r = l, i[r] === o) return r / (s - 1);
        const d = i[r],
            p = i[r + 1] - d,
            m = (o - d) / p;
        return (r + m) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4,
            s = e + 1e-4;
        r < 0 && (r = 0), s > 1 && (s = 1);
        const o = this.getPoint(r),
            a = this.getPoint(s),
            l = t || (o.isVector2 ? new me : new D);
        return l.copy(a).sub(o).normalize(), l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new D,
            r = [],
            s = [],
            o = [],
            a = new D,
            l = new rt;
        for (let m = 0; m <= e; m++) {
            const v = m / e;
            r[m] = this.getTangentAt(v, new D)
        }
        s[0] = new D, o[0] = new D;
        let c = Number.MAX_VALUE;
        const d = Math.abs(r[0].x),
            h = Math.abs(r[0].y),
            p = Math.abs(r[0].z);
        d <= c && (c = d, i.set(1, 0, 0)), h <= c && (c = h, i.set(0, 1, 0)), p <= c && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
        for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(r[m - 1], r[m]), a.length() > Number.EPSILON) {
                a.normalize();
                const v = Math.acos(gn(r[m - 1].dot(r[m]), -1, 1));
                s[m].applyMatrix4(l.makeRotationAxis(a, v))
            }
            o[m].crossVectors(r[m], s[m])
        }
        if (t === !0) {
            let m = Math.acos(gn(s[0].dot(s[e]), -1, 1));
            m /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let v = 1; v <= e; v++) s[v].applyMatrix4(l.makeRotationAxis(r[v], m * v)), o[v].crossVectors(r[v], s[v])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
}
class Fg extends Ur {
    constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
    }
    getPoint(e, t) {
        const i = t || new me,
            r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0;) s += r;
        for (; s > r;) s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const d = Math.cos(this.aRotation),
                h = Math.sin(this.aRotation),
                p = l - this.aX,
                m = c - this.aY;
            l = p * d - m * h + this.aX, c = p * h + m * d + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
}
class $P extends Fg {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function y_() {
    let n = 0,
        e = 0,
        t = 0,
        i = 0;

    function r(s, o, a, l) {
        n = s, e = a, t = -3 * s + 3 * o - 2 * a - l, i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            r(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, d, h) {
            let p = (o - s) / c - (a - s) / (c + d) + (a - o) / d,
                m = (a - o) / d - (l - o) / (d + h) + (l - a) / h;
            p *= d, m *= d, r(o, a, p, m)
        },
        calc: function(s) {
            const o = s * s,
                a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const Cp = new D,
    nv = new y_,
    iv = new y_,
    rv = new y_;
class e3 extends Ur {
    constructor(e = [], t = !1, i = "centripetal", r = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r
    }
    getPoint(e, t = new D) {
        const i = t,
            r = this.points,
            s = r.length,
            o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o),
            l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
        let c, d;
        this.closed || a > 0 ? c = r[(a - 1) % s] : (Cp.subVectors(r[0], r[1]).add(r[0]), c = Cp);
        const h = r[a % s],
            p = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? d = r[(a + 2) % s] : (Cp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), d = Cp), this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let v = Math.pow(c.distanceToSquared(h), m),
                y = Math.pow(h.distanceToSquared(p), m),
                A = Math.pow(p.distanceToSquared(d), m);
            y < 1e-4 && (y = 1), v < 1e-4 && (v = y), A < 1e-4 && (A = y), nv.initNonuniformCatmullRom(c.x, h.x, p.x, d.x, v, y, A), iv.initNonuniformCatmullRom(c.y, h.y, p.y, d.y, v, y, A), rv.initNonuniformCatmullRom(c.z, h.z, p.z, d.z, v, y, A)
        } else this.curveType === "catmullrom" && (nv.initCatmullRom(c.x, h.x, p.x, d.x, this.tension), iv.initCatmullRom(c.y, h.y, p.y, d.y, this.tension), rv.initCatmullRom(c.z, h.z, p.z, d.z, this.tension));
        return i.set(nv.calc(l), iv.calc(l), rv.calc(l)), i
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new D().fromArray(r))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
}

function dE(n, e, t, i, r) {
    const s = (i - e) * .5,
        o = (r - t) * .5,
        a = n * n,
        l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}

function IG(n, e) {
    const t = 1 - n;
    return t * t * e
}

function LG(n, e) {
    return 2 * (1 - n) * n * e
}

function DG(n, e) {
    return n * n * e
}

function gf(n, e, t, i) {
    return IG(n, e) + LG(n, t) + DG(n, i)
}

function FG(n, e) {
    const t = 1 - n;
    return t * t * t * e
}

function kG(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}

function NG(n, e) {
    return 3 * (1 - n) * n * n * e
}

function OG(n, e) {
    return n * n * n * e
}

function yf(n, e, t, i, r) {
    return FG(n, e) + kG(n, t) + NG(n, i) + OG(n, r)
}
class v_ extends Ur {
    constructor(e = new me, t = new me, i = new me, r = new me) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
    }
    getPoint(e, t = new me) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(yf(e, r.x, s.x, o.x, a.x), yf(e, r.y, s.y, o.y, a.y)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class t3 extends Ur {
    constructor(e = new D, t = new D, i = new D, r = new D) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
    }
    getPoint(e, t = new D) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(yf(e, r.x, s.x, o.x, a.x), yf(e, r.y, s.y, o.y, a.y), yf(e, r.z, s.z, o.z, a.z)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class kg extends Ur {
    constructor(e = new me, t = new me) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new me) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        const i = t || new me;
        return i.copy(this.v2).sub(this.v1).normalize(), i
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class n3 extends Ur {
    constructor(e = new D, t = new D) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new D) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class A_ extends Ur {
    constructor(e = new me, t = new me, i = new me) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i
    }
    getPoint(e, t = new me) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2;
        return i.set(gf(e, r.x, s.x, o.x), gf(e, r.y, s.y, o.y)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class x_ extends Ur {
    constructor(e = new D, t = new D, i = new D) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i
    }
    getPoint(e, t = new D) {
        const i = t,
            r = this.v0,
            s = this.v1,
            o = this.v2;
        return i.set(gf(e, r.x, s.x, o.x), gf(e, r.y, s.y, o.y), gf(e, r.z, s.z, o.z)), i
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class __ extends Ur {
    constructor(e = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
    }
    getPoint(e, t = new me) {
        const i = t,
            r = this.points,
            s = (r.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = r[o === 0 ? o : o - 1],
            c = r[o],
            d = r[o > r.length - 2 ? r.length - 1 : o + 1],
            h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(dE(a, l.x, c.x, d.x, h.x), dE(a, l.y, c.y, d.y, h.y)), i
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new me().fromArray(r))
        }
        return this
    }
}
var w_ = Object.freeze({
    __proto__: null,
    ArcCurve: $P,
    CatmullRomCurve3: e3,
    CubicBezierCurve: v_,
    CubicBezierCurve3: t3,
    EllipseCurve: Fg,
    LineCurve: kg,
    LineCurve3: n3,
    QuadraticBezierCurve: A_,
    QuadraticBezierCurve3: x_,
    SplineCurve: __
});
class i3 extends Ur {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new kg(t, e))
    }
    getPoint(e, t) {
        const i = e * this.getLength(),
            r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length;) {
            if (r[s] >= i) {
                const o = r[s] - i,
                    a = this.curves[s],
                    l = a.getLength(),
                    c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++) t += this.curves[i].getLength(), e.push(t);
        return this.cacheLengths = e, e
    }
    getSpacedPoints(e = 40) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]), t
    }
    getPoints(e = 12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r],
                a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
                l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const d = l[c];
                i && i.equals(d) || (t.push(d), i = d)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
    }
    copy(e) {
        super.copy(e), this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose, this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new w_[r.type]().fromJSON(r))
        }
        return this
    }
}
class Yf extends i3 {
    constructor(e) {
        super(), this.type = "Path", this.currentPoint = new me, e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this
    }
    lineTo(e, t) {
        const i = new kg(this.currentPoint.clone(), new me(e, t));
        return this.curves.push(i), this.currentPoint.set(e, t), this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new A_(this.currentPoint.clone(), new me(e, t), new me(i, r));
        return this.curves.push(s), this.currentPoint.set(i, r), this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new v_(this.currentPoint.clone(), new me(e, t), new me(i, r), new me(s, o));
        return this.curves.push(a), this.currentPoint.set(s, o), this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
            i = new __(t);
        return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x,
            l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o), this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o), this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const c = this.currentPoint.x,
            d = this.currentPoint.y;
        return this.absellipse(e + c, t + d, i, r, s, o, a, l), this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const c = new Fg(e, t, i, r, s, o, a, l);
        if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(c);
        const d = c.getPoint(1);
        return this.currentPoint.copy(d), this
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
    }
}
class Ku extends ut {
    constructor(e = [new me(0, -.5), new me(.5, 0), new me(0, .5)], t = 12, i = 0, r = Math.PI * 2) {
        super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        }, t = Math.floor(t), r = gn(r, 0, Math.PI * 2);
        const s = [],
            o = [],
            a = [],
            l = [],
            c = [],
            d = 1 / t,
            h = new D,
            p = new me,
            m = new D,
            v = new D,
            y = new D;
        let A = 0,
            x = 0;
        for (let _ = 0; _ <= e.length - 1; _++) switch (_) {
            case 0:
                A = e[_ + 1].x - e[_].x, x = e[_ + 1].y - e[_].y, m.x = x * 1, m.y = -A, m.z = x * 0, y.copy(m), m.normalize(), l.push(m.x, m.y, m.z);
                break;
            case e.length - 1:
                l.push(y.x, y.y, y.z);
                break;
            default:
                A = e[_ + 1].x - e[_].x, x = e[_ + 1].y - e[_].y, m.x = x * 1, m.y = -A, m.z = x * 0, v.copy(m), m.x += y.x, m.y += y.y, m.z += y.z, m.normalize(), l.push(m.x, m.y, m.z), y.copy(v)
        }
        for (let _ = 0; _ <= t; _++) {
            const S = i + _ * d * r,
                M = Math.sin(S),
                b = Math.cos(S);
            for (let B = 0; B <= e.length - 1; B++) {
                h.x = e[B].x * M, h.y = e[B].y, h.z = e[B].x * b, o.push(h.x, h.y, h.z), p.x = _ / t, p.y = B / (e.length - 1), a.push(p.x, p.y);
                const R = l[3 * B + 0] * M,
                    E = l[3 * B + 1],
                    P = l[3 * B + 0] * b;
                c.push(R, E, P)
            }
        }
        for (let _ = 0; _ < t; _++)
            for (let S = 0; S < e.length - 1; S++) {
                const M = S + _ * e.length,
                    b = M,
                    B = M + e.length,
                    R = M + e.length + 1,
                    E = M + 1;
                s.push(b, B, E), s.push(R, E, B)
            }
        this.setIndex(s), this.setAttribute("position", new We(o, 3)), this.setAttribute("uv", new We(a, 2)), this.setAttribute("normal", new We(c, 3))
    }
    static fromJSON(e) {
        return new Ku(e.points, e.segments, e.phiStart, e.phiLength)
    }
}
class wd extends Ku {
    constructor(e = 1, t = 1, i = 4, r = 8) {
        const s = new Yf;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            height: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new wd(e.radius, e.length, e.capSegments, e.radialSegments)
    }
}
class Sd extends ut {
    constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
        super(), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        }, t = Math.max(3, t);
        const s = [],
            o = [],
            a = [],
            l = [],
            c = new D,
            d = new me;
        o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5);
        for (let h = 0, p = 3; h <= t; h++, p += 3) {
            const m = i + h / t * r;
            c.x = e * Math.cos(m), c.y = e * Math.sin(m), o.push(c.x, c.y, c.z), a.push(0, 0, 1), d.x = (o[p] / e + 1) / 2, d.y = (o[p + 1] / e + 1) / 2, l.push(d.x, d.y)
        }
        for (let h = 1; h <= t; h++) s.push(h, h + 1, 0);
        this.setIndex(s), this.setAttribute("position", new We(o, 3)), this.setAttribute("normal", new We(a, 3)), this.setAttribute("uv", new We(l, 2))
    }
    static fromJSON(e) {
        return new Sd(e.radius, e.segments, e.thetaStart, e.thetaLength)
    }
}
class ul extends ut {
    constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        r = Math.floor(r), s = Math.floor(s);
        const d = [],
            h = [],
            p = [],
            m = [];
        let v = 0;
        const y = [],
            A = i / 2;
        let x = 0;
        _(), o === !1 && (e > 0 && S(!0), t > 0 && S(!1)), this.setIndex(d), this.setAttribute("position", new We(h, 3)), this.setAttribute("normal", new We(p, 3)), this.setAttribute("uv", new We(m, 2));

        function _() {
            const M = new D,
                b = new D;
            let B = 0;
            const R = (t - e) / i;
            for (let E = 0; E <= s; E++) {
                const P = [],
                    I = E / s,
                    z = I * (t - e) + e;
                for (let Z = 0; Z <= r; Z++) {
                    const W = Z / r,
                        G = W * l + a,
                        K = Math.sin(G),
                        te = Math.cos(G);
                    b.x = z * K, b.y = -I * i + A, b.z = z * te, h.push(b.x, b.y, b.z), M.set(K, R, te).normalize(), p.push(M.x, M.y, M.z), m.push(W, 1 - I), P.push(v++)
                }
                y.push(P)
            }
            for (let E = 0; E < r; E++)
                for (let P = 0; P < s; P++) {
                    const I = y[P][E],
                        z = y[P + 1][E],
                        Z = y[P + 1][E + 1],
                        W = y[P][E + 1];
                    d.push(I, z, W), d.push(z, Z, W), B += 6
                }
            c.addGroup(x, B, 0), x += B
        }

        function S(M) {
            const b = v,
                B = new me,
                R = new D;
            let E = 0;
            const P = M === !0 ? e : t,
                I = M === !0 ? 1 : -1;
            for (let Z = 1; Z <= r; Z++) h.push(0, A * I, 0), p.push(0, I, 0), m.push(.5, .5), v++;
            const z = v;
            for (let Z = 0; Z <= r; Z++) {
                const G = Z / r * l + a,
                    K = Math.cos(G),
                    te = Math.sin(G);
                R.x = P * te, R.y = A * I, R.z = P * K, h.push(R.x, R.y, R.z), p.push(0, I, 0), B.x = K * .5 + .5, B.y = te * .5 * I + .5, m.push(B.x, B.y), v++
            }
            for (let Z = 0; Z < r; Z++) {
                const W = b + Z,
                    G = z + Z;
                M === !0 ? d.push(G, G + 1, W) : d.push(G + 1, G, W), E += 3
            }
            c.addGroup(x, E, M === !0 ? 1 : 2), x += E
        }
    }
    static fromJSON(e) {
        return new ul(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class Md extends ul {
    constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
        super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Md(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class Qs extends ut {
    constructor(e = [], t = [], i = 1, r = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = [],
            o = [];
        a(r), c(i), d(), this.setAttribute("position", new We(s, 3)), this.setAttribute("normal", new We(s.slice(), 3)), this.setAttribute("uv", new We(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();

        function a(_) {
            const S = new D,
                M = new D,
                b = new D;
            for (let B = 0; B < t.length; B += 3) m(t[B + 0], S), m(t[B + 1], M), m(t[B + 2], b), l(S, M, b, _)
        }

        function l(_, S, M, b) {
            const B = b + 1,
                R = [];
            for (let E = 0; E <= B; E++) {
                R[E] = [];
                const P = _.clone().lerp(M, E / B),
                    I = S.clone().lerp(M, E / B),
                    z = B - E;
                for (let Z = 0; Z <= z; Z++) Z === 0 && E === B ? R[E][Z] = P : R[E][Z] = P.clone().lerp(I, Z / z)
            }
            for (let E = 0; E < B; E++)
                for (let P = 0; P < 2 * (B - E) - 1; P++) {
                    const I = Math.floor(P / 2);
                    P % 2 === 0 ? (p(R[E][I + 1]), p(R[E + 1][I]), p(R[E][I])) : (p(R[E][I + 1]), p(R[E + 1][I + 1]), p(R[E + 1][I]))
                }
        }

        function c(_) {
            const S = new D;
            for (let M = 0; M < s.length; M += 3) S.x = s[M + 0], S.y = s[M + 1], S.z = s[M + 2], S.normalize().multiplyScalar(_), s[M + 0] = S.x, s[M + 1] = S.y, s[M + 2] = S.z
        }

        function d() {
            const _ = new D;
            for (let S = 0; S < s.length; S += 3) {
                _.x = s[S + 0], _.y = s[S + 1], _.z = s[S + 2];
                const M = A(_) / 2 / Math.PI + .5,
                    b = x(_) / Math.PI + .5;
                o.push(M, 1 - b)
            }
            v(), h()
        }

        function h() {
            for (let _ = 0; _ < o.length; _ += 6) {
                const S = o[_ + 0],
                    M = o[_ + 2],
                    b = o[_ + 4],
                    B = Math.max(S, M, b),
                    R = Math.min(S, M, b);
                B > .9 && R < .1 && (S < .2 && (o[_ + 0] += 1), M < .2 && (o[_ + 2] += 1), b < .2 && (o[_ + 4] += 1))
            }
        }

        function p(_) {
            s.push(_.x, _.y, _.z)
        }

        function m(_, S) {
            const M = _ * 3;
            S.x = e[M + 0], S.y = e[M + 1], S.z = e[M + 2]
        }

        function v() {
            const _ = new D,
                S = new D,
                M = new D,
                b = new D,
                B = new me,
                R = new me,
                E = new me;
            for (let P = 0, I = 0; P < s.length; P += 9, I += 6) {
                _.set(s[P + 0], s[P + 1], s[P + 2]), S.set(s[P + 3], s[P + 4], s[P + 5]), M.set(s[P + 6], s[P + 7], s[P + 8]), B.set(o[I + 0], o[I + 1]), R.set(o[I + 2], o[I + 3]), E.set(o[I + 4], o[I + 5]), b.copy(_).add(S).add(M).divideScalar(3);
                const z = A(b);
                y(B, I + 0, _, z), y(R, I + 2, S, z), y(E, I + 4, M, z)
            }
        }

        function y(_, S, M, b) {
            b < 0 && _.x === 1 && (o[S] = _.x - 1), M.x === 0 && M.z === 0 && (o[S] = b / 2 / Math.PI + .5)
        }

        function A(_) {
            return Math.atan2(_.z, -_.x)
        }

        function x(_) {
            return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z))
        }
    }
    static fromJSON(e) {
        return new Qs(e.vertices, e.indices, e.radius, e.details)
    }
}
class Cd extends Qs {
    constructor(e = 1, t = 0) {
        const i = (1 + Math.sqrt(5)) / 2,
            r = 1 / i,
            s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Cd(e.radius, e.detail)
    }
}
const Ep = new D,
    bp = new D,
    sv = new D,
    Tp = new cr;
class r3 extends ut {
    constructor(e = null, t = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
                geometry: e,
                thresholdAngle: t
            }, e !== null) {
            const r = Math.pow(10, 4),
                s = Math.cos(Xa * t),
                o = e.getIndex(),
                a = e.getAttribute("position"),
                l = o ? o.count : a.count,
                c = [0, 0, 0],
                d = ["a", "b", "c"],
                h = new Array(3),
                p = {},
                m = [];
            for (let v = 0; v < l; v += 3) {
                o ? (c[0] = o.getX(v), c[1] = o.getX(v + 1), c[2] = o.getX(v + 2)) : (c[0] = v, c[1] = v + 1, c[2] = v + 2);
                const {
                    a: y,
                    b: A,
                    c: x
                } = Tp;
                if (y.fromBufferAttribute(a, c[0]), A.fromBufferAttribute(a, c[1]), x.fromBufferAttribute(a, c[2]), Tp.getNormal(sv), h[0] = `${Math.round(y.x*r)},${Math.round(y.y*r)},${Math.round(y.z*r)}`, h[1] = `${Math.round(A.x*r)},${Math.round(A.y*r)},${Math.round(A.z*r)}`, h[2] = `${Math.round(x.x*r)},${Math.round(x.y*r)},${Math.round(x.z*r)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let _ = 0; _ < 3; _++) {
                        const S = (_ + 1) % 3,
                            M = h[_],
                            b = h[S],
                            B = Tp[d[_]],
                            R = Tp[d[S]],
                            E = `${M}_${b}`,
                            P = `${b}_${M}`;
                        P in p && p[P] ? (sv.dot(p[P].normal) <= s && (m.push(B.x, B.y, B.z), m.push(R.x, R.y, R.z)), p[P] = null) : E in p || (p[E] = {
                            index0: c[_],
                            index1: c[S],
                            normal: sv.clone()
                        })
                    }
            }
            for (const v in p)
                if (p[v]) {
                    const {
                        index0: y,
                        index1: A
                    } = p[v];
                    Ep.fromBufferAttribute(a, y), bp.fromBufferAttribute(a, A), m.push(Ep.x, Ep.y, Ep.z), m.push(bp.x, bp.y, bp.z)
                } this.setAttribute("position", new We(m, 3))
        }
    }
}
class Ya extends Yf {
    constructor(e) {
        super(e), this.uuid = Ui(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e), this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new Yf().fromJSON(r))
        }
        return this
    }
}
const UG = {
    triangulate: function(n, e, t = 2) {
        const i = e && e.length,
            r = i ? e[0] * t : n.length;
        let s = s3(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, c, d, h, p, m;
        if (i && (s = WG(n, e, s, t)), n.length > 80 * t) {
            a = c = n[0], l = d = n[1];
            for (let v = t; v < r; v += t) h = n[v], p = n[v + 1], h < a && (a = h), p < l && (l = p), h > c && (c = h), p > d && (d = p);
            m = Math.max(c - a, d - l), m = m !== 0 ? 32767 / m : 0
        }
        return Zf(s, o, t, a, l, m, 0), o
    }
};

function s3(n, e, t, i, r) {
    let s, o;
    if (r === tH(n, e, t, i) > 0)
        for (s = e; s < t; s += i) o = hE(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i) o = hE(s, n[s], n[s + 1], o);
    return o && Ng(o, o.next) && ($f(o), o = o.next), o
}

function rl(n, e) {
    if (!n) return n;
    e || (e = n);
    let t = n,
        i;
    do
        if (i = !1, !t.steiner && (Ng(t, t.next) || tn(t.prev, t, t.next) === 0)) {
            if ($f(t), t = e = t.prev, t === t.next) break;
            i = !0
        } else t = t.next; while (i || t !== e);
    return e
}

function Zf(n, e, t, i, r, s, o) {
    if (!n) return;
    !o && s && KG(n, i, r, s);
    let a = n,
        l, c;
    for (; n.prev !== n.next;) {
        if (l = n.prev, c = n.next, s ? GG(n, i, r, s) : zG(n)) {
            e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(c.i / t | 0), $f(n), n = c.next, a = c.next;
            continue
        }
        if (n = c, n === a) {
            o ? o === 1 ? (n = HG(rl(n), e, t), Zf(n, e, t, i, r, s, 2)) : o === 2 && VG(n, e, t, i, r, s) : Zf(rl(n), e, t, i, r, s, 1);
            break
        }
    }
}

function zG(n) {
    const e = n.prev,
        t = n,
        i = n.next;
    if (tn(e, t, i) >= 0) return !1;
    const r = e.x,
        s = t.x,
        o = i.x,
        a = e.y,
        l = t.y,
        c = i.y,
        d = r < s ? r < o ? r : o : s < o ? s : o,
        h = a < l ? a < c ? a : c : l < c ? l : c,
        p = r > s ? r > o ? r : o : s > o ? s : o,
        m = a > l ? a > c ? a : c : l > c ? l : c;
    let v = i.next;
    for (; v !== e;) {
        if (v.x >= d && v.x <= p && v.y >= h && v.y <= m && cu(r, a, s, l, o, c, v.x, v.y) && tn(v.prev, v, v.next) >= 0) return !1;
        v = v.next
    }
    return !0
}

function GG(n, e, t, i) {
    const r = n.prev,
        s = n,
        o = n.next;
    if (tn(r, s, o) >= 0) return !1;
    const a = r.x,
        l = s.x,
        c = o.x,
        d = r.y,
        h = s.y,
        p = o.y,
        m = a < l ? a < c ? a : c : l < c ? l : c,
        v = d < h ? d < p ? d : p : h < p ? h : p,
        y = a > l ? a > c ? a : c : l > c ? l : c,
        A = d > h ? d > p ? d : p : h > p ? h : p,
        x = px(m, v, e, t, i),
        _ = px(y, A, e, t, i);
    let S = n.prevZ,
        M = n.nextZ;
    for (; S && S.z >= x && M && M.z <= _;) {
        if (S.x >= m && S.x <= y && S.y >= v && S.y <= A && S !== r && S !== o && cu(a, d, l, h, c, p, S.x, S.y) && tn(S.prev, S, S.next) >= 0 || (S = S.prevZ, M.x >= m && M.x <= y && M.y >= v && M.y <= A && M !== r && M !== o && cu(a, d, l, h, c, p, M.x, M.y) && tn(M.prev, M, M.next) >= 0)) return !1;
        M = M.nextZ
    }
    for (; S && S.z >= x;) {
        if (S.x >= m && S.x <= y && S.y >= v && S.y <= A && S !== r && S !== o && cu(a, d, l, h, c, p, S.x, S.y) && tn(S.prev, S, S.next) >= 0) return !1;
        S = S.prevZ
    }
    for (; M && M.z <= _;) {
        if (M.x >= m && M.x <= y && M.y >= v && M.y <= A && M !== r && M !== o && cu(a, d, l, h, c, p, M.x, M.y) && tn(M.prev, M, M.next) >= 0) return !1;
        M = M.nextZ
    }
    return !0
}

function HG(n, e, t) {
    let i = n;
    do {
        const r = i.prev,
            s = i.next.next;
        !Ng(r, s) && o3(r, i, i.next, s) && qf(r, s) && qf(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), $f(i), $f(i.next), i = n = s), i = i.next
    } while (i !== n);
    return rl(i)
}

function VG(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && qG(o, a)) {
                let l = a3(o, a);
                o = rl(o, o.next), l = rl(l, l.next), Zf(o, e, t, i, r, s, 0), Zf(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}

function WG(n, e, t, i) {
    const r = [];
    let s, o, a, l, c;
    for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : n.length, c = s3(n, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(ZG(c));
    for (r.sort(jG), s = 0; s < r.length; s++) t = JG(r[s], t);
    return t
}

function jG(n, e) {
    return n.x - e.x
}

function JG(n, e) {
    const t = XG(n, e);
    if (!t) return e;
    const i = a3(t, n);
    return rl(i, i.next), rl(t, t.next)
}

function XG(n, e) {
    let t = e,
        i = -1 / 0,
        r;
    const s = n.x,
        o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (p <= s && p > i && (i = p, r = t.x < t.next.x ? t : t.next, p === s)) return r
        }
        t = t.next
    } while (t !== e);
    if (!r) return null;
    const a = r,
        l = r.x,
        c = r.y;
    let d = 1 / 0,
        h;
    t = r;
    do s >= t.x && t.x >= l && s !== t.x && cu(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), qf(t, n) && (h < d || h === d && (t.x > r.x || t.x === r.x && QG(r, t))) && (r = t, d = h)), t = t.next; while (t !== a);
    return r
}

function QG(n, e) {
    return tn(n.prev, n, e.prev) < 0 && tn(e.next, n, n.next) < 0
}

function KG(n, e, t, i) {
    let r = n;
    do r.z === 0 && (r.z = px(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== n);
    r.prevZ.nextZ = null, r.prevZ = null, YG(r)
}

function YG(n) {
    let e, t, i, r, s, o, a, l, c = 1;
    do {
        for (t = n, n = null, s = null, o = 0; t;) {
            for (o++, i = t, a = 0, e = 0; e < c && (a++, i = i.nextZ, !!i); e++);
            for (l = c; a > 0 || l > 0 && i;) a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
            t = i
        }
        s.nextZ = null, c *= 2
    } while (o > 1);
    return n
}

function px(n, e, t, i, r) {
    return n = (n - t) * r | 0, e = (e - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1
}

function ZG(n) {
    let e = n,
        t = n;
    do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n);
    return t
}

function cu(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}

function qG(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !$G(n, e) && (qf(n, e) && qf(e, n) && eH(n, e) && (tn(n.prev, n, e.prev) || tn(n, e.prev, e)) || Ng(n, e) && tn(n.prev, n, n.next) > 0 && tn(e.prev, e, e.next) > 0)
}

function tn(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}

function Ng(n, e) {
    return n.x === e.x && n.y === e.y
}

function o3(n, e, t, i) {
    const r = Pp(tn(n, e, t)),
        s = Pp(tn(n, e, i)),
        o = Pp(tn(t, i, n)),
        a = Pp(tn(t, i, e));
    return !!(r !== s && o !== a || r === 0 && Bp(n, t, e) || s === 0 && Bp(n, i, e) || o === 0 && Bp(t, n, i) || a === 0 && Bp(t, e, i))
}

function Bp(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}

function Pp(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}

function $G(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && o3(t, t.next, n, e)) return !0;
        t = t.next
    } while (t !== n);
    return !1
}

function qf(n, e) {
    return tn(n.prev, n, n.next) < 0 ? tn(n, e, n.next) >= 0 && tn(n, n.prev, e) >= 0 : tn(n, e, n.prev) < 0 || tn(n, n.next, e) < 0
}

function eH(n, e) {
    let t = n,
        i = !1;
    const r = (n.x + e.x) / 2,
        s = (n.y + e.y) / 2;
    do t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next; while (t !== n);
    return i
}

function a3(n, e) {
    const t = new mx(n.i, n.x, n.y),
        i = new mx(e.i, e.x, e.y),
        r = n.next,
        s = e.prev;
    return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i
}

function hE(n, e, t, i) {
    const r = new mx(n, e, t);
    return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
}

function $f(n) {
    n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
}

function mx(n, e, t) {
    this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function tH(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i) r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s;
    return r
}
class ts {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return ts.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = [],
            r = [],
            s = [];
        pE(e), mE(i, e);
        let o = e.length;
        t.forEach(pE);
        for (let l = 0; l < t.length; l++) r.push(o), o += t[l].length, mE(i, t[l]);
        const a = UG.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
        return s
    }
}

function pE(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}

function mE(n, e) {
    for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y)
}
class Ed extends ut {
    constructor(e = new Ya([new me(.5, .5), new me(-.5, .5), new me(-.5, -.5), new me(.5, -.5)]), t = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        const i = this,
            r = [],
            s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new We(r, 3)), this.setAttribute("uv", new We(s, 2)), this.computeVertexNormals();

        function o(a) {
            const l = [],
                c = t.curveSegments !== void 0 ? t.curveSegments : 12,
                d = t.steps !== void 0 ? t.steps : 1,
                h = t.depth !== void 0 ? t.depth : 1;
            let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                m = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
                v = t.bevelSize !== void 0 ? t.bevelSize : m - .1,
                y = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                A = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const x = t.extrudePath,
                _ = t.UVGenerator !== void 0 ? t.UVGenerator : nH;
            let S, M = !1,
                b, B, R, E;
            x && (S = x.getSpacedPoints(d), M = !0, p = !1, b = x.computeFrenetFrames(d, !1), B = new D, R = new D, E = new D), p || (A = 0, m = 0, v = 0, y = 0);
            const P = a.extractPoints(c);
            let I = P.shape;
            const z = P.holes;
            if (!ts.isClockWise(I)) {
                I = I.reverse();
                for (let he = 0, ae = z.length; he < ae; he++) {
                    const Ce = z[he];
                    ts.isClockWise(Ce) && (z[he] = Ce.reverse())
                }
            }
            const W = ts.triangulateShape(I, z),
                G = I;
            for (let he = 0, ae = z.length; he < ae; he++) {
                const Ce = z[he];
                I = I.concat(Ce)
            }

            function K(he, ae, Ce) {
                return ae || console.error("THREE.ExtrudeGeometry: vec does not exist"), ae.clone().multiplyScalar(Ce).add(he)
            }
            const te = I.length,
                se = W.length;

            function k(he, ae, Ce) {
                let ze, Pe, Ze;
                const Je = he.x - ae.x,
                    je = he.y - ae.y,
                    vt = Ce.x - he.x,
                    St = Ce.y - he.y,
                    O = Je * Je + je * je,
                    L = Je * St - je * vt;
                if (Math.abs(L) > Number.EPSILON) {
                    const oe = Math.sqrt(O),
                        Se = Math.sqrt(vt * vt + St * St),
                        Ee = ae.x - je / oe,
                        Be = ae.y + Je / oe,
                        tt = Ce.x - St / Se,
                        De = Ce.y + vt / Se,
                        ge = ((tt - Ee) * St - (De - Be) * vt) / (Je * St - je * vt);
                    ze = Ee + Je * ge - he.x, Pe = Be + je * ge - he.y;
                    const Xe = ze * ze + Pe * Pe;
                    if (Xe <= 2) return new me(ze, Pe);
                    Ze = Math.sqrt(Xe / 2)
                } else {
                    let oe = !1;
                    Je > Number.EPSILON ? vt > Number.EPSILON && (oe = !0) : Je < -Number.EPSILON ? vt < -Number.EPSILON && (oe = !0) : Math.sign(je) === Math.sign(St) && (oe = !0), oe ? (ze = -je, Pe = Je, Ze = Math.sqrt(O)) : (ze = Je, Pe = je, Ze = Math.sqrt(O / 2))
                }
                return new me(ze / Ze, Pe / Ze)
            }
            const V = [];
            for (let he = 0, ae = G.length, Ce = ae - 1, ze = he + 1; he < ae; he++, Ce++, ze++) Ce === ae && (Ce = 0), ze === ae && (ze = 0), V[he] = k(G[he], G[Ce], G[ze]);
            const J = [];
            let ie, j = V.concat();
            for (let he = 0, ae = z.length; he < ae; he++) {
                const Ce = z[he];
                ie = [];
                for (let ze = 0, Pe = Ce.length, Ze = Pe - 1, Je = ze + 1; ze < Pe; ze++, Ze++, Je++) Ze === Pe && (Ze = 0), Je === Pe && (Je = 0), ie[ze] = k(Ce[ze], Ce[Ze], Ce[Je]);
                J.push(ie), j = j.concat(ie)
            }
            for (let he = 0; he < A; he++) {
                const ae = he / A,
                    Ce = m * Math.cos(ae * Math.PI / 2),
                    ze = v * Math.sin(ae * Math.PI / 2) + y;
                for (let Pe = 0, Ze = G.length; Pe < Ze; Pe++) {
                    const Je = K(G[Pe], V[Pe], ze);
                    Ne(Je.x, Je.y, -Ce)
                }
                for (let Pe = 0, Ze = z.length; Pe < Ze; Pe++) {
                    const Je = z[Pe];
                    ie = J[Pe];
                    for (let je = 0, vt = Je.length; je < vt; je++) {
                        const St = K(Je[je], ie[je], ze);
                        Ne(St.x, St.y, -Ce)
                    }
                }
            }
            const re = v + y;
            for (let he = 0; he < te; he++) {
                const ae = p ? K(I[he], j[he], re) : I[he];
                M ? (R.copy(b.normals[0]).multiplyScalar(ae.x), B.copy(b.binormals[0]).multiplyScalar(ae.y), E.copy(S[0]).add(R).add(B), Ne(E.x, E.y, E.z)) : Ne(ae.x, ae.y, 0)
            }
            for (let he = 1; he <= d; he++)
                for (let ae = 0; ae < te; ae++) {
                    const Ce = p ? K(I[ae], j[ae], re) : I[ae];
                    M ? (R.copy(b.normals[he]).multiplyScalar(Ce.x), B.copy(b.binormals[he]).multiplyScalar(Ce.y), E.copy(S[he]).add(R).add(B), Ne(E.x, E.y, E.z)) : Ne(Ce.x, Ce.y, h / d * he)
                }
            for (let he = A - 1; he >= 0; he--) {
                const ae = he / A,
                    Ce = m * Math.cos(ae * Math.PI / 2),
                    ze = v * Math.sin(ae * Math.PI / 2) + y;
                for (let Pe = 0, Ze = G.length; Pe < Ze; Pe++) {
                    const Je = K(G[Pe], V[Pe], ze);
                    Ne(Je.x, Je.y, h + Ce)
                }
                for (let Pe = 0, Ze = z.length; Pe < Ze; Pe++) {
                    const Je = z[Pe];
                    ie = J[Pe];
                    for (let je = 0, vt = Je.length; je < vt; je++) {
                        const St = K(Je[je], ie[je], ze);
                        M ? Ne(St.x, St.y + S[d - 1].y, S[d - 1].x + Ce) : Ne(St.x, St.y, h + Ce)
                    }
                }
            }
            ve(), xe();

            function ve() {
                const he = r.length / 3;
                if (p) {
                    let ae = 0,
                        Ce = te * ae;
                    for (let ze = 0; ze < se; ze++) {
                        const Pe = W[ze];
                        Oe(Pe[2] + Ce, Pe[1] + Ce, Pe[0] + Ce)
                    }
                    ae = d + A * 2, Ce = te * ae;
                    for (let ze = 0; ze < se; ze++) {
                        const Pe = W[ze];
                        Oe(Pe[0] + Ce, Pe[1] + Ce, Pe[2] + Ce)
                    }
                } else {
                    for (let ae = 0; ae < se; ae++) {
                        const Ce = W[ae];
                        Oe(Ce[2], Ce[1], Ce[0])
                    }
                    for (let ae = 0; ae < se; ae++) {
                        const Ce = W[ae];
                        Oe(Ce[0] + te * d, Ce[1] + te * d, Ce[2] + te * d)
                    }
                }
                i.addGroup(he, r.length / 3 - he, 0)
            }

            function xe() {
                const he = r.length / 3;
                let ae = 0;
                q(G, ae), ae += G.length;
                for (let Ce = 0, ze = z.length; Ce < ze; Ce++) {
                    const Pe = z[Ce];
                    q(Pe, ae), ae += Pe.length
                }
                i.addGroup(he, r.length / 3 - he, 1)
            }

            function q(he, ae) {
                let Ce = he.length;
                for (; --Ce >= 0;) {
                    const ze = Ce;
                    let Pe = Ce - 1;
                    Pe < 0 && (Pe = he.length - 1);
                    for (let Ze = 0, Je = d + A * 2; Ze < Je; Ze++) {
                        const je = te * Ze,
                            vt = te * (Ze + 1),
                            St = ae + ze + je,
                            O = ae + Pe + je,
                            L = ae + Pe + vt,
                            oe = ae + ze + vt;
                        He(St, O, L, oe)
                    }
                }
            }

            function Ne(he, ae, Ce) {
                l.push(he), l.push(ae), l.push(Ce)
            }

            function Oe(he, ae, Ce) {
                we(he), we(ae), we(Ce);
                const ze = r.length / 3,
                    Pe = _.generateTopUV(i, r, ze - 3, ze - 2, ze - 1);
                Le(Pe[0]), Le(Pe[1]), Le(Pe[2])
            }

            function He(he, ae, Ce, ze) {
                we(he), we(ae), we(ze), we(ae), we(Ce), we(ze);
                const Pe = r.length / 3,
                    Ze = _.generateSideWallUV(i, r, Pe - 6, Pe - 3, Pe - 2, Pe - 1);
                Le(Ze[0]), Le(Ze[1]), Le(Ze[3]), Le(Ze[1]), Le(Ze[2]), Le(Ze[3])
            }

            function we(he) {
                r.push(l[he * 3 + 0]), r.push(l[he * 3 + 1]), r.push(l[he * 3 + 2])
            }

            function Le(he) {
                s.push(he.x), s.push(he.y)
            }
        }
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes,
            i = this.parameters.options;
        return iH(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new w_[r.type]().fromJSON(r)), new Ed(i, e.options)
    }
}
const nH = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3],
            o = e[t * 3 + 1],
            a = e[i * 3],
            l = e[i * 3 + 1],
            c = e[r * 3],
            d = e[r * 3 + 1];
        return [new me(s, o), new me(a, l), new me(c, d)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[i * 3],
            d = e[i * 3 + 1],
            h = e[i * 3 + 2],
            p = e[r * 3],
            m = e[r * 3 + 1],
            v = e[r * 3 + 2],
            y = e[s * 3],
            A = e[s * 3 + 1],
            x = e[s * 3 + 2];
        return Math.abs(a - d) < Math.abs(o - c) ? [new me(o, 1 - l), new me(c, 1 - h), new me(p, 1 - v), new me(y, 1 - x)] : [new me(a, 1 - l), new me(d, 1 - h), new me(m, 1 - v), new me(A, 1 - x)]
    }
};

function iH(n, e, t) {
    if (t.shapes = [], Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        } else t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t
}
class bd extends Qs {
    constructor(e = 1, t = 0) {
        const i = (1 + Math.sqrt(5)) / 2,
            r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
            s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new bd(e.radius, e.detail)
    }
}
class Yu extends Qs {
    constructor(e = 1, t = 0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Yu(e.radius, e.detail)
    }
}
class Td extends ut {
    constructor(e = .5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
        super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        }, i = Math.max(3, i), r = Math.max(1, r);
        const a = [],
            l = [],
            c = [],
            d = [];
        let h = e;
        const p = (t - e) / r,
            m = new D,
            v = new me;
        for (let y = 0; y <= r; y++) {
            for (let A = 0; A <= i; A++) {
                const x = s + A / i * o;
                m.x = h * Math.cos(x), m.y = h * Math.sin(x), l.push(m.x, m.y, m.z), c.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, d.push(v.x, v.y)
            }
            h += p
        }
        for (let y = 0; y < r; y++) {
            const A = y * (i + 1);
            for (let x = 0; x < i; x++) {
                const _ = x + A,
                    S = _,
                    M = _ + i + 1,
                    b = _ + i + 2,
                    B = _ + 1;
                a.push(S, M, B), a.push(M, b, B)
            }
        }
        this.setIndex(a), this.setAttribute("position", new We(l, 3)), this.setAttribute("normal", new We(c, 3)), this.setAttribute("uv", new We(d, 2))
    }
    static fromJSON(e) {
        return new Td(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
    }
}
class Bd extends ut {
    constructor(e = new Ya([new me(0, .5), new me(-.5, -.5), new me(.5, -.5)]), t = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = [],
            r = [],
            s = [],
            o = [];
        let a = 0,
            l = 0;
        if (Array.isArray(e) === !1) c(e);
        else
            for (let d = 0; d < e.length; d++) c(e[d]), this.addGroup(a, l, d), a += l, l = 0;
        this.setIndex(i), this.setAttribute("position", new We(r, 3)), this.setAttribute("normal", new We(s, 3)), this.setAttribute("uv", new We(o, 2));

        function c(d) {
            const h = r.length / 3,
                p = d.extractPoints(t);
            let m = p.shape;
            const v = p.holes;
            ts.isClockWise(m) === !1 && (m = m.reverse());
            for (let A = 0, x = v.length; A < x; A++) {
                const _ = v[A];
                ts.isClockWise(_) === !0 && (v[A] = _.reverse())
            }
            const y = ts.triangulateShape(m, v);
            for (let A = 0, x = v.length; A < x; A++) {
                const _ = v[A];
                m = m.concat(_)
            }
            for (let A = 0, x = m.length; A < x; A++) {
                const _ = m[A];
                r.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y)
            }
            for (let A = 0, x = y.length; A < x; A++) {
                const _ = y[A],
                    S = _[0] + h,
                    M = _[1] + h,
                    b = _[2] + h;
                i.push(S, M, b), l += 3
            }
        }
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes;
        return rH(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new Bd(i, e.curveSegments)
    }
}

function rH(n, e) {
    if (e.shapes = [], Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        } else e.shapes.push(n.uuid);
    return e
}
class Zu extends ut {
    constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const d = [],
            h = new D,
            p = new D,
            m = [],
            v = [],
            y = [],
            A = [];
        for (let x = 0; x <= i; x++) {
            const _ = [],
                S = x / i;
            let M = 0;
            x == 0 && o == 0 ? M = .5 / t : x == i && l == Math.PI && (M = -.5 / t);
            for (let b = 0; b <= t; b++) {
                const B = b / t;
                h.x = -e * Math.cos(r + B * s) * Math.sin(o + S * a), h.y = e * Math.cos(o + S * a), h.z = e * Math.sin(r + B * s) * Math.sin(o + S * a), v.push(h.x, h.y, h.z), p.copy(h).normalize(), y.push(p.x, p.y, p.z), A.push(B + M, 1 - S), _.push(c++)
            }
            d.push(_)
        }
        for (let x = 0; x < i; x++)
            for (let _ = 0; _ < t; _++) {
                const S = d[x][_ + 1],
                    M = d[x][_],
                    b = d[x + 1][_],
                    B = d[x + 1][_ + 1];
                (x !== 0 || o > 0) && m.push(S, M, B), (x !== i - 1 || l < Math.PI) && m.push(M, b, B)
            }
        this.setIndex(m), this.setAttribute("position", new We(v, 3)), this.setAttribute("normal", new We(y, 3)), this.setAttribute("uv", new We(A, 2))
    }
    static fromJSON(e) {
        return new Zu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
    }
}
class Pd extends Qs {
    constructor(e = 1, t = 0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Pd(e.radius, e.detail)
    }
}
class Rd extends ut {
    constructor(e = 1, t = .4, i = 12, r = 48, s = Math.PI * 2) {
        super(), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        }, i = Math.floor(i), r = Math.floor(r);
        const o = [],
            a = [],
            l = [],
            c = [],
            d = new D,
            h = new D,
            p = new D;
        for (let m = 0; m <= i; m++)
            for (let v = 0; v <= r; v++) {
                const y = v / r * s,
                    A = m / i * Math.PI * 2;
                h.x = (e + t * Math.cos(A)) * Math.cos(y), h.y = (e + t * Math.cos(A)) * Math.sin(y), h.z = t * Math.sin(A), a.push(h.x, h.y, h.z), d.x = e * Math.cos(y), d.y = e * Math.sin(y), p.subVectors(h, d).normalize(), l.push(p.x, p.y, p.z), c.push(v / r), c.push(m / i)
            }
        for (let m = 1; m <= i; m++)
            for (let v = 1; v <= r; v++) {
                const y = (r + 1) * m + v - 1,
                    A = (r + 1) * (m - 1) + v - 1,
                    x = (r + 1) * (m - 1) + v,
                    _ = (r + 1) * m + v;
                o.push(y, A, _), o.push(A, x, _)
            }
        this.setIndex(o), this.setAttribute("position", new We(a, 3)), this.setAttribute("normal", new We(l, 3)), this.setAttribute("uv", new We(c, 2))
    }
    static fromJSON(e) {
        return new Rd(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
    }
}
class Id extends ut {
    constructor(e = 1, t = .4, i = 64, r = 8, s = 2, o = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        }, i = Math.floor(i), r = Math.floor(r);
        const a = [],
            l = [],
            c = [],
            d = [],
            h = new D,
            p = new D,
            m = new D,
            v = new D,
            y = new D,
            A = new D,
            x = new D;
        for (let S = 0; S <= i; ++S) {
            const M = S / i * s * Math.PI * 2;
            _(M, s, o, e, m), _(M + .01, s, o, e, v), A.subVectors(v, m), x.addVectors(v, m), y.crossVectors(A, x), x.crossVectors(y, A), y.normalize(), x.normalize();
            for (let b = 0; b <= r; ++b) {
                const B = b / r * Math.PI * 2,
                    R = -t * Math.cos(B),
                    E = t * Math.sin(B);
                h.x = m.x + (R * x.x + E * y.x), h.y = m.y + (R * x.y + E * y.y), h.z = m.z + (R * x.z + E * y.z), l.push(h.x, h.y, h.z), p.subVectors(h, m).normalize(), c.push(p.x, p.y, p.z), d.push(S / i), d.push(b / r)
            }
        }
        for (let S = 1; S <= i; S++)
            for (let M = 1; M <= r; M++) {
                const b = (r + 1) * (S - 1) + (M - 1),
                    B = (r + 1) * S + (M - 1),
                    R = (r + 1) * S + M,
                    E = (r + 1) * (S - 1) + M;
                a.push(b, B, E), a.push(B, R, E)
            }
        this.setIndex(a), this.setAttribute("position", new We(l, 3)), this.setAttribute("normal", new We(c, 3)), this.setAttribute("uv", new We(d, 2));

        function _(S, M, b, B, R) {
            const E = Math.cos(S),
                P = Math.sin(S),
                I = b / M * S,
                z = Math.cos(I);
            R.x = B * (2 + z) * .5 * E, R.y = B * (2 + z) * P * .5, R.z = B * Math.sin(I) * .5
        }
    }
    static fromJSON(e) {
        return new Id(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
    }
}
class Ld extends ut {
    constructor(e = new x_(new D(-1, -1, 0), new D(-1, 1, 0), new D(1, 1, 0)), t = 64, i = 1, r = 8, s = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        const a = new D,
            l = new D,
            c = new me;
        let d = new D;
        const h = [],
            p = [],
            m = [],
            v = [];
        y(), this.setIndex(v), this.setAttribute("position", new We(h, 3)), this.setAttribute("normal", new We(p, 3)), this.setAttribute("uv", new We(m, 2));

        function y() {
            for (let S = 0; S < t; S++) A(S);
            A(s === !1 ? t : 0), _(), x()
        }

        function A(S) {
            d = e.getPointAt(S / t, d);
            const M = o.normals[S],
                b = o.binormals[S];
            for (let B = 0; B <= r; B++) {
                const R = B / r * Math.PI * 2,
                    E = Math.sin(R),
                    P = -Math.cos(R);
                l.x = P * M.x + E * b.x, l.y = P * M.y + E * b.y, l.z = P * M.z + E * b.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = d.x + i * l.x, a.y = d.y + i * l.y, a.z = d.z + i * l.z, h.push(a.x, a.y, a.z)
            }
        }

        function x() {
            for (let S = 1; S <= t; S++)
                for (let M = 1; M <= r; M++) {
                    const b = (r + 1) * (S - 1) + (M - 1),
                        B = (r + 1) * S + (M - 1),
                        R = (r + 1) * S + M,
                        E = (r + 1) * (S - 1) + M;
                    v.push(b, B, E), v.push(B, R, E)
                }
        }

        function _() {
            for (let S = 0; S <= t; S++)
                for (let M = 0; M <= r; M++) c.x = S / t, c.y = M / r, m.push(c.x, c.y)
        }
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(), e
    }
    static fromJSON(e) {
        return new Ld(new w_[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
    }
}
class l3 extends ut {
    constructor(e = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: e
            }, e !== null) {
            const t = [],
                i = new Set,
                r = new D,
                s = new D;
            if (e.index !== null) {
                const o = e.attributes.position,
                    a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let c = 0, d = l.length; c < d; ++c) {
                    const h = l[c],
                        p = h.start,
                        m = h.count;
                    for (let v = p, y = p + m; v < y; v += 3)
                        for (let A = 0; A < 3; A++) {
                            const x = a.getX(v + A),
                                _ = a.getX(v + (A + 1) % 3);
                            r.fromBufferAttribute(o, x), s.fromBufferAttribute(o, _), gE(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let c = 0; c < 3; c++) {
                        const d = 3 * a + c,
                            h = 3 * a + (c + 1) % 3;
                        r.fromBufferAttribute(o, d), s.fromBufferAttribute(o, h), gE(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new We(t, 3))
        }
    }
}

function gE(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
        r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0)
}
var yE = Object.freeze({
    __proto__: null,
    BoxGeometry: qo,
    CapsuleGeometry: wd,
    CircleGeometry: Sd,
    ConeGeometry: Md,
    CylinderGeometry: ul,
    DodecahedronGeometry: Cd,
    EdgesGeometry: r3,
    ExtrudeGeometry: Ed,
    IcosahedronGeometry: bd,
    LatheGeometry: Ku,
    OctahedronGeometry: Yu,
    PlaneGeometry: Xu,
    PolyhedronGeometry: Qs,
    RingGeometry: Td,
    ShapeGeometry: Bd,
    SphereGeometry: Zu,
    TetrahedronGeometry: Pd,
    TorusGeometry: Rd,
    TorusKnotGeometry: Id,
    TubeGeometry: Ld,
    WireframeGeometry: l3
});
class u3 extends wn {
    constructor(e) {
        super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Ie(0), this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
    }
}
class c3 extends os {
    constructor(e) {
        super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
    }
}
class qu extends wn {
    constructor(e) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Ie(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xs, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class Ks extends qu {
    constructor(e) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new me(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return gn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ie(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ie(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ie(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
    }
}
class f3 extends wn {
    constructor(e) {
        super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Ie(16777215), this.specular = new Ie(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xs, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = md, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class d3 extends wn {
    constructor(e) {
        super(), this.isMeshToonMaterial = !0, this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new Ie(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xs, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
class h3 extends wn {
    constructor(e) {
        super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xs, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
    }
}
class p3 extends wn {
    constructor(e) {
        super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Ie(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xs, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = md, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class m3 extends wn {
    constructor(e) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new Ie(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xs, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class g3 extends ei {
    constructor(e) {
        super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    }
}

function or(n, e, t) {
    return S_(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t)
}

function za(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}

function S_(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}

function y3(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length,
        i = new Array(t);
    for (let r = 0; r !== t; ++r) i[r] = r;
    return i.sort(e), i
}

function gx(n, e, t) {
    const i = n.length,
        r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l) r[o++] = n[a + l]
    }
    return r
}

function M_(n, e, t, i) {
    let r = 1,
        s = n[0];
    for (; s !== void 0 && s[i] === void 0;) s = n[r++];
    if (s === void 0) return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++]; while (s !== void 0);
        else if (o.toArray !== void 0)
        do o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++]; while (s !== void 0);
    else
        do o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++]; while (s !== void 0)
}

function sH(n, e, t, i, r = 30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const c = s.tracks[l],
            d = c.getValueSize(),
            h = [],
            p = [];
        for (let m = 0; m < c.times.length; ++m) {
            const v = c.times[m] * r;
            if (!(v < t || v >= i)) {
                h.push(c.times[m]);
                for (let y = 0; y < d; ++y) p.push(c.values[m * d + y])
            }
        }
        h.length !== 0 && (c.times = za(h, c.times.constructor), c.values = za(p, c.values.constructor), o.push(c))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
    return s.resetDuration(), s
}

function oH(n, e = 0, t = n, i = 30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length,
        s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o],
            l = a.ValueTypeName;
        if (l === "bool" || l === "string") continue;
        const c = n.tracks.find(function(x) {
            return x.name === a.name && x.ValueTypeName === l
        });
        if (c === void 0) continue;
        let d = 0;
        const h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3);
        let p = 0;
        const m = c.getValueSize();
        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
        const v = a.times.length - 1;
        let y;
        if (s <= a.times[0]) {
            const x = d,
                _ = h - d;
            y = or(a.values, x, _)
        } else if (s >= a.times[v]) {
            const x = v * h + d,
                _ = x + h - d;
            y = or(a.values, x, _)
        } else {
            const x = a.createInterpolant(),
                _ = d,
                S = h - d;
            x.evaluate(s), y = or(x.resultBuffer, _, S)
        }
        l === "quaternion" && new Hn().fromArray(y).normalize().conjugate().toArray(y);
        const A = c.times.length;
        for (let x = 0; x < A; ++x) {
            const _ = x * m + p;
            if (l === "quaternion") Hn.multiplyQuaternionsFlat(c.values, _, y, 0, c.values, _);
            else {
                const S = m - p * 2;
                for (let M = 0; M < S; ++M) c.values[_ + M] -= y[M]
            }
        }
    }
    return n.blendMode = Z1, n
}
var aH = Object.freeze({
    __proto__: null,
    arraySlice: or,
    convertArray: za,
    flattenJSON: M_,
    getKeyframeOrder: y3,
    isTypedArray: S_,
    makeClipAdditive: oH,
    sortedArray: gx,
    subclip: sH
});
class $u {
    constructor(e, t, i, r) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex,
            r = t[i],
            s = t[i - 1];
        e: {
            t: {
                let o;n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2;;) {
                            if (r === void 0) {
                                if (e < s) break i;
                                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                            }
                            if (i === a) break;
                            if (s = r, r = t[++i], e < r) break t
                        }
                        o = t.length;
                        break n
                    }if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2, s = a);
                        for (let l = i - 2;;) {
                            if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (i === l) break;
                            if (r = s, s = t[--i - 1], e >= s) break t
                        }
                        o = i, i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o;) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0,
                this.copySampleValue_(0);
                if (r === void 0) return i = t.length,
                this._cachedIndex = i,
                this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r;
        for (let o = 0; o !== r; ++o) t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class v3 extends $u {
    constructor(e, t, i, r) {
        super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Na,
            endingEnd: Na
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2,
            o = e + 1,
            a = r[s],
            l = r[o];
        if (a === void 0) switch (this.getSettings_().endingStart) {
            case Oa:
                s = e, a = 2 * t - i;
                break;
            case Jf:
                s = r.length - 2, a = t + r[s] - r[s + 1];
                break;
            default:
                s = e, a = i
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
            case Oa:
                o = e, l = 2 * i - t;
                break;
            case Jf:
                o = 1, l = i + r[1] - r[0];
                break;
            default:
                o = e - 1, l = t
        }
        const c = (i - t) * .5,
            d = this.valueSize;
        this._weightPrev = c / (t - a), this._weightNext = c / (l - i), this._offsetPrev = s * d, this._offsetNext = o * d
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            d = this._offsetPrev,
            h = this._offsetNext,
            p = this._weightPrev,
            m = this._weightNext,
            v = (i - t) / (r - t),
            y = v * v,
            A = y * v,
            x = -p * A + 2 * p * y - p * v,
            _ = (1 + p) * A + (-1.5 - 2 * p) * y + (-.5 + p) * v + 1,
            S = (-1 - m) * A + (1.5 + m) * y + .5 * v,
            M = m * A - m * y;
        for (let b = 0; b !== a; ++b) s[b] = x * o[d + b] + _ * o[c + b] + S * o[l + b] + M * o[h + b];
        return s
    }
}
class C_ extends $u {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            d = (i - t) / (r - t),
            h = 1 - d;
        for (let p = 0; p !== a; ++p) s[p] = o[c + p] * h + o[l + p] * d;
        return s
    }
}
class A3 extends $u {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class zr {
    constructor(e, t, i, r) {
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = za(t, this.TimeBufferType), this.values = za(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: za(e.times, Array),
                values: za(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName, i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new A3(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new C_(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new v3(this.times, this.values, this.getValueSize(), e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
            case Lu:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case il:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case cm:
                t = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this
        }
        return this.createInterpolant = t, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return Lu;
            case this.InterpolantFactoryMethodLinear:
                return il;
            case this.InterpolantFactoryMethodSmooth:
                return cm
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times,
            r = i.length;
        let s = 0,
            o = r - 1;
        for (; s !== r && i[s] < e;) ++s;
        for (; o !== -1 && i[o] > t;) --o;
        if (++o, s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            const a = this.getValueSize();
            this.times = or(i, s, o), this.values = or(this.values, s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        const i = this.times,
            r = this.values,
            s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
                break
            }
            o = l
        }
        if (r !== void 0 && S_(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
                const c = r[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = or(this.times),
            t = or(this.values),
            i = this.getValueSize(),
            r = this.getInterpolation() === cm,
            s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a],
                d = e[a + 1];
            if (c !== d && (a !== 1 || c !== e[0]))
                if (r) l = !0;
                else {
                    const h = a * i,
                        p = h - i,
                        m = h + i;
                    for (let v = 0; v !== i; ++v) {
                        const y = t[h + v];
                        if (y !== t[p + v] || y !== t[m + v]) {
                            l = !0;
                            break
                        }
                    }
                } if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i,
                        p = o * i;
                    for (let m = 0; m !== i; ++m) t[p + m] = t[h + m]
                }++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = or(e, 0, o), this.values = or(t, 0, o * i)) : (this.times = e, this.values = t), this
    }
    clone() {
        const e = or(this.times, 0),
            t = or(this.values, 0),
            i = this.constructor,
            r = new i(this.name, e, t);
        return r.createInterpolant = this.createInterpolant, r
    }
}
zr.prototype.TimeBufferType = Float32Array;
zr.prototype.ValueBufferType = Float32Array;
zr.prototype.DefaultInterpolation = il;
class cl extends zr {}
cl.prototype.ValueTypeName = "bool";
cl.prototype.ValueBufferType = Array;
cl.prototype.DefaultInterpolation = Lu;
cl.prototype.InterpolantFactoryMethodLinear = void 0;
cl.prototype.InterpolantFactoryMethodSmooth = void 0;
class E_ extends zr {}
E_.prototype.ValueTypeName = "color";
class Nu extends zr {}
Nu.prototype.ValueTypeName = "number";
class x3 extends $u {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (i - t) / (r - t);
        let c = e * a;
        for (let d = c + a; c !== d; c += 4) Hn.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class Wo extends zr {
    InterpolantFactoryMethodLinear(e) {
        return new x3(this.times, this.values, this.getValueSize(), e)
    }
}
Wo.prototype.ValueTypeName = "quaternion";
Wo.prototype.DefaultInterpolation = il;
Wo.prototype.InterpolantFactoryMethodSmooth = void 0;
class fl extends zr {}
fl.prototype.ValueTypeName = "string";
fl.prototype.ValueBufferType = Array;
fl.prototype.DefaultInterpolation = Lu;
fl.prototype.InterpolantFactoryMethodLinear = void 0;
fl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ou extends zr {}
Ou.prototype.ValueTypeName = "vector";
class Uu {
    constructor(e, t = -1, i, r = Tg) {
        this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Ui(), this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = [],
            i = e.tracks,
            r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o) t.push(uH(i[o]).scale(r));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return s.uuid = e.uuid, s
    }
    static toJSON(e) {
        const t = [],
            i = e.tracks,
            r = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
        for (let s = 0, o = i.length; s !== o; ++s) t.push(zr.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let l = [],
                c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            const d = y3(l);
            l = gx(l, 1, d), c = gx(c, 1, d), !r && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new Nu(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / i))
        }
        return new this(e, -1, o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t) return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                d = c.name.match(s);
            if (d && d.length > 1) {
                const h = d[1];
                let p = r[h];
                p || (r[h] = p = []), p.push(c)
            }
        }
        const o = [];
        for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function(h, p, m, v, y) {
                if (m.length !== 0) {
                    const A = [],
                        x = [];
                    M_(m, A, x, v), A.length !== 0 && y.push(new h(p, A, x))
                }
            },
            r = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let h = 0; h < c.length; h++) {
            const p = c[h].keys;
            if (!(!p || p.length === 0))
                if (p[0].morphTargets) {
                    const m = {};
                    let v;
                    for (v = 0; v < p.length; v++)
                        if (p[v].morphTargets)
                            for (let y = 0; y < p[v].morphTargets.length; y++) m[p[v].morphTargets[y]] = -1;
                    for (const y in m) {
                        const A = [],
                            x = [];
                        for (let _ = 0; _ !== p[v].morphTargets.length; ++_) {
                            const S = p[v];
                            A.push(S.time), x.push(S.morphTarget === y ? 1 : 0)
                        }
                        r.push(new Nu(".morphTargetInfluence[" + y + "]", A, x))
                    }
                    l = m.length * o
                } else {
                    const m = ".bones[" + t[h].name + "]";
                    i(Ou, m + ".position", p, "pos", r), i(Wo, m + ".quaternion", p, "rot", r), i(Ou, m + ".scale", p, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s, l, r, a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t, this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function lH(n) {
    switch (n.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Nu;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Ou;
        case "color":
            return E_;
        case "quaternion":
            return Wo;
        case "bool":
        case "boolean":
            return cl;
        case "string":
            return fl
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}

function uH(n) {
    if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = lH(n.type);
    if (n.times === void 0) {
        const t = [],
            i = [];
        M_(n.keys, t, i, "value"), n.times = t, n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation)
}
const sl = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1) return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class b_ {
    constructor(e, t, i) {
        const r = this;
        let s = !1,
            o = 0,
            a = 0,
            l;
        const c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(d) {
            a++, s === !1 && r.onStart !== void 0 && r.onStart(d, o, a), s = !0
        }, this.itemEnd = function(d) {
            o++, r.onProgress !== void 0 && r.onProgress(d, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad())
        }, this.itemError = function(d) {
            r.onError !== void 0 && r.onError(d)
        }, this.resolveURL = function(d) {
            return l ? l(d) : d
        }, this.setURLModifier = function(d) {
            return l = d, this
        }, this.addHandler = function(d, h) {
            return c.push(d, h), this
        }, this.removeHandler = function(d) {
            const h = c.indexOf(d);
            return h !== -1 && c.splice(h, 2), this
        }, this.getHandler = function(d) {
            for (let h = 0, p = c.length; h < p; h += 2) {
                const m = c[h],
                    v = c[h + 1];
                if (m.global && (m.lastIndex = 0), m.test(d)) return v
            }
            return null
        }
    }
}
const fu = new b_;
class hi {
    constructor(e) {
        this.manager = e !== void 0 ? e : fu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        })
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e, this
    }
    setWithCredentials(e) {
        return this.withCredentials = e, this
    }
    setPath(e) {
        return this.path = e, this
    }
    setResourcePath(e) {
        return this.resourcePath = e, this
    }
    setRequestHeader(e) {
        return this.requestHeader = e, this
    }
}
const Ss = {};
class cH extends Error {
    constructor(e, t) {
        super(e), this.response = t
    }
}
class Gi extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = sl.get(e);
        if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            t && t(s), this.manager.itemEnd(e)
        }, 0), s;
        if (Ss[e] !== void 0) {
            Ss[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        Ss[e] = [], Ss[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            a = this.mimeType,
            l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                const d = Ss[e],
                    h = c.body.getReader(),
                    p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
                    m = p ? parseInt(p) : 0,
                    v = m !== 0;
                let y = 0;
                const A = new ReadableStream({
                    start(x) {
                        _();

                        function _() {
                            h.read().then(({
                                done: S,
                                value: M
                            }) => {
                                if (S) x.close();
                                else {
                                    y += M.byteLength;
                                    const b = new ProgressEvent("progress", {
                                        lengthComputable: v,
                                        loaded: y,
                                        total: m
                                    });
                                    for (let B = 0, R = d.length; B < R; B++) {
                                        const E = d[B];
                                        E.onProgress && E.onProgress(b)
                                    }
                                    x.enqueue(M), _()
                                }
                            })
                        }
                    }
                });
                return new Response(A)
            } else throw new cH(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
        }).then(c => {
            switch (l) {
                case "arraybuffer":
                    return c.arrayBuffer();
                case "blob":
                    return c.blob();
                case "document":
                    return c.text().then(d => new DOMParser().parseFromString(d, a));
                case "json":
                    return c.json();
                default:
                    if (a === void 0) return c.text(); {
                        const h = /charset="?([^;"\s]*)"?/i.exec(a),
                            p = h && h[1] ? h[1].toLowerCase() : void 0,
                            m = new TextDecoder(p);
                        return c.arrayBuffer().then(v => m.decode(v))
                    }
            }
        }).then(c => {
            sl.add(e, c);
            const d = Ss[e];
            delete Ss[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onLoad && m.onLoad(c)
            }
        }).catch(c => {
            const d = Ss[e];
            if (d === void 0) throw this.manager.itemError(e), c;
            delete Ss[e];
            for (let h = 0, p = d.length; h < p; h++) {
                const m = d[h];
                m.onError && m.onError(c)
            }
            this.manager.itemError(e)
        }).finally(() => {
            this.manager.itemEnd(e)
        }), this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e, this
    }
    setMimeType(e) {
        return this.mimeType = e, this
    }
}
class fH extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = new Gi(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = Uu.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class dH extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = [],
            a = new g_,
            l = new Gi(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
        let c = 0;

        function d(h) {
            l.load(e[h], function(p) {
                const m = s.parse(p, !0);
                o[h] = {
                    width: m.width,
                    height: m.height,
                    format: m.format,
                    mipmaps: m.mipmaps
                }, c += 1, c === 6 && (m.mipmapCount === 1 && (a.minFilter = en), a.image = o, a.format = m.format, a.needsUpdate = !0, t && t(a))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let h = 0, p = e.length; h < p; ++h) d(h);
        else l.load(e, function(h) {
            const p = s.parse(h, !0);
            if (p.isCubemap) {
                const m = p.mipmaps.length / p.mipmapCount;
                for (let v = 0; v < m; v++) {
                    o[v] = {
                        mipmaps: []
                    };
                    for (let y = 0; y < p.mipmapCount; y++) o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + y]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height
                }
                a.image = o
            } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps;
            p.mipmapCount === 1 && (a.minFilter = en), a.format = p.format, a.needsUpdate = !0, t && t(a)
        }, i, r);
        return a
    }
}
class ed extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = sl.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            t && t(o), s.manager.itemEnd(e)
        }, 0), o;
        const a = Kf("img");

        function l() {
            d(), sl.add(e, this), t && t(this), s.manager.itemEnd(e)
        }

        function c(h) {
            d(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e)
        }

        function d() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
    }
}
class hH extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new vd,
            o = new ed(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;

        function l(c) {
            o.load(e[c], function(d) {
                s.images[c] = d, a++, a === 6 && (s.needsUpdate = !0, t && t(s))
            }, void 0, r)
        }
        for (let c = 0; c < e.length; ++c) l(c);
        return s
    }
}
class pH extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = new wu,
            a = new Gi(this.manager);
        return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
            const c = s.parse(l);
            c && (c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : zn, o.wrapT = c.wrapT !== void 0 ? c.wrapT : zn, o.magFilter = c.magFilter !== void 0 ? c.magFilter : en, o.minFilter = c.minFilter !== void 0 ? c.minFilter : en, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (o.encoding = c.encoding), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = ss), c.mipmapCount === 1 && (o.minFilter = en), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c))
        }, i, r), o
    }
}
class Dd extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new Yt,
            o = new ed(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
            s.image = a, s.needsUpdate = !0, t !== void 0 && t(s)
        }, i, r), s
    }
}
class $o extends Tt {
    constructor(e, t = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new Ie(e), this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
    }
}
class _3 extends $o {
    constructor(e, t, i) {
        super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Tt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Ie(t)
    }
    copy(e, t) {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this
    }
}
const ov = new rt,
    vE = new D,
    AE = new D;
class T_ {
    constructor(e) {
        this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new me(512, 512), this.map = null, this.mapPass = null, this.matrix = new rt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Pg, this._frameExtents = new me(1, 1), this._viewportCount = 1, this._viewports = [new kt(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera,
            i = this.matrix;
        vE.setFromMatrixPosition(e.matrixWorld), t.position.copy(vE), AE.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(AE), t.updateMatrixWorld(), ov.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ov), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(ov)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
    }
}
class mH extends T_ {
    constructor() {
        super(new Gt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera,
            i = Qf * 2 * e.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e), this.focus = e.focus, this
    }
}
class B_ extends $o {
    constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
        super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Tt.DEFAULT_UP), this.updateMatrix(), this.target = new Tt, this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new mH
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
const xE = new rt,
    Gc = new D,
    av = new D;
class gH extends T_ {
    constructor() {
        super(new Gt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new me(4, 2), this._viewportCount = 6, this._viewports = [new kt(2, 1, 1, 1), new kt(0, 1, 1, 1), new kt(3, 1, 1, 1), new kt(1, 1, 1, 1), new kt(3, 0, 1, 1), new kt(1, 0, 1, 1)], this._cubeDirections = [new D(1, 0, 0), new D(-1, 0, 0), new D(0, 0, 1), new D(0, 0, -1), new D(0, 1, 0), new D(0, -1, 0)], this._cubeUps = [new D(0, 1, 0), new D(0, 1, 0), new D(0, 1, 0), new D(0, 1, 0), new D(0, 0, 1), new D(0, 0, -1)]
    }
    updateMatrices(e, t = 0) {
        const i = this.camera,
            r = this.matrix,
            s = e.distance || i.far;
        s !== i.far && (i.far = s, i.updateProjectionMatrix()), Gc.setFromMatrixPosition(e.matrixWorld), i.position.copy(Gc), av.copy(i.position), av.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(av), i.updateMatrixWorld(), r.makeTranslation(-Gc.x, -Gc.y, -Gc.z), xE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(xE)
    }
}
class P_ extends $o {
    constructor(e, t, i = 0, r = 2) {
        super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new gH
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
    }
}
class yH extends T_ {
    constructor() {
        super(new Fr(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class R_ extends $o {
    constructor(e, t) {
        super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Tt.DEFAULT_UP), this.updateMatrix(), this.target = new Tt, this.shadow = new yH
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
class w3 extends $o {
    constructor(e, t) {
        super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}
class S3 extends $o {
    constructor(e, t, i = 10, r = 10) {
        super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e), this.width = e.width, this.height = e.height, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width, t.object.height = this.height, t
    }
}
class M3 {
    constructor() {
        this.isSphericalHarmonics3 = !0, this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new D)
    }
    set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], .546274 * (i * i - r * r)), t
    }
    getIrradianceAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z,
            o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * r), t.addScaledVector(o[2], 2 * .511664 * s), t.addScaledVector(o[3], 2 * .511664 * i), t.addScaledVector(o[4], 2 * .429043 * i * r), t.addScaledVector(o[5], 2 * .429043 * r * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 2 * .429043 * i * s), t.addScaledVector(o[8], .429043 * (i * i - r * r)), t
    }
    add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t = 0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e = [], t = 0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x,
            r = e.y,
            s = e.z;
        t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * s, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = .546274 * (i * i - r * r)
    }
}
class Og extends $o {
    constructor(e = new M3, t = 1) {
        super(void 0, t), this.isLightProbe = !0, this.sh = e
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this
    }
    fromJSON(e) {
        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(), t
    }
}
class Ug extends hi {
    constructor(e) {
        super(e), this.textures = {}
    }
    load(e, t, i, r) {
        const s = this,
            o = new Gi(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;

        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s]
        }
        const r = Ug.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Ie().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {}, o.type) {
                    case "t":
                        r.uniforms[s].value = i(o.value);
                        break;
                    case "c":
                        r.uniforms[s].value = new Ie().setHex(o.value);
                        break;
                    case "v2":
                        r.uniforms[s].value = new me().fromArray(o.value);
                        break;
                    case "v3":
                        r.uniforms[s].value = new D().fromArray(o.value);
                        break;
                    case "v4":
                        r.uniforms[s].value = new kt().fromArray(o.value);
                        break;
                    case "m3":
                        r.uniforms[s].value = new li().fromArray(o.value);
                        break;
                    case "m4":
                        r.uniforms[s].value = new rt().fromArray(o.value);
                        break;
                    default:
                        r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
            for (const s in e.extensions) r.extensions[s] = e.extensions[s];
        if (e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new me().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new me().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r
    }
    setTextures(e) {
        return this.textures = e, this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: u3,
            SpriteMaterial: d_,
            RawShaderMaterial: c3,
            ShaderMaterial: os,
            PointsMaterial: _d,
            MeshPhysicalMaterial: Ks,
            MeshStandardMaterial: qu,
            MeshPhongMaterial: f3,
            MeshToonMaterial: d3,
            MeshNormalMaterial: h3,
            MeshLambertMaterial: p3,
            MeshDepthMaterial: l_,
            MeshDistanceMaterial: u_,
            MeshBasicMaterial: Ni,
            MeshMatcapMaterial: m3,
            LineDashedMaterial: g3,
            LineBasicMaterial: ei,
            Material: wn
        };
        return new t[e]
    }
}
class ns {
    static decodeText(e) {
        if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class C3 extends ut {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e), this.instanceCount = e.instanceCount, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
    }
}
class E3 extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = new Gi(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {},
            i = {};

        function r(m, v) {
            if (t[v] !== void 0) return t[v];
            const A = m.interleavedBuffers[v],
                x = s(m, A.buffer),
                _ = lu(A.type, x),
                S = new Ad(_, A.stride);
            return S.uuid = A.uuid, t[v] = S, S
        }

        function s(m, v) {
            if (i[v] !== void 0) return i[v];
            const A = m.arrayBuffers[v],
                x = new Uint32Array(A).buffer;
            return i[v] = x, x
        }
        const o = e.isInstancedBufferGeometry ? new C3 : new ut,
            a = e.data.index;
        if (a !== void 0) {
            const m = lu(a.type, a.array);
            o.setIndex(new Dt(m, 1))
        }
        const l = e.data.attributes;
        for (const m in l) {
            const v = l[m];
            let y;
            if (v.isInterleavedBufferAttribute) {
                const A = r(e.data, v.data);
                y = new Vo(A, v.itemSize, v.offset, v.normalized)
            } else {
                const A = lu(v.type, v.array),
                    x = v.isInstancedBufferAttribute ? ku : Dt;
                y = new x(A, v.itemSize, v.normalized)
            }
            v.name !== void 0 && (y.name = v.name), v.usage !== void 0 && y.setUsage(v.usage), v.updateRange !== void 0 && (y.updateRange.offset = v.updateRange.offset, y.updateRange.count = v.updateRange.count), o.setAttribute(m, y)
        }
        const c = e.data.morphAttributes;
        if (c)
            for (const m in c) {
                const v = c[m],
                    y = [];
                for (let A = 0, x = v.length; A < x; A++) {
                    const _ = v[A];
                    let S;
                    if (_.isInterleavedBufferAttribute) {
                        const M = r(e.data, _.data);
                        S = new Vo(M, _.itemSize, _.offset, _.normalized)
                    } else {
                        const M = lu(_.type, _.array);
                        S = new Dt(M, _.itemSize, _.normalized)
                    }
                    _.name !== void 0 && (S.name = _.name), y.push(S)
                }
                o.morphAttributes[m] = y
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let m = 0, v = h.length; m !== v; ++m) {
                const y = h[m];
                o.addGroup(y.start, y.count, y.materialIndex)
            }
        const p = e.data.boundingSphere;
        if (p !== void 0) {
            const m = new D;
            p.center !== void 0 && m.fromArray(p.center), o.boundingSphere = new Zo(m, p.radius)
        }
        return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    }
}
class vH extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = this.path === "" ? ns.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new Gi(this.manager);
        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (h) {
                r !== void 0 && r(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const d = c.metadata;
            if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(c, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this,
            r = this.path === "" ? ns.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new Gi(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t),
            a = JSON.parse(o),
            l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations),
            r = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, r),
            o = this.parseImages(e.images, function() {
                t !== void 0 && t(c)
            }),
            a = this.parseTextures(e.textures, o),
            l = this.parseMaterials(e.materials, a),
            c = this.parseObject(e.object, s, l, a, i),
            d = this.parseSkeletons(e.skeletons, c);
        if (this.bindSkeletons(c, d), t !== void 0) {
            let h = !1;
            for (const p in o)
                if (o[p].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                } h === !1 && t(c)
        }
        return c
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            r = this.parseGeometries(e.geometries, i),
            s = await this.parseImagesAsync(e.images),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            l = this.parseObject(e.object, r, a, o, t),
            c = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, c), l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new Ya().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {},
            r = {};
        if (t.traverse(function(s) {
                s.isBone && (r[s.uuid] = s)
            }), e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new xd().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new E3;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        a = r.parse(l);
                        break;
                    default:
                        l.type in yE ? a = yE[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {},
            r = {};
        if (e !== void 0) {
            const s = new Ug;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)), r[l.uuid] = i[l.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i],
                    s = Uu.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this,
            r = {};
        let s;

        function o(l) {
            return i.manager.itemStart(l), s.load(l, function() {
                i.manager.itemEnd(l)
            }, void 0, function() {
                i.manager.itemError(l), i.manager.itemEnd(l)
            })
        }

        function a(l) {
            if (typeof l == "string") {
                const c = l,
                    d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
                return o(d)
            } else return l.data ? {
                data: lu(l.type, l.data),
                width: l.width,
                height: l.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new b_(t);
            s = new ed(l), s.setCrossOrigin(this.crossOrigin);
            for (let c = 0, d = e.length; c < d; c++) {
                const h = e[c],
                    p = h.url;
                if (Array.isArray(p)) {
                    const m = [];
                    for (let v = 0, y = p.length; v < y; v++) {
                        const A = p[v],
                            x = a(A);
                        x !== null && (x instanceof HTMLImageElement ? m.push(x) : m.push(new wu(x.data, x.width, x.height)))
                    }
                    r[h.uuid] = new Ua(m)
                } else {
                    const m = a(h.url);
                    r[h.uuid] = new Ua(m)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this,
            i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o,
                    l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(l)
            } else return o.data ? {
                data: lu(o.type, o.data),
                width: o.width,
                height: o.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new ed(this.manager), r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o],
                    c = l.url;
                if (Array.isArray(c)) {
                    const d = [];
                    for (let h = 0, p = c.length; h < p; h++) {
                        const m = c[h],
                            v = await s(m);
                        v !== null && (v instanceof HTMLImageElement ? d.push(v) : d.push(new wu(v.data, v.width, v.height)))
                    }
                    i[l.uuid] = new Ua(d)
                } else {
                    const d = await s(l.url);
                    i[l.uuid] = new Ua(d)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image],
                    c = l.data;
                let d;
                Array.isArray(c) ? (d = new vd, c.length === 6 && (d.needsUpdate = !0)) : (c && c.data ? d = new wu : d = new Yt, c && (d.needsUpdate = !0)), d.source = l, d.uuid = a.uuid, a.name !== void 0 && (d.name = a.name), a.mapping !== void 0 && (d.mapping = i(a.mapping, AH)), a.offset !== void 0 && d.offset.fromArray(a.offset), a.repeat !== void 0 && d.repeat.fromArray(a.repeat), a.center !== void 0 && d.center.fromArray(a.center), a.rotation !== void 0 && (d.rotation = a.rotation), a.wrap !== void 0 && (d.wrapS = i(a.wrap[0], _E), d.wrapT = i(a.wrap[1], _E)), a.format !== void 0 && (d.format = a.format), a.type !== void 0 && (d.type = a.type), a.encoding !== void 0 && (d.encoding = a.encoding), a.minFilter !== void 0 && (d.minFilter = i(a.minFilter, wE)), a.magFilter !== void 0 && (d.magFilter = i(a.magFilter, wE)), a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy), a.flipY !== void 0 && (d.flipY = a.flipY), a.generateMipmaps !== void 0 && (d.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (d.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (d.userData = a.userData), r[a.uuid] = d
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;

        function a(p) {
            return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p]
        }

        function l(p) {
            if (p !== void 0) {
                if (Array.isArray(p)) {
                    const m = [];
                    for (let v = 0, y = p.length; v < y; v++) {
                        const A = p[v];
                        i[A] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", A), m.push(i[A])
                    }
                    return m
                }
                return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p]
            }
        }

        function c(p) {
            return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p]
        }
        let d, h;
        switch (e.type) {
            case "Scene":
                o = new f_, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Ie(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new Lg(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Ig(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
                break;
            case "PerspectiveCamera":
                o = new Gt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                o = new Fr(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                o = new w3(e.color, e.intensity);
                break;
            case "DirectionalLight":
                o = new R_(e.color, e.intensity);
                break;
            case "PointLight":
                o = new P_(e.color, e.intensity, e.distance, e.decay);
                break;
            case "RectAreaLight":
                o = new S3(e.color, e.intensity, e.width, e.height);
                break;
            case "SpotLight":
                o = new B_(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                break;
            case "HemisphereLight":
                o = new _3(e.color, e.groundColor, e.intensity);
                break;
            case "LightProbe":
                o = new Og().fromJSON(e);
                break;
            case "SkinnedMesh":
                d = a(e.geometry), h = l(e.material), o = new h_(d, h), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
                break;
            case "Mesh":
                d = a(e.geometry), h = l(e.material), o = new bn(d, h);
                break;
            case "InstancedMesh":
                d = a(e.geometry), h = l(e.material);
                const p = e.count,
                    m = e.instanceMatrix,
                    v = e.instanceColor;
                o = new qP(d, h, p), o.instanceMatrix = new ku(new Float32Array(m.array), 16), v !== void 0 && (o.instanceColor = new ku(new Float32Array(v.array), v.itemSize));
                break;
            case "LOD":
                o = new ZP;
                break;
            case "Line":
                o = new js(a(e.geometry), l(e.material));
                break;
            case "LineLoop":
                o = new p_(a(e.geometry), l(e.material));
                break;
            case "LineSegments":
                o = new Or(a(e.geometry), l(e.material));
                break;
            case "PointCloud":
            case "Points":
                o = new m_(a(e.geometry), l(e.material));
                break;
            case "Sprite":
                o = new YP(l(e.material));
                break;
            case "Group":
                o = new Ls;
                break;
            case "Bone":
                o = new Dg;
                break;
            default:
                o = new Tt
        }
        if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
            const p = e.children;
            for (let m = 0; m < p.length; m++) o.add(this.parseObject(p[m], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const p = e.animations;
            for (let m = 0; m < p.length; m++) {
                const v = p[m];
                o.animations.push(s[v])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const p = e.levels;
            for (let m = 0; m < p.length; m++) {
                const v = p[m],
                    y = o.getObjectByProperty("uuid", v.object);
                y !== void 0 && o.addLevel(y, v.distance, v.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
}
const AH = {
        UVMapping: Eg,
        CubeReflectionMapping: zo,
        CubeRefractionMapping: Go,
        EquirectangularReflectionMapping: Vf,
        EquirectangularRefractionMapping: Wf,
        CubeUVReflectionMapping: Ju
    },
    _E = {
        RepeatWrapping: Ho,
        ClampToEdgeWrapping: zn,
        MirroredRepeatWrapping: Ru
    },
    wE = {
        NearestFilter: fn,
        NearestMipmapNearestFilter: jf,
        NearestMipmapLinearFilter: _u,
        LinearFilter: en,
        LinearMipmapNearestFilter: bg,
        LinearMipmapLinearFilter: ss
    };
class b3 extends hi {
    constructor(e) {
        super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e, this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = sl.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            t && t(o), s.manager.itemEnd(e)
        }, 0), o;
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(l) {
            return l.blob()
        }).then(function(l) {
            return createImageBitmap(l, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(l) {
            sl.add(e, l), t && t(l), s.manager.itemEnd(e)
        }).catch(function(l) {
            r && r(l), s.manager.itemError(e), s.manager.itemEnd(e)
        }), s.manager.itemStart(e)
    }
}
let Rp;
class I_ {
    static getContext() {
        return Rp === void 0 && (Rp = new(window.AudioContext || window.webkitAudioContext)), Rp
    }
    static setContext(e) {
        Rp = e
    }
}
class xH extends hi {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this,
            o = new Gi(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
            try {
                const l = a.slice(0);
                I_.getContext().decodeAudioData(l, function(d) {
                    t(d)
                })
            } catch (l) {
                r ? r(l) : console.error(l), s.manager.itemError(e)
            }
        }, i, r)
    }
}
class _H extends Og {
    constructor(e, t, i = 1) {
        super(void 0, i), this.isHemisphereLightProbe = !0;
        const r = new Ie().set(e),
            s = new Ie().set(t),
            o = new D(r.r, r.g, r.b),
            a = new D(s.r, s.g, s.b),
            l = Math.sqrt(Math.PI),
            c = l * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
    }
}
class wH extends Og {
    constructor(e, t = 1) {
        super(void 0, t), this.isAmbientLightProbe = !0;
        const i = new Ie().set(e);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
const SE = new rt,
    ME = new rt,
    ma = new rt;
class SH {
    constructor() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Gt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Gt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ma.copy(e.projectionMatrix);
            const r = t.eyeSep / 2,
                s = r * t.near / t.focus,
                o = t.near * Math.tan(Xa * t.fov * .5) / t.zoom;
            let a, l;
            ME.elements[12] = -r, SE.elements[12] = r, a = -o * t.aspect + s, l = o * t.aspect + s, ma.elements[0] = 2 * t.near / (l - a), ma.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ma), a = -o * t.aspect - s, l = o * t.aspect - s, ma.elements[0] = 2 * t.near / (l - a), ma.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ma)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ME), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(SE)
    }
}
class L_ {
    constructor(e = !0) {
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    start() {
        this.startTime = CE(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }
    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const t = CE();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
        }
        return e
    }
}

function CE() {
    return (typeof performance > "u" ? Date : performance).now()
}
const ga = new D,
    EE = new Hn,
    MH = new D,
    ya = new D;
class CH extends Tt {
    constructor() {
        super(), this.type = "AudioListener", this.context = I_.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new L_
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
            i = this.up;
        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ga, EE, MH), ya.set(0, 0, -1).applyQuaternion(EE), t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(ga.x, r), t.positionY.linearRampToValueAtTime(ga.y, r), t.positionZ.linearRampToValueAtTime(ga.z, r), t.forwardX.linearRampToValueAtTime(ya.x, r), t.forwardY.linearRampToValueAtTime(ya.y, r), t.forwardZ.linearRampToValueAtTime(ya.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r)
        } else t.setPosition(ga.x, ga.y, ga.z), t.setOrientation(ya.x, ya.y, ya.z, i.x, i.y, i.z)
    }
}
class T3 extends Tt {
    constructor(e) {
        super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
    }
    setBuffer(e) {
        return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
    }
    setDetune(e) {
        if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
    }
    setLoopStart(e) {
        return this.loopStart = e, this
    }
    setLoopEnd(e) {
        return this.loopEnd = e, this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
}
const va = new D,
    bE = new Hn,
    EH = new D,
    Aa = new D;
class bH extends T3 {
    constructor(e) {
        super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e, this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e, this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e, this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e, this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
        this.matrixWorld.decompose(va, bE, EH), Aa.set(0, 0, 1).applyQuaternion(bE);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(va.x, i), t.positionY.linearRampToValueAtTime(va.y, i), t.positionZ.linearRampToValueAtTime(va.z, i), t.orientationX.linearRampToValueAtTime(Aa.x, i), t.orientationY.linearRampToValueAtTime(Aa.y, i), t.orientationZ.linearRampToValueAtTime(Aa.z, i)
        } else t.setPosition(va.x, va.y, va.z), t.setOrientation(Aa.x, Aa.y, Aa.z)
    }
}
class TH {
    constructor(e, t = 2048) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++) e += t[i];
        return e / t.length
    }
}
class B3 {
    constructor(e, t, i) {
        this.binding = e, this.valueSize = i;
        let r, s, o;
        switch (t) {
            case "quaternion":
                r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
                break;
            default:
                r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer,
            r = this.valueSize,
            s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a) i[s + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer,
            i = this.valueSize,
            r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize,
            i = this.buffer,
            r = e * t + t,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(i, r, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (i[l] !== i[l + t]) {
                a.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding,
            t = this.buffer,
            i = this.valueSize,
            r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s) t[s] = t[r + s % i];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
        for (let i = e; i < t; i++) this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o) e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        Hn.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        Hn.multiplyQuaternionsFlat(e, o, e, t, e, i), Hn.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r
        }
    }
}
const D_ = "\\[\\]\\.:\\/",
    BH = new RegExp("[" + D_ + "]", "g"),
    F_ = "[^" + D_ + "]",
    PH = "[^" + D_.replace("\\.", "") + "]",
    RH = /((?:WC+[\/:])*)/.source.replace("WC", F_),
    IH = /(WCOD+)?/.source.replace("WCOD", PH),
    LH = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", F_),
    DH = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", F_),
    FH = new RegExp("^" + RH + IH + LH + DH + "$"),
    kH = ["material", "materials", "bones", "map"];
class NH {
    constructor(e, t, i) {
        const r = i || bt.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_,
            r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
    }
}
class bt {
    constructor(e, t, i) {
        this.path = t, this.parsedPath = i || bt.parseTrackName(t), this.node = bt.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new bt.Composite(e, t, i) : new bt(e, t, i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(BH, "")
    }
    static parseTrackName(e) {
        const t = FH.exec(e);
        if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            },
            r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            kH.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i
        }
        if (e.children) {
            const i = function(s) {
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (a.name === t || a.uuid === t) return a;
                        const l = i(a.children);
                        if (l) return l
                    }
                    return null
                },
                r = i(e.children);
            if (r) return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath,
            i = t.objectName,
            r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = bt.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
                case "materials":
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    e = e.skeleton.bones;
                    for (let d = 0; d < e.length; d++)
                        if (e[d].name === c) {
                            c = d;
                            break
                        } break;
                case "map":
                    if ("map" in e) {
                        e = e.map;
                        break
                    }
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[i] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
bt.Composite = NH;
bt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
bt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
bt.prototype.GetterByBindingType = [bt.prototype._getValue_direct, bt.prototype._getValue_array, bt.prototype._getValue_arrayElement, bt.prototype._getValue_toArray];
bt.prototype.SetterByBindingTypeAndVersioning = [
    [bt.prototype._setValue_direct, bt.prototype._setValue_direct_setNeedsUpdate, bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [bt.prototype._setValue_array, bt.prototype._setValue_array_setNeedsUpdate, bt.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [bt.prototype._setValue_arrayElement, bt.prototype._setValue_arrayElement_setNeedsUpdate, bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [bt.prototype._setValue_fromArray, bt.prototype._setValue_fromArray_setNeedsUpdate, bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class OH {
    constructor() {
        this.isAnimationObjectGroup = !0, this.uuid = Ui(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i) e[arguments[i].uuid] = i;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects,
            t = this._indicesByUUID,
            i = this._paths,
            r = this._parsedPaths,
            s = this._bindings,
            o = s.length;
        let a, l = e.length,
            c = this.nCachedObjects_;
        for (let d = 0, h = arguments.length; d !== h; ++d) {
            const p = arguments[d],
                m = p.uuid;
            let v = t[m];
            if (v === void 0) {
                v = l++, t[m] = v, e.push(p);
                for (let y = 0, A = o; y !== A; ++y) s[y].push(new bt(p, i[y], r[y]))
            } else if (v < c) {
                a = e[v];
                const y = --c,
                    A = e[y];
                t[A.uuid] = v, e[v] = A, t[m] = y, e[y] = p;
                for (let x = 0, _ = o; x !== _; ++x) {
                    const S = s[x],
                        M = S[y];
                    let b = S[v];
                    S[v] = M, b === void 0 && (b = new bt(p, i[x], r[x])), S[y] = b
                }
            } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    }
    remove() {
        const e = this._objects,
            t = this._indicesByUUID,
            i = this._bindings,
            r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o],
                c = l.uuid,
                d = t[c];
            if (d !== void 0 && d >= s) {
                const h = s++,
                    p = e[h];
                t[p.uuid] = d, e[d] = p, t[c] = h, e[h] = l;
                for (let m = 0, v = r; m !== v; ++m) {
                    const y = i[m],
                        A = y[h],
                        x = y[d];
                    y[d] = A, y[h] = x
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects,
            t = this._indicesByUUID,
            i = this._bindings,
            r = i.length;
        let s = this.nCachedObjects_,
            o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a],
                d = c.uuid,
                h = t[d];
            if (h !== void 0)
                if (delete t[d], h < s) {
                    const p = --s,
                        m = e[p],
                        v = --o,
                        y = e[v];
                    t[m.uuid] = h, e[h] = m, t[y.uuid] = p, e[p] = y, e.pop();
                    for (let A = 0, x = r; A !== x; ++A) {
                        const _ = i[A],
                            S = _[p],
                            M = _[v];
                        _[h] = S, _[p] = M, _.pop()
                    }
                } else {
                    const p = --o,
                        m = e[p];
                    p > 0 && (t[m.uuid] = h), e[h] = m, e.pop();
                    for (let v = 0, y = r; v !== y; ++v) {
                        const A = i[v];
                        A[h] = A[p], A.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0) return s[r];
        const o = this._paths,
            a = this._parsedPaths,
            l = this._objects,
            c = l.length,
            d = this.nCachedObjects_,
            h = new Array(c);
        r = s.length, i[e] = r, o.push(e), a.push(t), s.push(h);
        for (let p = d, m = l.length; p !== m; ++p) {
            const v = l[p];
            h[p] = new bt(v, e, t)
        }
        return h
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
            i = t[e];
        if (i !== void 0) {
            const r = this._paths,
                s = this._parsedPaths,
                o = this._bindings,
                a = o.length - 1,
                l = o[a],
                c = e[a];
            t[c] = i, o[i] = l, o.pop(), s[i] = s[a], s.pop(), r[i] = r[a], r.pop()
        }
    }
}
class UH {
    constructor(e, t, i = null, r = t.blendMode) {
        this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r;
        const s = t.tracks,
            o = s.length,
            a = new Array(o),
            l = {
                endingStart: Na,
                endingEnd: Na
            };
        for (let c = 0; c !== o; ++c) {
            const d = s[c].createInterpolant(null);
            a[c] = d, d.settings = l
        }
        this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = TP, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this), this
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset()
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e, this
    }
    setLoop(e, t) {
        return this.loop = e, this.repetitions = t, this
    }
    setEffectiveWeight(e) {
        return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t), this.fadeIn(t), i) {
            const r = this._clip.duration,
                s = e._clip.duration,
                o = s / r,
                a = r / s;
            e.warp(1, o, t), this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e, this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer,
            s = r.time,
            o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
        const l = a.parameterPositions,
            c = a.sampleValues;
        return l[0] = s, l[1] = s + i, c[0] = e / o, c[1] = t / o, this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * i;
            l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t),
            a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants,
                c = this._propertyBindings;
            switch (this.blendMode) {
                case Z1:
                    for (let d = 0, h = l.length; d !== h; ++d) l[d].evaluate(o), c[d].accumulateAdditive(a);
                    break;
                case Tg:
                default:
                    for (let d = 0, h = l.length; d !== h; ++d) l[d].evaluate(o), c[d].accumulate(r, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t, t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t, t
    }
    _updateTime(e) {
        const t = this._clip.duration,
            i = this.loop;
        let r = this.time + e,
            s = this._loopCount;
        const o = i === BP;
        if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === bP) {
            s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
                if (r >= t) r = t;
                else if (r < 0) r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) {
                const a = Math.floor(r / t);
                r -= t * a, s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1
                });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else this._setEndings(!1, !1, o);
                    this._loopCount = s, this.time = r, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else this.time = r;
            if (o && (s & 1) === 1) return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = Oa, r.endingEnd = Oa) : (e ? r.endingStart = this.zeroSlopeAtStart ? Oa : Na : r.endingStart = Jf, t ? r.endingEnd = this.zeroSlopeAtEnd ? Oa : Na : r.endingEnd = Jf)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer,
            s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
        const a = o.parameterPositions,
            l = o.sampleValues;
        return a[0] = s, l[0] = t, a[1] = s + e, l[1] = i, this
    }
}
const zH = new Float32Array(1);
class GH extends as {
    constructor(e) {
        super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root,
            r = e._clip.tracks,
            s = r.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = i.uuid,
            c = this._bindingsByRootAndName;
        let d = c[l];
        d === void 0 && (d = {}, c[l] = d);
        for (let h = 0; h !== s; ++h) {
            const p = r[h],
                m = p.name;
            let v = d[m];
            if (v !== void 0) ++v.referenceCount, o[h] = v;
            else {
                if (v = o[h], v !== void 0) {
                    v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, m));
                    continue
                }
                const y = t && t._propertyBindings[h].binding.parsedPath;
                v = new B3(bt.create(i, m, y), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, m), o[h] = v
            }
            a[h].resultBuffer = v.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid,
                    r = e._clip.uuid,
                    s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions,
            s = this._actionsByClip;
        let o = s[t];
        if (o === void 0) o = {
            knownActions: [e],
            actionByRoot: {}
        }, e._byClipCacheIndex = 0, s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length, a.push(e)
        }
        e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions,
            i = t[t.length - 1],
            r = e._cacheIndex;
        i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null;
        const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            l = a.knownActions,
            c = l[l.length - 1],
            d = e._byClipCacheIndex;
        c._byClipCacheIndex = d, l[d] = c, l.pop(), e._byClipCacheIndex = null;
        const h = a.actionByRoot,
            p = (e._localRoot || this._root).uuid;
        delete h[p], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions,
            i = e._cacheIndex,
            r = this._nActiveActions++,
            s = t[r];
        e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions,
            i = e._cacheIndex,
            r = --this._nActiveActions,
            s = t[r];
        e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName,
            s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings,
            i = e.binding,
            r = i.rootNode.uuid,
            s = i.path,
            o = this._bindingsByRootAndName,
            a = o[r],
            l = t[t.length - 1],
            c = e._cacheIndex;
        l._cacheIndex = c, t[c] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings,
            i = e._cacheIndex,
            r = this._nActiveBindings++,
            s = t[r];
        e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings,
            i = e._cacheIndex,
            r = --this._nActiveBindings,
            s = t[r];
        e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new C_(new Float32Array(2), new Float32Array(2), 1, zH), i.__cacheIndex = t, e[t] = i), i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
            i = e.__cacheIndex,
            r = --this._nActiveControlInterpolants,
            s = t[r];
        e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root,
            s = r.uuid;
        let o = typeof e == "string" ? Uu.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
        let c = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = Tg), l !== void 0) {
            const h = l.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i) return h;
            c = l.knownActions[0], o === null && (o = c._clip)
        }
        if (o === null) return null;
        const d = new UH(this, o, t, i);
        return this._bindAction(d, c), this._addInactiveAction(d, a, s), d
    }
    existingAction(e, t) {
        const i = t || this._root,
            r = i.uuid,
            s = typeof e == "string" ? Uu.findByName(i, e) : e,
            o = s ? s.uuid : e,
            a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions,
            t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i) e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions,
            i = this._nActiveActions,
            r = this.time += e,
            s = Math.sign(e),
            o = this._accuIndex ^= 1;
        for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, o);
        const a = this._bindings,
            l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c) a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions,
            i = e.uuid,
            r = this._actionsByClip,
            s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const d = c._cacheIndex,
                    h = t[t.length - 1];
                c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = d, t[d] = h, t.pop(), this._removeInactiveBindingsForAction(c)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid,
            i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot,
                l = a[t];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
        }
        const r = this._bindingsByRootAndName,
            s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(), this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i), this._removeInactiveAction(i))
    }
}
class k_ {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new k_(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let HH = 0;
class VH extends as {
    constructor() {
        super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
            value: HH++
        }), this.name = "", this.usage = Xf, this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e), this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1), this
    }
    setName(e) {
        return this.name = e, this
    }
    setUsage(e) {
        return this.usage = e, this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }), this
    }
    copy(e) {
        this.name = e.name, this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++) this.uniforms.push(t[i].clone());
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class WH extends Ad {
    constructor(e, t, i = 1) {
        super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute, t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
    }
}
class jH {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = s, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e, this
    }
    setType(e, t) {
        return this.type = e, this.elementSize = t, this
    }
    setItemSize(e) {
        return this.itemSize = e, this
    }
    setCount(e) {
        return this.count = e, this
    }
}
class P3 {
    constructor(e, t, i = 0, r = 1 / 0) {
        this.ray = new gd(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Ka, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t = !0, i = []) {
        return yx(e, this, i, t), i.sort(TE), i
    }
    intersectObjects(e, t = !0, i = []) {
        for (let r = 0, s = e.length; r < s; r++) yx(e[r], this, i, t);
        return i.sort(TE), i
    }
}

function TE(n, e) {
    return n.distance - e.distance
}

function yx(n, e, t, i) {
    if (n.layers.test(e.layers) && n.raycast(e, t), i === !0) {
        const r = n.children;
        for (let s = 0, o = r.length; s < o; s++) yx(r[s], e, t, !0)
    }
}
class vx {
    constructor(e = 1, t = 0, i = 0) {
        return this.radius = e, this.phi = t, this.theta = i, this
    }
    set(e, t, i) {
        return this.radius = e, this.phi = t, this.theta = i, this
    }
    copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(gn(t / this.radius, -1, 1))), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class JH {
    constructor(e = 1, t = 0, i = 0) {
        return this.radius = e, this.theta = t, this.y = i, this
    }
    set(e, t, i) {
        return this.radius = e, this.theta = t, this.y = i, this
    }
    copy(e) {
        return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const BE = new me;
class XH {
    constructor(e = new me(1 / 0, 1 / 0), t = new me(-1 / 0, -1 / 0)) {
        this.isBox2 = !0, this.min = e, this.max = t
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = BE.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return BE.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const PE = new D,
    Ip = new D;
class QH {
    constructor(e = new D, t = new D) {
        this.start = e, this.end = t
    }
    set(e, t) {
        return this.start.copy(e), this.end.copy(t), this
    }
    copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        PE.subVectors(e, this.start), Ip.subVectors(this.end, this.start);
        const i = Ip.dot(Ip);
        let s = Ip.dot(PE) / i;
        return t && (s = gn(s, 0, 1)), s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const RE = new D;
class KH extends Tt {
    constructor(e, t) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
        const i = new ut,
            r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
            const c = o / l * Math.PI * 2,
                d = a / l * Math.PI * 2;
            r.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1)
        }
        i.setAttribute("position", new We(r, 3));
        const s = new ei({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new Or(i, s), this.add(this.cone), this.update()
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
        const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), RE.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(RE), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const uo = new D,
    Lp = new rt,
    lv = new rt;
class YH extends Or {
    constructor(e) {
        const t = R3(e),
            i = new ut,
            r = [],
            s = [],
            o = new Ie(0, 0, 1),
            a = new Ie(0, 1, 0);
        for (let c = 0; c < t.length; c++) {
            const d = t[c];
            d.parent && d.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b))
        }
        i.setAttribute("position", new We(r, 3)), i.setAttribute("color", new We(s, 3));
        const l = new ei({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones,
            i = this.geometry,
            r = i.getAttribute("position");
        lv.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (Lp.multiplyMatrices(lv, a.matrixWorld), uo.setFromMatrixPosition(Lp), r.setXYZ(o, uo.x, uo.y, uo.z), Lp.multiplyMatrices(lv, a.parent.matrixWorld), uo.setFromMatrixPosition(Lp), r.setXYZ(o + 1, uo.x, uo.y, uo.z), o += 2)
        }
        i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function R3(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++) e.push.apply(e, R3(n.children[t]));
    return e
}
class ZH extends bn {
    constructor(e, t, i) {
        const r = new Zu(t, 4, 2),
            s = new Ni({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            });
        super(r, s), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const qH = new D,
    IE = new Ie,
    LE = new Ie;
class $H extends Tt {
    constructor(e, t, i) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper";
        const r = new Yu(t);
        r.rotateY(Math.PI * .5), this.material = new Ni({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }), this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position"),
            o = new Float32Array(s.count * 3);
        r.setAttribute("color", new Dt(o, 3)), this.add(new bn(r, this.material)), this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0) this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            IE.copy(this.light.color), LE.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? IE : LE;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1), e.lookAt(qH.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class e5 extends Or {
    constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
        i = new Ie(i), r = new Ie(r);
        const s = t / 2,
            o = e / t,
            a = e / 2,
            l = [],
            c = [];
        for (let p = 0, m = 0, v = -a; p <= t; p++, v += o) {
            l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
            const y = p === s ? i : r;
            y.toArray(c, m), m += 3, y.toArray(c, m), m += 3, y.toArray(c, m), m += 3, y.toArray(c, m), m += 3
        }
        const d = new ut;
        d.setAttribute("position", new We(l, 3)), d.setAttribute("color", new We(c, 3));
        const h = new ei({
            vertexColors: !0,
            toneMapped: !1
        });
        super(d, h), this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class t5 extends Or {
    constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
        s = new Ie(s), o = new Ie(o);
        const a = [],
            l = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const p = h / t * (Math.PI * 2),
                    m = Math.sin(p) * e,
                    v = Math.cos(p) * e;
                a.push(0, 0, 0), a.push(m, 0, v);
                const y = h & 1 ? s : o;
                l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b)
            }
        for (let h = 0; h < i; h++) {
            const p = h & 1 ? s : o,
                m = e - e / i * h;
            for (let v = 0; v < r; v++) {
                let y = v / r * (Math.PI * 2),
                    A = Math.sin(y) * m,
                    x = Math.cos(y) * m;
                a.push(A, 0, x), l.push(p.r, p.g, p.b), y = (v + 1) / r * (Math.PI * 2), A = Math.sin(y) * m, x = Math.cos(y) * m, a.push(A, 0, x), l.push(p.r, p.g, p.b)
            }
        }
        const c = new ut;
        c.setAttribute("position", new We(a, 3)), c.setAttribute("color", new We(l, 3));
        const d = new ei({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, d), this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
const DE = new D,
    Dp = new D,
    FE = new D;
class n5 extends Tt {
    constructor(e, t, i) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
        let r = new ut;
        r.setAttribute("position", new We([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        const s = new ei({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new js(r, s), this.add(this.lightPlane), r = new ut, r.setAttribute("position", new We([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new js(r, s), this.add(this.targetLine), this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), DE.setFromMatrixPosition(this.light.matrixWorld), Dp.setFromMatrixPosition(this.light.target.matrixWorld), FE.subVectors(Dp, DE), this.lightPlane.lookAt(Dp), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Dp), this.targetLine.scale.z = FE.length()
    }
}
const Fp = new D,
    un = new yd;
class i5 extends Or {
    constructor(e) {
        const t = new ut,
            i = new ei({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            }),
            r = [],
            s = [],
            o = {};
        a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");

        function a(v, y) {
            l(v), l(y)
        }

        function l(v) {
            r.push(0, 0, 0), s.push(0, 0, 0), o[v] === void 0 && (o[v] = []), o[v].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new We(r, 3)), t.setAttribute("color", new We(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
        const c = new Ie(16755200),
            d = new Ie(16711680),
            h = new Ie(43775),
            p = new Ie(16777215),
            m = new Ie(3355443);
        this.setColors(c, d, h, p, m)
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0
    }
    update() {
        const e = this.geometry,
            t = this.pointMap,
            i = 1,
            r = 1;
        un.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), pn("c", t, e, un, 0, 0, -1), pn("t", t, e, un, 0, 0, 1), pn("n1", t, e, un, -i, -r, -1), pn("n2", t, e, un, i, -r, -1), pn("n3", t, e, un, -i, r, -1), pn("n4", t, e, un, i, r, -1), pn("f1", t, e, un, -i, -r, 1), pn("f2", t, e, un, i, -r, 1), pn("f3", t, e, un, -i, r, 1), pn("f4", t, e, un, i, r, 1), pn("u1", t, e, un, i * .7, r * 1.1, -1), pn("u2", t, e, un, -i * .7, r * 1.1, -1), pn("u3", t, e, un, 0, r * 2, -1), pn("cf1", t, e, un, -i, 0, 1), pn("cf2", t, e, un, i, 0, 1), pn("cf3", t, e, un, 0, -r, 1), pn("cf4", t, e, un, 0, r, 1), pn("cn1", t, e, un, -i, 0, -1), pn("cn2", t, e, un, i, 0, -1), pn("cn3", t, e, un, 0, -r, -1), pn("cn4", t, e, un, 0, r, -1), e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function pn(n, e, t, i, r, s, o) {
    Fp.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let c = 0, d = a.length; c < d; c++) l.setXYZ(a[c], Fp.x, Fp.y, Fp.z)
    }
}
const kp = new Yo;
class r5 extends Or {
    constructor(e, t = 16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new Float32Array(8 * 3),
            s = new ut;
        s.setIndex(new Dt(i, 1)), s.setAttribute("position", new Dt(r, 3)), super(s, new ei({
            color: t,
            toneMapped: !1
        })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && kp.setFromObject(this.object), kp.isEmpty()) return;
        const t = kp.min,
            i = kp.max,
            r = this.geometry.attributes.position,
            s = r.array;
        s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e, this.update(), this
    }
    copy(e, t) {
        return super.copy(e, t), this.object = e.object, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class s5 extends Or {
    constructor(e, t = 16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
            s = new ut;
        s.setIndex(new Dt(i, 1)), s.setAttribute("position", new We(r, 3)), super(s, new ei({
            color: t,
            toneMapped: !1
        })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class o5 extends js {
    constructor(e, t = 1, i = 16776960) {
        const r = i,
            s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
            o = new ut;
        o.setAttribute("position", new We(s, 3)), o.computeBoundingSphere(), super(o, new ei({
            color: r,
            toneMapped: !1
        })), this.type = "PlaneHelper", this.plane = e, this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            l = new ut;
        l.setAttribute("position", new We(a, 3)), l.computeBoundingSphere(), this.add(new bn(l, new Ni({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
}
const kE = new D;
let Np, uv;
class a5 extends Tt {
    constructor(e = new D(0, 0, 1), t = new D(0, 0, 0), i = 1, r = 16776960, s = i * .2, o = s * .2) {
        super(), this.type = "ArrowHelper", Np === void 0 && (Np = new ut, Np.setAttribute("position", new We([0, 0, 0, 0, 1, 0], 3)), uv = new ul(0, .5, 1, 5, 1), uv.translate(0, -.5, 0)), this.position.copy(t), this.line = new js(Np, new ei({
            color: r,
            toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new bn(uv, new Ni({
            color: r,
            toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            kE.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(kE, t)
        }
    }
    setLength(e, t = e * .2, i = t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }
    dispose() {
        this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
    }
}
class l5 extends Or {
    constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            r = new ut;
        r.setAttribute("position", new We(t, 3)), r.setAttribute("color", new We(i, 3));
        const s = new ei({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s), this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Ie,
            s = this.geometry.attributes.color.array;
        return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class u5 {
    constructor() {
        this.type = "ShapePath", this.color = new Ie, this.subPaths = [], this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Yf, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r), this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this
    }
    toShapes(e) {
        function t(x) {
            const _ = [];
            for (let S = 0, M = x.length; S < M; S++) {
                const b = x[S],
                    B = new Ya;
                B.curves = b.curves, _.push(B)
            }
            return _
        }

        function i(x, _) {
            const S = _.length;
            let M = !1;
            for (let b = S - 1, B = 0; B < S; b = B++) {
                let R = _[b],
                    E = _[B],
                    P = E.x - R.x,
                    I = E.y - R.y;
                if (Math.abs(I) > Number.EPSILON) {
                    if (I < 0 && (R = _[B], P = -P, E = _[b], I = -I), x.y < R.y || x.y > E.y) continue;
                    if (x.y === R.y) {
                        if (x.x === R.x) return !0
                    } else {
                        const z = I * (x.x - R.x) - P * (x.y - R.y);
                        if (z === 0) return !0;
                        if (z < 0) continue;
                        M = !M
                    }
                } else {
                    if (x.y !== R.y) continue;
                    if (E.x <= x.x && x.x <= R.x || R.x <= x.x && x.x <= E.x) return !0
                }
            }
            return M
        }
        const r = ts.isClockWise,
            s = this.subPaths;
        if (s.length === 0) return [];
        let o, a, l;
        const c = [];
        if (s.length === 1) return a = s[0], l = new Ya, l.curves = a.curves, c.push(l), c;
        let d = !r(s[0].getPoints());
        d = e ? !d : d;
        const h = [],
            p = [];
        let m = [],
            v = 0,
            y;
        p[v] = void 0, m[v] = [];
        for (let x = 0, _ = s.length; x < _; x++) a = s[x], y = a.getPoints(), o = r(y), o = e ? !o : o, o ? (!d && p[v] && v++, p[v] = {
            s: new Ya,
            p: y
        }, p[v].s.curves = a.curves, d && v++, m[v] = []) : m[v].push({
            h: a,
            p: y[0]
        });
        if (!p[0]) return t(s);
        if (p.length > 1) {
            let x = !1,
                _ = 0;
            for (let S = 0, M = p.length; S < M; S++) h[S] = [];
            for (let S = 0, M = p.length; S < M; S++) {
                const b = m[S];
                for (let B = 0; B < b.length; B++) {
                    const R = b[B];
                    let E = !0;
                    for (let P = 0; P < p.length; P++) i(R.p, p[P].p) && (S !== P && _++, E ? (E = !1, h[P].push(R)) : x = !0);
                    E && h[S].push(R)
                }
            }
            _ > 0 && x === !1 && (m = h)
        }
        let A;
        for (let x = 0, _ = p.length; x < _; x++) {
            l = p[x].s, c.push(l), A = m[x];
            for (let S = 0, M = A.length; S < M; S++) l.holes.push(A[S].h)
        }
        return c
    }
}
const bs = c5();

function c5() {
    const n = new ArrayBuffer(4),
        e = new Float32Array(n),
        t = new Uint32Array(n),
        i = new Uint32Array(512),
        r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0, i[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14, i[l | 256] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10, i[l | 256] = c + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : c < 128 ? (i[l] = 31744, i[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, r[l] = 13, r[l | 256] = 13)
    }
    const s = new Uint32Array(2048),
        o = new Uint32Array(64),
        a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13,
            d = 0;
        for (; !(c & 8388608);) c <<= 1, d -= 8388608;
        c &= -8388609, d += 947912704, s[l] = c | d
    }
    for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l) o[l] = l << 23;
    o[31] = 1199570944, o[32] = 2147483648;
    for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}

function f5(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = gn(n, -65504, 65504), bs.floatView[0] = n;
    const e = bs.uint32View[0],
        t = e >> 23 & 511;
    return bs.baseTable[t] + ((e & 8388607) >> bs.shiftTable[t])
}

function d5(n) {
    const e = n >> 10;
    return bs.uint32View[0] = bs.mantissaTable[bs.offsetTable[e] + (n & 1023)] + bs.exponentTable[e], bs.floatView[0]
}
var h5 = Object.freeze({
    __proto__: null,
    fromHalfFloat: d5,
    toHalfFloat: f5
});
class p5 extends qo {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, i, r, s, o)
    }
}
class m5 extends wd {
    constructor(e, t, i, r) {
        console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, i, r)
    }
}
class g5 extends Sd {
    constructor(e, t, i, r) {
        console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, i, r)
    }
}
class y5 extends Md {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, i, r, s, o, a)
    }
}
class v5 extends ul {
    constructor(e, t, i, r, s, o, a, l) {
        console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, i, r, s, o, a, l)
    }
}
class A5 extends Cd {
    constructor(e, t) {
        console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t)
    }
}
class x5 extends Ed {
    constructor(e, t) {
        console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t)
    }
}
class _5 extends bd {
    constructor(e, t) {
        console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t)
    }
}
class w5 extends Ku {
    constructor(e, t, i, r) {
        console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, i, r)
    }
}
class S5 extends Yu {
    constructor(e, t) {
        console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t)
    }
}
class M5 extends Xu {
    constructor(e, t, i, r) {
        console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, i, r)
    }
}
class C5 extends Qs {
    constructor(e, t, i, r) {
        console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, i, r)
    }
}
class E5 extends Td {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, i, r, s, o)
    }
}
class b5 extends Bd {
    constructor(e, t) {
        console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t)
    }
}
class T5 extends Zu {
    constructor(e, t, i, r, s, o, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, i, r, s, o, a)
    }
}
class B5 extends Pd {
    constructor(e, t) {
        console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t)
    }
}
class P5 extends Rd {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, i, r, s)
    }
}
class R5 extends Id {
    constructor(e, t, i, r, s, o) {
        console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, i, r, s, o)
    }
}
class I5 extends Ld {
    constructor(e, t, i, r, s) {
        console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, i, r, s)
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: Mg
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Mg);
const Ax = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: K1,
    AddEquation: Pa,
    AddOperation: aP,
    AdditiveAnimationBlendMode: Z1,
    AdditiveBlending: FA,
    AlphaFormat: yP,
    AlwaysDepth: eP,
    AlwaysStencilFunc: DP,
    AmbientLight: w3,
    AmbientLightProbe: wH,
    AnimationClip: Uu,
    AnimationLoader: fH,
    AnimationMixer: GH,
    AnimationObjectGroup: OH,
    AnimationUtils: aH,
    ArcCurve: $P,
    ArrayCamera: JP,
    ArrowHelper: a5,
    Audio: T3,
    AudioAnalyser: TH,
    AudioContext: I_,
    AudioListener: CH,
    AudioLoader: xH,
    AxesHelper: l5,
    BackSide: Ci,
    BasicDepthPacking: RP,
    BasicShadowMap: zB,
    Bone: Dg,
    BooleanKeyframeTrack: cl,
    Box2: XH,
    Box3: Yo,
    Box3Helper: s5,
    BoxBufferGeometry: p5,
    BoxGeometry: qo,
    BoxHelper: r5,
    BufferAttribute: Dt,
    BufferGeometry: ut,
    BufferGeometryLoader: E3,
    ByteType: dP,
    Cache: sl,
    Camera: yd,
    CameraHelper: i5,
    CanvasTexture: RG,
    CapsuleBufferGeometry: m5,
    CapsuleGeometry: wd,
    CatmullRomCurve3: e3,
    CineonToneMapping: cP,
    CircleBufferGeometry: g5,
    CircleGeometry: Sd,
    ClampToEdgeWrapping: zn,
    Clock: L_,
    Color: Ie,
    ColorKeyframeTrack: E_,
    ColorManagement: Zn,
    CompressedArrayTexture: PG,
    CompressedTexture: g_,
    CompressedTextureLoader: dH,
    ConeBufferGeometry: y5,
    ConeGeometry: Md,
    CubeCamera: s_,
    CubeReflectionMapping: zo,
    CubeRefractionMapping: Go,
    CubeTexture: vd,
    CubeTextureLoader: hH,
    CubeUVReflectionMapping: Ju,
    CubicBezierCurve: v_,
    CubicBezierCurve3: t3,
    CubicInterpolant: v3,
    CullFaceBack: DA,
    CullFaceFront: UB,
    CullFaceFrontBack: kk,
    CullFaceNone: OB,
    Curve: Ur,
    CurvePath: i3,
    CustomBlending: GB,
    CustomToneMapping: fP,
    CylinderBufferGeometry: v5,
    CylinderGeometry: ul,
    Cylindrical: JH,
    Data3DTexture: n_,
    DataArrayTexture: Bg,
    DataTexture: wu,
    DataTextureLoader: pH,
    DataUtils: h5,
    DecrementStencilOp: Xk,
    DecrementWrapStencilOp: Kk,
    DefaultLoadingManager: fu,
    DepthFormat: ko,
    DepthStencilFormat: nl,
    DepthTexture: XP,
    DirectionalLight: R_,
    DirectionalLightHelper: n5,
    DiscreteInterpolant: A3,
    DodecahedronBufferGeometry: A5,
    DodecahedronGeometry: Cd,
    DoubleSide: Rr,
    DstAlphaFactor: QB,
    DstColorFactor: YB,
    DynamicCopyUsage: uN,
    DynamicDrawUsage: Ja,
    DynamicReadUsage: oN,
    EdgesGeometry: r3,
    EllipseCurve: Fg,
    EqualDepth: nP,
    EqualStencilFunc: $k,
    EquirectangularReflectionMapping: Vf,
    EquirectangularRefractionMapping: Wf,
    Euler: ll,
    EventDispatcher: as,
    ExtrudeBufferGeometry: x5,
    ExtrudeGeometry: Ed,
    FileLoader: Gi,
    Float16BufferAttribute: VN,
    Float32BufferAttribute: We,
    Float64BufferAttribute: WN,
    FloatType: Rs,
    Fog: Lg,
    FogExp2: Ig,
    FramebufferTexture: BG,
    FrontSide: rs,
    Frustum: Pg,
    GLBufferAttribute: jH,
    GLSL1: fN,
    GLSL3: ux,
    GreaterDepth: rP,
    GreaterEqualDepth: iP,
    GreaterEqualStencilFunc: iN,
    GreaterStencilFunc: tN,
    GridHelper: e5,
    Group: Ls,
    HalfFloatType: Iu,
    HemisphereLight: _3,
    HemisphereLightHelper: $H,
    HemisphereLightProbe: _H,
    IcosahedronBufferGeometry: _5,
    IcosahedronGeometry: bd,
    ImageBitmapLoader: b3,
    ImageLoader: ed,
    ImageUtils: t_,
    IncrementStencilOp: Jk,
    IncrementWrapStencilOp: Qk,
    InstancedBufferAttribute: ku,
    InstancedBufferGeometry: C3,
    InstancedInterleavedBuffer: WH,
    InstancedMesh: qP,
    Int16BufferAttribute: GN,
    Int32BufferAttribute: HN,
    Int8BufferAttribute: ON,
    IntType: pP,
    InterleavedBuffer: Ad,
    InterleavedBufferAttribute: Vo,
    Interpolant: $u,
    InterpolateDiscrete: Lu,
    InterpolateLinear: il,
    InterpolateSmooth: cm,
    InvertStencilOp: Yk,
    KeepStencilOp: fm,
    KeyframeTrack: zr,
    LOD: ZP,
    LatheBufferGeometry: w5,
    LatheGeometry: Ku,
    Layers: Ka,
    LessDepth: tP,
    LessEqualDepth: Wm,
    LessEqualStencilFunc: eN,
    LessStencilFunc: qk,
    Light: $o,
    LightProbe: Og,
    Line: js,
    Line3: QH,
    LineBasicMaterial: ei,
    LineCurve: kg,
    LineCurve3: n3,
    LineDashedMaterial: g3,
    LineLoop: p_,
    LineSegments: Or,
    LinearEncoding: Ws,
    LinearFilter: en,
    LinearInterpolant: C_,
    LinearMipMapLinearFilter: Gk,
    LinearMipMapNearestFilter: zk,
    LinearMipmapLinearFilter: ss,
    LinearMipmapNearestFilter: bg,
    LinearSRGBColorSpace: Du,
    LinearToneMapping: lP,
    Loader: hi,
    LoaderUtils: ns,
    LoadingManager: b_,
    LoopOnce: bP,
    LoopPingPong: BP,
    LoopRepeat: TP,
    LuminanceAlphaFormat: AP,
    LuminanceFormat: vP,
    MOUSE: Ma,
    Material: wn,
    MaterialLoader: Ug,
    MathUtils: e_,
    Matrix3: li,
    Matrix4: rt,
    MaxEquation: UA,
    Mesh: bn,
    MeshBasicMaterial: Ni,
    MeshDepthMaterial: l_,
    MeshDistanceMaterial: u_,
    MeshLambertMaterial: p3,
    MeshMatcapMaterial: m3,
    MeshNormalMaterial: h3,
    MeshPhongMaterial: f3,
    MeshPhysicalMaterial: Ks,
    MeshStandardMaterial: qu,
    MeshToonMaterial: d3,
    MinEquation: OA,
    MirroredRepeatWrapping: Ru,
    MixOperation: oP,
    MultiplyBlending: NA,
    MultiplyOperation: md,
    NearestFilter: fn,
    NearestMipMapLinearFilter: Uk,
    NearestMipMapNearestFilter: Ok,
    NearestMipmapLinearFilter: _u,
    NearestMipmapNearestFilter: jf,
    NeverDepth: $B,
    NeverStencilFunc: Zk,
    NoBlending: ks,
    NoColorSpace: Vk,
    NoToneMapping: Dr,
    NormalAnimationBlendMode: Tg,
    NormalBlending: Wa,
    NotEqualDepth: sP,
    NotEqualStencilFunc: nN,
    NumberKeyframeTrack: Nu,
    Object3D: Tt,
    ObjectLoader: vH,
    ObjectSpaceNormalMap: LP,
    OctahedronBufferGeometry: S5,
    OctahedronGeometry: Yu,
    OneFactor: jB,
    OneMinusDstAlphaFactor: KB,
    OneMinusDstColorFactor: ZB,
    OneMinusSrcAlphaFactor: Q1,
    OneMinusSrcColorFactor: XB,
    OrthographicCamera: Fr,
    PCFShadowMap: Cg,
    PCFSoftShadowMap: pf,
    PMREMGenerator: fx,
    Path: Yf,
    PerspectiveCamera: Gt,
    Plane: vo,
    PlaneBufferGeometry: M5,
    PlaneGeometry: Xu,
    PlaneHelper: o5,
    PointLight: P_,
    PointLightHelper: ZH,
    Points: m_,
    PointsMaterial: _d,
    PolarGridHelper: t5,
    PolyhedronBufferGeometry: C5,
    PolyhedronGeometry: Qs,
    PositionalAudio: bH,
    PropertyBinding: bt,
    PropertyMixer: B3,
    QuadraticBezierCurve: A_,
    QuadraticBezierCurve3: x_,
    Quaternion: Hn,
    QuaternionKeyframeTrack: Wo,
    QuaternionLinearInterpolant: x3,
    RED_GREEN_RGTC2_Format: ax,
    RED_RGTC1_Format: EP,
    REVISION: Mg,
    RGBADepthPacking: IP,
    RGBAFormat: xi,
    RGBAIntegerFormat: MP,
    RGBA_ASTC_10x10_Format: ix,
    RGBA_ASTC_10x5_Format: ex,
    RGBA_ASTC_10x6_Format: tx,
    RGBA_ASTC_10x8_Format: nx,
    RGBA_ASTC_12x10_Format: rx,
    RGBA_ASTC_12x12_Format: sx,
    RGBA_ASTC_4x4_Format: JA,
    RGBA_ASTC_5x4_Format: XA,
    RGBA_ASTC_5x5_Format: QA,
    RGBA_ASTC_6x5_Format: KA,
    RGBA_ASTC_6x6_Format: YA,
    RGBA_ASTC_8x5_Format: ZA,
    RGBA_ASTC_8x6_Format: qA,
    RGBA_ASTC_8x8_Format: $A,
    RGBA_BPTC_Format: um,
    RGBA_ETC2_EAC_Format: jA,
    RGBA_PVRTC_2BPPV1_Format: VA,
    RGBA_PVRTC_4BPPV1_Format: HA,
    RGBA_S3TC_DXT1_Format: om,
    RGBA_S3TC_DXT3_Format: am,
    RGBA_S3TC_DXT5_Format: lm,
    RGB_ETC1_Format: CP,
    RGB_ETC2_Format: WA,
    RGB_PVRTC_2BPPV1_Format: GA,
    RGB_PVRTC_4BPPV1_Format: zA,
    RGB_S3TC_DXT1_Format: sm,
    RGFormat: wP,
    RGIntegerFormat: SP,
    RawShaderMaterial: c3,
    Ray: gd,
    Raycaster: P3,
    RectAreaLight: S3,
    RedFormat: xP,
    RedIntegerFormat: _P,
    ReinhardToneMapping: uP,
    RepeatWrapping: Ho,
    ReplaceStencilOp: jk,
    ReverseSubtractEquation: VB,
    RingBufferGeometry: E5,
    RingGeometry: Td,
    SIGNED_RED_GREEN_RGTC2_Format: lx,
    SIGNED_RED_RGTC1_Format: ox,
    SRGBColorSpace: Tr,
    Scene: f_,
    ShaderChunk: pt,
    ShaderLib: Pr,
    ShaderMaterial: os,
    ShadowMaterial: u3,
    Shape: Ya,
    ShapeBufferGeometry: b5,
    ShapeGeometry: Bd,
    ShapePath: u5,
    ShapeUtils: ts,
    ShortType: hP,
    Skeleton: xd,
    SkeletonHelper: YH,
    SkinnedMesh: h_,
    Source: Ua,
    Sphere: Zo,
    SphereBufferGeometry: T5,
    SphereGeometry: Zu,
    Spherical: vx,
    SphericalHarmonics3: M3,
    SplineCurve: __,
    SpotLight: B_,
    SpotLightHelper: KH,
    Sprite: YP,
    SpriteMaterial: d_,
    SrcAlphaFactor: X1,
    SrcAlphaSaturateFactor: qB,
    SrcColorFactor: JB,
    StaticCopyUsage: lN,
    StaticDrawUsage: Xf,
    StaticReadUsage: sN,
    StereoCamera: SH,
    StreamCopyUsage: cN,
    StreamDrawUsage: rN,
    StreamReadUsage: aN,
    StringKeyframeTrack: fl,
    SubtractEquation: HB,
    SubtractiveBlending: kA,
    TOUCH: Ca,
    TangentSpaceNormalMap: Xs,
    TetrahedronBufferGeometry: B5,
    TetrahedronGeometry: Pd,
    Texture: Yt,
    TextureLoader: Dd,
    TorusBufferGeometry: P5,
    TorusGeometry: Rd,
    TorusKnotBufferGeometry: R5,
    TorusKnotGeometry: Id,
    Triangle: cr,
    TriangleFanDrawMode: q1,
    TriangleStripDrawMode: PP,
    TrianglesDrawMode: Hk,
    TubeBufferGeometry: I5,
    TubeGeometry: Ld,
    TwoPassDoubleSide: Nk,
    UVMapping: Eg,
    Uint16BufferAttribute: i_,
    Uint32BufferAttribute: r_,
    Uint8BufferAttribute: UN,
    Uint8ClampedBufferAttribute: zN,
    Uniform: k_,
    UniformsGroup: VH,
    UniformsLib: Re,
    UniformsUtils: UP,
    UnsignedByteType: Vs,
    UnsignedInt248Type: ja,
    UnsignedIntType: Mo,
    UnsignedShort4444Type: mP,
    UnsignedShort5551Type: gP,
    UnsignedShortType: Y1,
    VSMShadowMap: ka,
    Vector2: me,
    Vector3: D,
    Vector4: kt,
    VectorKeyframeTrack: Ou,
    VideoTexture: TG,
    WebGL1Renderer: QP,
    WebGL3DRenderTarget: TN,
    WebGLArrayRenderTarget: bN,
    WebGLCubeRenderTarget: o_,
    WebGLMultipleRenderTargets: BN,
    WebGLRenderTarget: Nr,
    WebGLRenderer: c_,
    WebGLUtils: jP,
    WireframeGeometry: l3,
    WrapAroundEnding: Jf,
    ZeroCurvatureEnding: Na,
    ZeroFactor: WB,
    ZeroSlopeEnding: Oa,
    ZeroStencilOp: Wk,
    _SRGBAFormat: jm,
    sRGBEncoding: Ct
}, Symbol.toStringTag, {
    value: "Module"
}));
var Co = {},
    L5 = {
        get exports() {
            return Co
        },
        set exports(n) {
            Co = n
        }
    },
    dl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
dl.ConcurrentRoot = 1;
dl.ContinuousEventPriority = 4;
dl.DefaultEventPriority = 16;
dl.DiscreteEventPriority = 1;
dl.IdleEventPriority = 536870912;
dl.LegacyRoot = 0;
(function(n) {
    n.exports = dl
})(L5);

function D5(n) {
    let e;
    const t = new Set,
        i = (c, d) => {
            const h = typeof c == "function" ? c(e) : c;
            if (h !== e) {
                const p = e;
                e = d ? h : Object.assign({}, e, h), t.forEach(m => m(e, p))
            }
        },
        r = () => e,
        s = (c, d = r, h = Object.is) => {
            console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
            let p = d(e);

            function m() {
                const v = d(e);
                if (!h(p, v)) {
                    const y = p;
                    c(p = v, y)
                }
            }
            return t.add(m), () => t.delete(m)
        },
        l = {
            setState: i,
            getState: r,
            subscribe: (c, d, h) => d || h ? s(c, d, h) : (t.add(c), () => t.delete(c)),
            destroy: () => t.clear()
        };
    return e = n(i, r, l), l
}
const F5 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    NE = F5 ? U.useEffect : U.useLayoutEffect;

function I3(n) {
    const e = typeof n == "function" ? D5(n) : n,
        t = (i = e.getState, r = Object.is) => {
            const [, s] = U.useReducer(A => A + 1, 0), o = e.getState(), a = U.useRef(o), l = U.useRef(i), c = U.useRef(r), d = U.useRef(!1), h = U.useRef();
            h.current === void 0 && (h.current = i(o));
            let p, m = !1;
            (a.current !== o || l.current !== i || c.current !== r || d.current) && (p = i(o), m = !r(h.current, p)), NE(() => {
                m && (h.current = p), a.current = o, l.current = i, c.current = r, d.current = !1
            });
            const v = U.useRef(o);
            NE(() => {
                const A = () => {
                        try {
                            const _ = e.getState(),
                                S = l.current(_);
                            c.current(h.current, S) || (a.current = _, h.current = S, s())
                        } catch {
                            d.current = !0, s()
                        }
                    },
                    x = e.subscribe(A);
                return e.getState() !== v.current && A(), x
            }, []);
            const y = m ? p : h.current;
            return U.useDebugValue(y), y
        };
    return Object.assign(t, e), t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const i = [t, e];
        return {
            next() {
                const r = i.length <= 0;
                return {
                    value: i.shift(),
                    done: r
                }
            }
        }
    }, t
}
var xx = {},
    k5 = {
        get exports() {
            return xx
        },
        set exports(n) {
            xx = n
        }
    },
    td = {},
    N5 = {
        get exports() {
            return td
        },
        set exports(n) {
            td = n
        }
    },
    L3 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(k, V) {
        var J = k.length;
        k.push(V);
        e: for (; 0 < J;) {
            var ie = J - 1 >>> 1,
                j = k[ie];
            if (0 < r(j, V)) k[ie] = V, k[J] = j, J = ie;
            else break e
        }
    }

    function t(k) {
        return k.length === 0 ? null : k[0]
    }

    function i(k) {
        if (k.length === 0) return null;
        var V = k[0],
            J = k.pop();
        if (J !== V) {
            k[0] = J;
            e: for (var ie = 0, j = k.length, re = j >>> 1; ie < re;) {
                var ve = 2 * (ie + 1) - 1,
                    xe = k[ve],
                    q = ve + 1,
                    Ne = k[q];
                if (0 > r(xe, J)) q < j && 0 > r(Ne, xe) ? (k[ie] = Ne, k[q] = J, ie = q) : (k[ie] = xe, k[ve] = J, ie = ve);
                else if (q < j && 0 > r(Ne, J)) k[ie] = Ne, k[q] = J, ie = q;
                else break e
            }
        }
        return V
    }

    function r(k, V) {
        var J = k.sortIndex - V.sortIndex;
        return J !== 0 ? J : k.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        c = [],
        d = 1,
        h = null,
        p = 3,
        m = !1,
        v = !1,
        y = !1,
        A = typeof setTimeout == "function" ? setTimeout : null,
        x = typeof clearTimeout == "function" ? clearTimeout : null,
        _ = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function S(k) {
        for (var V = t(c); V !== null;) {
            if (V.callback === null) i(c);
            else if (V.startTime <= k) i(c), V.sortIndex = V.expirationTime, e(l, V);
            else break;
            V = t(c)
        }
    }

    function M(k) {
        if (y = !1, S(k), !v)
            if (t(l) !== null) v = !0, te(b);
            else {
                var V = t(c);
                V !== null && se(M, V.startTime - k)
            }
    }

    function b(k, V) {
        v = !1, y && (y = !1, x(E), E = -1), m = !0;
        var J = p;
        try {
            for (S(V), h = t(l); h !== null && (!(h.expirationTime > V) || k && !z());) {
                var ie = h.callback;
                if (typeof ie == "function") {
                    h.callback = null, p = h.priorityLevel;
                    var j = ie(h.expirationTime <= V);
                    V = n.unstable_now(), typeof j == "function" ? h.callback = j : h === t(l) && i(l), S(V)
                } else i(l);
                h = t(l)
            }
            if (h !== null) var re = !0;
            else {
                var ve = t(c);
                ve !== null && se(M, ve.startTime - V), re = !1
            }
            return re
        } finally {
            h = null, p = J, m = !1
        }
    }
    var B = !1,
        R = null,
        E = -1,
        P = 5,
        I = -1;

    function z() {
        return !(n.unstable_now() - I < P)
    }

    function Z() {
        if (R !== null) {
            var k = n.unstable_now();
            I = k;
            var V = !0;
            try {
                V = R(!0, k)
            } finally {
                V ? W() : (B = !1, R = null)
            }
        } else B = !1
    }
    var W;
    if (typeof _ == "function") W = function() {
        _(Z)
    };
    else if (typeof MessageChannel < "u") {
        var G = new MessageChannel,
            K = G.port2;
        G.port1.onmessage = Z, W = function() {
            K.postMessage(null)
        }
    } else W = function() {
        A(Z, 0)
    };

    function te(k) {
        R = k, B || (B = !0, W())
    }

    function se(k, V) {
        E = A(function() {
            k(n.unstable_now())
        }, V)
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(k) {
        k.callback = null
    }, n.unstable_continueExecution = function() {
        v || m || (v = !0, te(b))
    }, n.unstable_forceFrameRate = function(k) {
        0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < k ? Math.floor(1e3 / k) : 5
    }, n.unstable_getCurrentPriorityLevel = function() {
        return p
    }, n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }, n.unstable_next = function(k) {
        switch (p) {
            case 1:
            case 2:
            case 3:
                var V = 3;
                break;
            default:
                V = p
        }
        var J = p;
        p = V;
        try {
            return k()
        } finally {
            p = J
        }
    }, n.unstable_pauseExecution = function() {}, n.unstable_requestPaint = function() {}, n.unstable_runWithPriority = function(k, V) {
        switch (k) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                k = 3
        }
        var J = p;
        p = k;
        try {
            return V()
        } finally {
            p = J
        }
    }, n.unstable_scheduleCallback = function(k, V, J) {
        var ie = n.unstable_now();
        switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? ie + J : ie) : J = ie, k) {
            case 1:
                var j = -1;
                break;
            case 2:
                j = 250;
                break;
            case 5:
                j = 1073741823;
                break;
            case 4:
                j = 1e4;
                break;
            default:
                j = 5e3
        }
        return j = J + j, k = {
            id: d++,
            callback: V,
            priorityLevel: k,
            startTime: J,
            expirationTime: j,
            sortIndex: -1
        }, J > ie ? (k.sortIndex = J, e(c, k), t(l) === null && k === t(c) && (y ? (x(E), E = -1) : y = !0, se(M, J - ie))) : (k.sortIndex = j, e(l, k), v || m || (v = !0, te(b))), k
    }, n.unstable_shouldYield = z, n.unstable_wrapCallback = function(k) {
        var V = p;
        return function() {
            var J = p;
            p = V;
            try {
                return k.apply(this, arguments)
            } finally {
                p = J
            }
        }
    }
})(L3);
(function(n) {
    n.exports = L3
})(N5);
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O5 = function(e) {
    var t = {},
        i = U,
        r = td,
        s = Object.assign;

    function o(u) {
        for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, g = 1; g < arguments.length; g++) f += "&args[]=" + encodeURIComponent(arguments[g]);
        return "Minified React error #" + u + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        l = Symbol.for("react.element"),
        c = Symbol.for("react.portal"),
        d = Symbol.for("react.fragment"),
        h = Symbol.for("react.strict_mode"),
        p = Symbol.for("react.profiler"),
        m = Symbol.for("react.provider"),
        v = Symbol.for("react.context"),
        y = Symbol.for("react.forward_ref"),
        A = Symbol.for("react.suspense"),
        x = Symbol.for("react.suspense_list"),
        _ = Symbol.for("react.memo"),
        S = Symbol.for("react.lazy"),
        M = Symbol.for("react.offscreen"),
        b = Symbol.iterator;

    function B(u) {
        return u === null || typeof u != "object" ? null : (u = b && u[b] || u["@@iterator"], typeof u == "function" ? u : null)
    }

    function R(u) {
        if (u == null) return null;
        if (typeof u == "function") return u.displayName || u.name || null;
        if (typeof u == "string") return u;
        switch (u) {
            case d:
                return "Fragment";
            case c:
                return "Portal";
            case p:
                return "Profiler";
            case h:
                return "StrictMode";
            case A:
                return "Suspense";
            case x:
                return "SuspenseList"
        }
        if (typeof u == "object") switch (u.$$typeof) {
            case v:
                return (u.displayName || "Context") + ".Consumer";
            case m:
                return (u._context.displayName || "Context") + ".Provider";
            case y:
                var f = u.render;
                return u = u.displayName, u || (u = f.displayName || f.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u;
            case _:
                return f = u.displayName || null, f !== null ? f : R(u.type) || "Memo";
            case S:
                f = u._payload, u = u._init;
                try {
                    return R(u(f))
                } catch {}
        }
        return null
    }

    function E(u) {
        var f = u.type;
        switch (u.tag) {
            case 24:
                return "Cache";
            case 9:
                return (f.displayName || "Context") + ".Consumer";
            case 10:
                return (f._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return u = f.render, u = u.displayName || u.name || "", f.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return f;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return R(f);
            case 8:
                return f === h ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof f == "function") return f.displayName || f.name || null;
                if (typeof f == "string") return f
        }
        return null
    }

    function P(u) {
        var f = u,
            g = u;
        if (u.alternate)
            for (; f.return;) f = f.return;
        else {
            u = f;
            do f = u, f.flags & 4098 && (g = f.return), u = f.return; while (u)
        }
        return f.tag === 3 ? g : null
    }

    function I(u) {
        if (P(u) !== u) throw Error(o(188))
    }

    function z(u) {
        var f = u.alternate;
        if (!f) {
            if (f = P(u), f === null) throw Error(o(188));
            return f !== u ? null : u
        }
        for (var g = u, w = f;;) {
            var C = g.return;
            if (C === null) break;
            var T = C.alternate;
            if (T === null) {
                if (w = C.return, w !== null) {
                    g = w;
                    continue
                }
                break
            }
            if (C.child === T.child) {
                for (T = C.child; T;) {
                    if (T === g) return I(C), u;
                    if (T === w) return I(C), f;
                    T = T.sibling
                }
                throw Error(o(188))
            }
            if (g.return !== w.return) g = C, w = T;
            else {
                for (var N = !1, X = C.child; X;) {
                    if (X === g) {
                        N = !0, g = C, w = T;
                        break
                    }
                    if (X === w) {
                        N = !0, w = C, g = T;
                        break
                    }
                    X = X.sibling
                }
                if (!N) {
                    for (X = T.child; X;) {
                        if (X === g) {
                            N = !0, g = T, w = C;
                            break
                        }
                        if (X === w) {
                            N = !0, w = T, g = C;
                            break
                        }
                        X = X.sibling
                    }
                    if (!N) throw Error(o(189))
                }
            }
            if (g.alternate !== w) throw Error(o(190))
        }
        if (g.tag !== 3) throw Error(o(188));
        return g.stateNode.current === g ? u : f
    }

    function Z(u) {
        return u = z(u), u !== null ? W(u) : null
    }

    function W(u) {
        if (u.tag === 5 || u.tag === 6) return u;
        for (u = u.child; u !== null;) {
            var f = W(u);
            if (f !== null) return f;
            u = u.sibling
        }
        return null
    }

    function G(u) {
        if (u.tag === 5 || u.tag === 6) return u;
        for (u = u.child; u !== null;) {
            if (u.tag !== 4) {
                var f = G(u);
                if (f !== null) return f
            }
            u = u.sibling
        }
        return null
    }
    var K = Array.isArray,
        te = e.getPublicInstance,
        se = e.getRootHostContext,
        k = e.getChildHostContext,
        V = e.prepareForCommit,
        J = e.resetAfterCommit,
        ie = e.createInstance,
        j = e.appendInitialChild,
        re = e.finalizeInitialChildren,
        ve = e.prepareUpdate,
        xe = e.shouldSetTextContent,
        q = e.createTextInstance,
        Ne = e.scheduleTimeout,
        Oe = e.cancelTimeout,
        He = e.noTimeout,
        we = e.isPrimaryRenderer,
        Le = e.supportsMutation,
        he = e.supportsPersistence,
        ae = e.supportsHydration,
        Ce = e.getInstanceFromNode,
        ze = e.preparePortalMount,
        Pe = e.getCurrentEventPriority,
        Ze = e.detachDeletedInstance,
        Je = e.supportsMicrotasks,
        je = e.scheduleMicrotask,
        vt = e.supportsTestSelectors,
        St = e.findFiberRoot,
        O = e.getBoundingRect,
        L = e.getTextContent,
        oe = e.isHiddenSubtree,
        Se = e.matchAccessibilityRole,
        Ee = e.setFocusIfFocusable,
        Be = e.setupIntersectionObserver,
        tt = e.appendChild,
        De = e.appendChildToContainer,
        ge = e.commitTextUpdate,
        Xe = e.commitMount,
        H = e.commitUpdate,
        ue = e.insertBefore,
        _e = e.insertInContainerBefore,
        Te = e.removeChild,
        $e = e.removeChildFromContainer,
        yt = e.resetTextContent,
        Vt = e.hideInstance,
        Q = e.hideTextInstance,
        fe = e.unhideInstance,
        Ae = e.unhideTextInstance,
        Ue = e.clearContainer,
        Ke = e.cloneInstance,
        Bt = e.createContainerChildSet,
        dn = e.appendChildToContainerChildSet,
        Pn = e.finalizeContainerChildren,
        Gr = e.replaceContainerChildren,
        Ot = e.cloneHiddenInstance,
        ji = e.cloneHiddenTextInstance,
        pi = e.canHydrateInstance,
        zd = e.canHydrateTextInstance,
        Zg = e.canHydrateSuspenseInstance,
        Gd = e.isSuspenseInstancePending,
        nc = e.isSuspenseInstanceFallback,
        F = e.registerSuspenseInstanceRetry,
        ee = e.getNextHydratableSibling,
        pe = e.getFirstHydratableChild,
        $ = e.getFirstHydratableChildWithinContainer,
        ye = e.getFirstHydratableChildWithinSuspenseInstance,
        qe = e.hydrateInstance,
        st = e.hydrateTextInstance,
        ft = e.hydrateSuspenseInstance,
        mt = e.getNextHydratableInstanceAfterSuspenseInstance,
        Mt = e.commitHydratedContainer,
        xt = e.commitHydratedSuspenseInstance,
        _t = e.clearSuspenseBoundary,
        on = e.clearSuspenseBoundaryFromContainer,
        ti = e.shouldDeleteUnhydratedTailInstances,
        vr = e.didNotMatchHydratedContainerTextInstance,
        ls = e.didNotMatchHydratedTextInstance,
        Jt;

    function dt(u) {
        if (Jt === void 0) try {
            throw Error()
        } catch (g) {
            var f = g.stack.trim().match(/\n( *(at )?)/);
            Jt = f && f[1] || ""
        }
        return `
` + Jt + u
    }
    var na = !1;

    function an(u, f) {
        if (!u || na) return "";
        na = !0;
        var g = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (f)
                if (f = function() {
                        throw Error()
                    }, Object.defineProperty(f.prototype, "props", {
                        set: function() {
                            throw Error()
                        }
                    }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(f, [])
                    } catch (be) {
                        var w = be
                    }
                    Reflect.construct(u, [], f)
                } else {
                    try {
                        f.call()
                    } catch (be) {
                        w = be
                    }
                    u.call(f.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (be) {
                    w = be
                }
                u()
            }
        } catch (be) {
            if (be && w && typeof be.stack == "string") {
                for (var C = be.stack.split(`
`), T = w.stack.split(`
`), N = C.length - 1, X = T.length - 1; 1 <= N && 0 <= X && C[N] !== T[X];) X--;
                for (; 1 <= N && 0 <= X; N--, X--)
                    if (C[N] !== T[X]) {
                        if (N !== 1 || X !== 1)
                            do
                                if (N--, X--, 0 > X || C[N] !== T[X]) {
                                    var de = `
` + C[N].replace(" at new ", " at ");
                                    return u.displayName && de.includes("<anonymous>") && (de = de.replace("<anonymous>", u.displayName)), de
                                } while (1 <= N && 0 <= X);
                        break
                    }
            }
        } finally {
            na = !1, Error.prepareStackTrace = g
        }
        return (u = u ? u.displayName || u.name : "") ? dt(u) : ""
    }
    var us = Object.prototype.hasOwnProperty,
        ml = [],
        Ji = -1;

    function Xi(u) {
        return {
            current: u
        }
    }

    function ct(u) {
        0 > Ji || (u.current = ml[Ji], ml[Ji] = null, Ji--)
    }

    function Et(u, f) {
        Ji++, ml[Ji] = u.current, u.current = f
    }
    var Qi = {},
        Ft = Xi(Qi),
        Rn = Xi(!1),
        cs = Qi;

    function fs(u, f) {
        var g = u.type.contextTypes;
        if (!g) return Qi;
        var w = u.stateNode;
        if (w && w.__reactInternalMemoizedUnmaskedChildContext === f) return w.__reactInternalMemoizedMaskedChildContext;
        var C = {},
            T;
        for (T in g) C[T] = f[T];
        return w && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = f, u.__reactInternalMemoizedMaskedChildContext = C), C
    }

    function mi(u) {
        return u = u.childContextTypes, u != null
    }

    function Hd() {
        ct(Rn), ct(Ft)
    }

    function xw(u, f, g) {
        if (Ft.current !== Qi) throw Error(o(168));
        Et(Ft, f), Et(Rn, g)
    }

    function _w(u, f, g) {
        var w = u.stateNode;
        if (f = f.childContextTypes, typeof w.getChildContext != "function") return g;
        w = w.getChildContext();
        for (var C in w)
            if (!(C in f)) throw Error(o(108, E(u) || "Unknown", C));
        return s({}, g, w)
    }

    function Vd(u) {
        return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || Qi, cs = Ft.current, Et(Ft, u), Et(Rn, Rn.current), !0
    }

    function ww(u, f, g) {
        var w = u.stateNode;
        if (!w) throw Error(o(169));
        g ? (u = _w(u, f, cs), w.__reactInternalMemoizedMergedChildContext = u, ct(Rn), ct(Ft), Et(Ft, u)) : ct(Rn), Et(Rn, g)
    }
    var Ar = Math.clz32 ? Math.clz32 : II,
        PI = Math.log,
        RI = Math.LN2;

    function II(u) {
        return u >>>= 0, u === 0 ? 32 : 31 - (PI(u) / RI | 0) | 0
    }
    var Wd = 64,
        jd = 4194304;

    function ic(u) {
        switch (u & -u) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return u & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return u & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return u
        }
    }

    function Jd(u, f) {
        var g = u.pendingLanes;
        if (g === 0) return 0;
        var w = 0,
            C = u.suspendedLanes,
            T = u.pingedLanes,
            N = g & 268435455;
        if (N !== 0) {
            var X = N & ~C;
            X !== 0 ? w = ic(X) : (T &= N, T !== 0 && (w = ic(T)))
        } else N = g & ~C, N !== 0 ? w = ic(N) : T !== 0 && (w = ic(T));
        if (w === 0) return 0;
        if (f !== 0 && f !== w && !(f & C) && (C = w & -w, T = f & -f, C >= T || C === 16 && (T & 4194240) !== 0)) return f;
        if (w & 4 && (w |= g & 16), f = u.entangledLanes, f !== 0)
            for (u = u.entanglements, f &= w; 0 < f;) g = 31 - Ar(f), C = 1 << g, w |= u[g], f &= ~C;
        return w
    }

    function LI(u, f) {
        switch (u) {
            case 1:
            case 2:
            case 4:
                return f + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return f + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }

    function DI(u, f) {
        for (var g = u.suspendedLanes, w = u.pingedLanes, C = u.expirationTimes, T = u.pendingLanes; 0 < T;) {
            var N = 31 - Ar(T),
                X = 1 << N,
                de = C[N];
            de === -1 ? (!(X & g) || X & w) && (C[N] = LI(X, f)) : de <= f && (u.expiredLanes |= X), T &= ~X
        }
    }

    function qg(u) {
        return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0
    }

    function $g(u) {
        for (var f = [], g = 0; 31 > g; g++) f.push(u);
        return f
    }

    function rc(u, f, g) {
        u.pendingLanes |= f, f !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, f = 31 - Ar(f), u[f] = g
    }

    function FI(u, f) {
        var g = u.pendingLanes & ~f;
        u.pendingLanes = f, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= f, u.mutableReadLanes &= f, u.entangledLanes &= f, f = u.entanglements;
        var w = u.eventTimes;
        for (u = u.expirationTimes; 0 < g;) {
            var C = 31 - Ar(g),
                T = 1 << C;
            f[C] = 0, w[C] = -1, u[C] = -1, g &= ~T
        }
    }

    function e0(u, f) {
        var g = u.entangledLanes |= f;
        for (u = u.entanglements; g;) {
            var w = 31 - Ar(g),
                C = 1 << w;
            C & f | u[w] & f && (u[w] |= f), g &= ~C
        }
    }
    var Rt = 0;

    function Sw(u) {
        return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var t0 = r.unstable_scheduleCallback,
        Mw = r.unstable_cancelCallback,
        kI = r.unstable_shouldYield,
        NI = r.unstable_requestPaint,
        In = r.unstable_now,
        n0 = r.unstable_ImmediatePriority,
        OI = r.unstable_UserBlockingPriority,
        i0 = r.unstable_NormalPriority,
        UI = r.unstable_IdlePriority,
        Xd = null,
        Hr = null;

    function zI(u) {
        if (Hr && typeof Hr.onCommitFiberRoot == "function") try {
            Hr.onCommitFiberRoot(Xd, u, void 0, (u.current.flags & 128) === 128)
        } catch {}
    }

    function GI(u, f) {
        return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f
    }
    var Vr = typeof Object.is == "function" ? Object.is : GI,
        ds = null,
        Qd = !1,
        r0 = !1;

    function Cw(u) {
        ds === null ? ds = [u] : ds.push(u)
    }

    function HI(u) {
        Qd = !0, Cw(u)
    }

    function Wr() {
        if (!r0 && ds !== null) {
            r0 = !0;
            var u = 0,
                f = Rt;
            try {
                var g = ds;
                for (Rt = 1; u < g.length; u++) {
                    var w = g[u];
                    do w = w(!0); while (w !== null)
                }
                ds = null, Qd = !1
            } catch (C) {
                throw ds !== null && (ds = ds.slice(u + 1)), t0(n0, Wr), C
            } finally {
                Rt = f, r0 = !1
            }
        }
        return null
    }
    var VI = a.ReactCurrentBatchConfig;

    function Kd(u, f) {
        if (Vr(u, f)) return !0;
        if (typeof u != "object" || u === null || typeof f != "object" || f === null) return !1;
        var g = Object.keys(u),
            w = Object.keys(f);
        if (g.length !== w.length) return !1;
        for (w = 0; w < g.length; w++) {
            var C = g[w];
            if (!us.call(f, C) || !Vr(u[C], f[C])) return !1
        }
        return !0
    }

    function WI(u) {
        switch (u.tag) {
            case 5:
                return dt(u.type);
            case 16:
                return dt("Lazy");
            case 13:
                return dt("Suspense");
            case 19:
                return dt("SuspenseList");
            case 0:
            case 2:
            case 15:
                return u = an(u.type, !1), u;
            case 11:
                return u = an(u.type.render, !1), u;
            case 1:
                return u = an(u.type, !0), u;
            default:
                return ""
        }
    }

    function xr(u, f) {
        if (u && u.defaultProps) {
            f = s({}, f), u = u.defaultProps;
            for (var g in u) f[g] === void 0 && (f[g] = u[g]);
            return f
        }
        return f
    }
    var Yd = Xi(null),
        Zd = null,
        gl = null,
        s0 = null;

    function o0() {
        s0 = gl = Zd = null
    }

    function Ew(u, f, g) {
        we ? (Et(Yd, f._currentValue), f._currentValue = g) : (Et(Yd, f._currentValue2), f._currentValue2 = g)
    }

    function a0(u) {
        var f = Yd.current;
        ct(Yd), we ? u._currentValue = f : u._currentValue2 = f
    }

    function l0(u, f, g) {
        for (; u !== null;) {
            var w = u.alternate;
            if ((u.childLanes & f) !== f ? (u.childLanes |= f, w !== null && (w.childLanes |= f)) : w !== null && (w.childLanes & f) !== f && (w.childLanes |= f), u === g) break;
            u = u.return
        }
    }

    function yl(u, f) {
        Zd = u, s0 = gl = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & f && (Pi = !0), u.firstContext = null)
    }

    function Ki(u) {
        var f = we ? u._currentValue : u._currentValue2;
        if (s0 !== u)
            if (u = {
                    context: u,
                    memoizedValue: f,
                    next: null
                }, gl === null) {
                if (Zd === null) throw Error(o(308));
                gl = u, Zd.dependencies = {
                    lanes: 0,
                    firstContext: u
                }
            } else gl = gl.next = u;
        return f
    }
    var jr = null,
        Ys = !1;

    function u0(u) {
        u.updateQueue = {
            baseState: u.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }

    function bw(u, f) {
        u = u.updateQueue, f.updateQueue === u && (f.updateQueue = {
            baseState: u.baseState,
            firstBaseUpdate: u.firstBaseUpdate,
            lastBaseUpdate: u.lastBaseUpdate,
            shared: u.shared,
            effects: u.effects
        })
    }

    function hs(u, f) {
        return {
            eventTime: u,
            lane: f,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }

    function Zs(u, f) {
        var g = u.updateQueue;
        g !== null && (g = g.shared, yn !== null && u.mode & 1 && !(gt & 2) ? (u = g.interleaved, u === null ? (f.next = f, jr === null ? jr = [g] : jr.push(g)) : (f.next = u.next, u.next = f), g.interleaved = f) : (u = g.pending, u === null ? f.next = f : (f.next = u.next, u.next = f), g.pending = f))
    }

    function qd(u, f, g) {
        if (f = f.updateQueue, f !== null && (f = f.shared, (g & 4194240) !== 0)) {
            var w = f.lanes;
            w &= u.pendingLanes, g |= w, f.lanes = g, e0(u, g)
        }
    }

    function Tw(u, f) {
        var g = u.updateQueue,
            w = u.alternate;
        if (w !== null && (w = w.updateQueue, g === w)) {
            var C = null,
                T = null;
            if (g = g.firstBaseUpdate, g !== null) {
                do {
                    var N = {
                        eventTime: g.eventTime,
                        lane: g.lane,
                        tag: g.tag,
                        payload: g.payload,
                        callback: g.callback,
                        next: null
                    };
                    T === null ? C = T = N : T = T.next = N, g = g.next
                } while (g !== null);
                T === null ? C = T = f : T = T.next = f
            } else C = T = f;
            g = {
                baseState: w.baseState,
                firstBaseUpdate: C,
                lastBaseUpdate: T,
                shared: w.shared,
                effects: w.effects
            }, u.updateQueue = g;
            return
        }
        u = g.lastBaseUpdate, u === null ? g.firstBaseUpdate = f : u.next = f, g.lastBaseUpdate = f
    }

    function $d(u, f, g, w) {
        var C = u.updateQueue;
        Ys = !1;
        var T = C.firstBaseUpdate,
            N = C.lastBaseUpdate,
            X = C.shared.pending;
        if (X !== null) {
            C.shared.pending = null;
            var de = X,
                be = de.next;
            de.next = null, N === null ? T = be : N.next = be, N = de;
            var Ve = u.alternate;
            Ve !== null && (Ve = Ve.updateQueue, X = Ve.lastBaseUpdate, X !== N && (X === null ? Ve.firstBaseUpdate = be : X.next = be, Ve.lastBaseUpdate = de))
        }
        if (T !== null) {
            var ot = C.baseState;
            N = 0, Ve = be = de = null, X = T;
            do {
                var et = X.lane,
                    Ut = X.eventTime;
                if ((w & et) === et) {
                    Ve !== null && (Ve = Ve.next = {
                        eventTime: Ut,
                        lane: 0,
                        tag: X.tag,
                        payload: X.payload,
                        callback: X.callback,
                        next: null
                    });
                    e: {
                        var Ye = u,
                            Xn = X;
                        switch (et = f, Ut = g, Xn.tag) {
                            case 1:
                                if (Ye = Xn.payload, typeof Ye == "function") {
                                    ot = Ye.call(Ut, ot, et);
                                    break e
                                }
                                ot = Ye;
                                break e;
                            case 3:
                                Ye.flags = Ye.flags & -65537 | 128;
                            case 0:
                                if (Ye = Xn.payload, et = typeof Ye == "function" ? Ye.call(Ut, ot, et) : Ye, et == null) break e;
                                ot = s({}, ot, et);
                                break e;
                            case 2:
                                Ys = !0
                        }
                    }
                    X.callback !== null && X.lane !== 0 && (u.flags |= 64, et = C.effects, et === null ? C.effects = [X] : et.push(X))
                } else Ut = {
                    eventTime: Ut,
                    lane: et,
                    tag: X.tag,
                    payload: X.payload,
                    callback: X.callback,
                    next: null
                }, Ve === null ? (be = Ve = Ut, de = ot) : Ve = Ve.next = Ut, N |= et;
                if (X = X.next, X === null) {
                    if (X = C.shared.pending, X === null) break;
                    et = X, X = et.next, et.next = null, C.lastBaseUpdate = et, C.shared.pending = null
                }
            } while (1);
            if (Ve === null && (de = ot), C.baseState = de, C.firstBaseUpdate = be, C.lastBaseUpdate = Ve, f = C.shared.interleaved, f !== null) {
                C = f;
                do N |= C.lane, C = C.next; while (C !== f)
            } else T === null && (C.shared.lanes = 0);
            El |= N, u.lanes = N, u.memoizedState = ot
        }
    }

    function Bw(u, f, g) {
        if (u = f.effects, f.effects = null, u !== null)
            for (f = 0; f < u.length; f++) {
                var w = u[f],
                    C = w.callback;
                if (C !== null) {
                    if (w.callback = null, w = g, typeof C != "function") throw Error(o(191, C));
                    C.call(w)
                }
            }
    }
    var Pw = new i.Component().refs;

    function c0(u, f, g, w) {
        f = u.memoizedState, g = g(w, f), g = g == null ? f : s({}, f, g), u.memoizedState = g, u.lanes === 0 && (u.updateQueue.baseState = g)
    }
    var eh = {
        isMounted: function(u) {
            return (u = u._reactInternals) ? P(u) === u : !1
        },
        enqueueSetState: function(u, f, g) {
            u = u._reactInternals;
            var w = ii(),
                C = eo(u),
                T = hs(w, C);
            T.payload = f, g != null && (T.callback = g), Zs(u, T), f = er(u, C, w), f !== null && qd(f, u, C)
        },
        enqueueReplaceState: function(u, f, g) {
            u = u._reactInternals;
            var w = ii(),
                C = eo(u),
                T = hs(w, C);
            T.tag = 1, T.payload = f, g != null && (T.callback = g), Zs(u, T), f = er(u, C, w), f !== null && qd(f, u, C)
        },
        enqueueForceUpdate: function(u, f) {
            u = u._reactInternals;
            var g = ii(),
                w = eo(u),
                C = hs(g, w);
            C.tag = 2, f != null && (C.callback = f), Zs(u, C), f = er(u, w, g), f !== null && qd(f, u, w)
        }
    };

    function Rw(u, f, g, w, C, T, N) {
        return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(w, T, N) : f.prototype && f.prototype.isPureReactComponent ? !Kd(g, w) || !Kd(C, T) : !0
    }

    function Iw(u, f, g) {
        var w = !1,
            C = Qi,
            T = f.contextType;
        return typeof T == "object" && T !== null ? T = Ki(T) : (C = mi(f) ? cs : Ft.current, w = f.contextTypes, T = (w = w != null) ? fs(u, C) : Qi), f = new f(g, T), u.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null, f.updater = eh, u.stateNode = f, f._reactInternals = u, w && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = C, u.__reactInternalMemoizedMaskedChildContext = T), f
    }

    function Lw(u, f, g, w) {
        u = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(g, w), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(g, w), f.state !== u && eh.enqueueReplaceState(f, f.state, null)
    }

    function f0(u, f, g, w) {
        var C = u.stateNode;
        C.props = g, C.state = u.memoizedState, C.refs = Pw, u0(u);
        var T = f.contextType;
        typeof T == "object" && T !== null ? C.context = Ki(T) : (T = mi(f) ? cs : Ft.current, C.context = fs(u, T)), C.state = u.memoizedState, T = f.getDerivedStateFromProps, typeof T == "function" && (c0(u, f, T, g), C.state = u.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (f = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), f !== C.state && eh.enqueueReplaceState(C, C.state, null), $d(u, g, C, w), C.state = u.memoizedState), typeof C.componentDidMount == "function" && (u.flags |= 4194308)
    }
    var vl = [],
        Al = 0,
        th = null,
        nh = 0,
        Yi = [],
        Zi = 0,
        ia = null,
        ps = 1,
        ms = "";

    function ra(u, f) {
        vl[Al++] = nh, vl[Al++] = th, th = u, nh = f
    }

    function Dw(u, f, g) {
        Yi[Zi++] = ps, Yi[Zi++] = ms, Yi[Zi++] = ia, ia = u;
        var w = ps;
        u = ms;
        var C = 32 - Ar(w) - 1;
        w &= ~(1 << C), g += 1;
        var T = 32 - Ar(f) + C;
        if (30 < T) {
            var N = C - C % 5;
            T = (w & (1 << N) - 1).toString(32), w >>= N, C -= N, ps = 1 << 32 - Ar(f) + C | g << C | w, ms = T + u
        } else ps = 1 << T | g << C | w, ms = u
    }

    function d0(u) {
        u.return !== null && (ra(u, 1), Dw(u, 1, 0))
    }

    function h0(u) {
        for (; u === th;) th = vl[--Al], vl[Al] = null, nh = vl[--Al], vl[Al] = null;
        for (; u === ia;) ia = Yi[--Zi], Yi[Zi] = null, ms = Yi[--Zi], Yi[Zi] = null, ps = Yi[--Zi], Yi[Zi] = null
    }
    var Ti = null,
        Bi = null,
        Xt = !1,
        sc = !1,
        _r = null;

    function Fw(u, f) {
        var g = tr(5, null, null, 0);
        g.elementType = "DELETED", g.stateNode = f, g.return = u, f = u.deletions, f === null ? (u.deletions = [g], u.flags |= 16) : f.push(g)
    }

    function kw(u, f) {
        switch (u.tag) {
            case 5:
                return f = pi(f, u.type, u.pendingProps), f !== null ? (u.stateNode = f, Ti = u, Bi = pe(f), !0) : !1;
            case 6:
                return f = zd(f, u.pendingProps), f !== null ? (u.stateNode = f, Ti = u, Bi = null, !0) : !1;
            case 13:
                if (f = Zg(f), f !== null) {
                    var g = ia !== null ? {
                        id: ps,
                        overflow: ms
                    } : null;
                    return u.memoizedState = {
                        dehydrated: f,
                        treeContext: g,
                        retryLane: 1073741824
                    }, g = tr(18, null, null, 0), g.stateNode = f, g.return = u, u.child = g, Ti = u, Bi = null, !0
                }
                return !1;
            default:
                return !1
        }
    }

    function p0(u) {
        return (u.mode & 1) !== 0 && (u.flags & 128) === 0
    }

    function m0(u) {
        if (Xt) {
            var f = Bi;
            if (f) {
                var g = f;
                if (!kw(u, f)) {
                    if (p0(u)) throw Error(o(418));
                    f = ee(g);
                    var w = Ti;
                    f && kw(u, f) ? Fw(w, g) : (u.flags = u.flags & -4097 | 2, Xt = !1, Ti = u)
                }
            } else {
                if (p0(u)) throw Error(o(418));
                u.flags = u.flags & -4097 | 2, Xt = !1, Ti = u
            }
        }
    }

    function Nw(u) {
        for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13;) u = u.return;
        Ti = u
    }

    function oc(u) {
        if (!ae || u !== Ti) return !1;
        if (!Xt) return Nw(u), Xt = !0, !1;
        if (u.tag !== 3 && (u.tag !== 5 || ti(u.type) && !xe(u.type, u.memoizedProps))) {
            var f = Bi;
            if (f) {
                if (p0(u)) {
                    for (u = Bi; u;) u = ee(u);
                    throw Error(o(418))
                }
                for (; f;) Fw(u, f), f = ee(f)
            }
        }
        if (Nw(u), u.tag === 13) {
            if (!ae) throw Error(o(316));
            if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317));
            Bi = mt(u)
        } else Bi = Ti ? ee(u.stateNode) : null;
        return !0
    }

    function xl() {
        ae && (Bi = Ti = null, sc = Xt = !1)
    }

    function g0(u) {
        _r === null ? _r = [u] : _r.push(u)
    }

    function ac(u, f, g) {
        if (u = g.ref, u !== null && typeof u != "function" && typeof u != "object") {
            if (g._owner) {
                if (g = g._owner, g) {
                    if (g.tag !== 1) throw Error(o(309));
                    var w = g.stateNode
                }
                if (!w) throw Error(o(147, u));
                var C = w,
                    T = "" + u;
                return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === T ? f.ref : (f = function(N) {
                    var X = C.refs;
                    X === Pw && (X = C.refs = {}), N === null ? delete X[T] : X[T] = N
                }, f._stringRef = T, f)
            }
            if (typeof u != "string") throw Error(o(284));
            if (!g._owner) throw Error(o(290, u))
        }
        return u
    }

    function ih(u, f) {
        throw u = Object.prototype.toString.call(f), Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : u))
    }

    function Ow(u) {
        var f = u._init;
        return f(u._payload)
    }

    function Uw(u) {
        function f(ne, Y) {
            if (u) {
                var ce = ne.deletions;
                ce === null ? (ne.deletions = [Y], ne.flags |= 16) : ce.push(Y)
            }
        }

        function g(ne, Y) {
            if (!u) return null;
            for (; Y !== null;) f(ne, Y), Y = Y.sibling;
            return null
        }

        function w(ne, Y) {
            for (ne = new Map; Y !== null;) Y.key !== null ? ne.set(Y.key, Y) : ne.set(Y.index, Y), Y = Y.sibling;
            return ne
        }

        function C(ne, Y) {
            return ne = no(ne, Y), ne.index = 0, ne.sibling = null, ne
        }

        function T(ne, Y, ce) {
            return ne.index = ce, u ? (ce = ne.alternate, ce !== null ? (ce = ce.index, ce < Y ? (ne.flags |= 2, Y) : ce) : (ne.flags |= 2, Y)) : (ne.flags |= 1048576, Y)
        }

        function N(ne) {
            return u && ne.alternate === null && (ne.flags |= 2), ne
        }

        function X(ne, Y, ce, ke) {
            return Y === null || Y.tag !== 6 ? (Y = $0(ce, ne.mode, ke), Y.return = ne, Y) : (Y = C(Y, ce), Y.return = ne, Y)
        }

        function de(ne, Y, ce, ke) {
            var Qe = ce.type;
            return Qe === d ? Ve(ne, Y, ce.props.children, ke, ce.key) : Y !== null && (Y.elementType === Qe || typeof Qe == "object" && Qe !== null && Qe.$$typeof === S && Ow(Qe) === Y.type) ? (ke = C(Y, ce.props), ke.ref = ac(ne, Y, ce), ke.return = ne, ke) : (ke = Dh(ce.type, ce.key, ce.props, null, ne.mode, ke), ke.ref = ac(ne, Y, ce), ke.return = ne, ke)
        }

        function be(ne, Y, ce, ke) {
            return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== ce.containerInfo || Y.stateNode.implementation !== ce.implementation ? (Y = ey(ce, ne.mode, ke), Y.return = ne, Y) : (Y = C(Y, ce.children || []), Y.return = ne, Y)
        }

        function Ve(ne, Y, ce, ke, Qe) {
            return Y === null || Y.tag !== 7 ? (Y = fa(ce, ne.mode, ke, Qe), Y.return = ne, Y) : (Y = C(Y, ce), Y.return = ne, Y)
        }

        function ot(ne, Y, ce) {
            if (typeof Y == "string" && Y !== "" || typeof Y == "number") return Y = $0("" + Y, ne.mode, ce), Y.return = ne, Y;
            if (typeof Y == "object" && Y !== null) {
                switch (Y.$$typeof) {
                    case l:
                        return ce = Dh(Y.type, Y.key, Y.props, null, ne.mode, ce), ce.ref = ac(ne, null, Y), ce.return = ne, ce;
                    case c:
                        return Y = ey(Y, ne.mode, ce), Y.return = ne, Y;
                    case S:
                        var ke = Y._init;
                        return ot(ne, ke(Y._payload), ce)
                }
                if (K(Y) || B(Y)) return Y = fa(Y, ne.mode, ce, null), Y.return = ne, Y;
                ih(ne, Y)
            }
            return null
        }

        function et(ne, Y, ce, ke) {
            var Qe = Y !== null ? Y.key : null;
            if (typeof ce == "string" && ce !== "" || typeof ce == "number") return Qe !== null ? null : X(ne, Y, "" + ce, ke);
            if (typeof ce == "object" && ce !== null) {
                switch (ce.$$typeof) {
                    case l:
                        return ce.key === Qe ? de(ne, Y, ce, ke) : null;
                    case c:
                        return ce.key === Qe ? be(ne, Y, ce, ke) : null;
                    case S:
                        return Qe = ce._init, et(ne, Y, Qe(ce._payload), ke)
                }
                if (K(ce) || B(ce)) return Qe !== null ? null : Ve(ne, Y, ce, ke, null);
                ih(ne, ce)
            }
            return null
        }

        function Ut(ne, Y, ce, ke, Qe) {
            if (typeof ke == "string" && ke !== "" || typeof ke == "number") return ne = ne.get(ce) || null, X(Y, ne, "" + ke, Qe);
            if (typeof ke == "object" && ke !== null) {
                switch (ke.$$typeof) {
                    case l:
                        return ne = ne.get(ke.key === null ? ce : ke.key) || null, de(Y, ne, ke, Qe);
                    case c:
                        return ne = ne.get(ke.key === null ? ce : ke.key) || null, be(Y, ne, ke, Qe);
                    case S:
                        var ht = ke._init;
                        return Ut(ne, Y, ce, ht(ke._payload), Qe)
                }
                if (K(ke) || B(ke)) return ne = ne.get(ce) || null, Ve(Y, ne, ke, Qe, null);
                ih(Y, ke)
            }
            return null
        }

        function Ye(ne, Y, ce, ke) {
            for (var Qe = null, ht = null, at = Y, It = Y = 0, Dn = null; at !== null && It < ce.length; It++) {
                at.index > It ? (Dn = at, at = null) : Dn = at.sibling;
                var Lt = et(ne, at, ce[It], ke);
                if (Lt === null) {
                    at === null && (at = Dn);
                    break
                }
                u && at && Lt.alternate === null && f(ne, at), Y = T(Lt, Y, It), ht === null ? Qe = Lt : ht.sibling = Lt, ht = Lt, at = Dn
            }
            if (It === ce.length) return g(ne, at), Xt && ra(ne, It), Qe;
            if (at === null) {
                for (; It < ce.length; It++) at = ot(ne, ce[It], ke), at !== null && (Y = T(at, Y, It), ht === null ? Qe = at : ht.sibling = at, ht = at);
                return Xt && ra(ne, It), Qe
            }
            for (at = w(ne, at); It < ce.length; It++) Dn = Ut(at, ne, It, ce[It], ke), Dn !== null && (u && Dn.alternate !== null && at.delete(Dn.key === null ? It : Dn.key), Y = T(Dn, Y, It), ht === null ? Qe = Dn : ht.sibling = Dn, ht = Dn);
            return u && at.forEach(function(io) {
                return f(ne, io)
            }), Xt && ra(ne, It), Qe
        }

        function Xn(ne, Y, ce, ke) {
            var Qe = B(ce);
            if (typeof Qe != "function") throw Error(o(150));
            if (ce = Qe.call(ce), ce == null) throw Error(o(151));
            for (var ht = Qe = null, at = Y, It = Y = 0, Dn = null, Lt = ce.next(); at !== null && !Lt.done; It++, Lt = ce.next()) {
                at.index > It ? (Dn = at, at = null) : Dn = at.sibling;
                var io = et(ne, at, Lt.value, ke);
                if (io === null) {
                    at === null && (at = Dn);
                    break
                }
                u && at && io.alternate === null && f(ne, at), Y = T(io, Y, It), ht === null ? Qe = io : ht.sibling = io, ht = io, at = Dn
            }
            if (Lt.done) return g(ne, at), Xt && ra(ne, It), Qe;
            if (at === null) {
                for (; !Lt.done; It++, Lt = ce.next()) Lt = ot(ne, Lt.value, ke), Lt !== null && (Y = T(Lt, Y, It), ht === null ? Qe = Lt : ht.sibling = Lt, ht = Lt);
                return Xt && ra(ne, It), Qe
            }
            for (at = w(ne, at); !Lt.done; It++, Lt = ce.next()) Lt = Ut(at, ne, It, Lt.value, ke), Lt !== null && (u && Lt.alternate !== null && at.delete(Lt.key === null ? It : Lt.key), Y = T(Lt, Y, It), ht === null ? Qe = Lt : ht.sibling = Lt, ht = Lt);
            return u && at.forEach(function(xL) {
                return f(ne, xL)
            }), Xt && ra(ne, It), Qe
        }

        function nr(ne, Y, ce, ke) {
            if (typeof ce == "object" && ce !== null && ce.type === d && ce.key === null && (ce = ce.props.children), typeof ce == "object" && ce !== null) {
                switch (ce.$$typeof) {
                    case l:
                        e: {
                            for (var Qe = ce.key, ht = Y; ht !== null;) {
                                if (ht.key === Qe) {
                                    if (Qe = ce.type, Qe === d) {
                                        if (ht.tag === 7) {
                                            g(ne, ht.sibling), Y = C(ht, ce.props.children), Y.return = ne, ne = Y;
                                            break e
                                        }
                                    } else if (ht.elementType === Qe || typeof Qe == "object" && Qe !== null && Qe.$$typeof === S && Ow(Qe) === ht.type) {
                                        g(ne, ht.sibling), Y = C(ht, ce.props), Y.ref = ac(ne, ht, ce), Y.return = ne, ne = Y;
                                        break e
                                    }
                                    g(ne, ht);
                                    break
                                } else f(ne, ht);
                                ht = ht.sibling
                            }
                            ce.type === d ? (Y = fa(ce.props.children, ne.mode, ke, ce.key), Y.return = ne, ne = Y) : (ke = Dh(ce.type, ce.key, ce.props, null, ne.mode, ke), ke.ref = ac(ne, Y, ce), ke.return = ne, ne = ke)
                        }
                        return N(ne);
                    case c:
                        e: {
                            for (ht = ce.key; Y !== null;) {
                                if (Y.key === ht)
                                    if (Y.tag === 4 && Y.stateNode.containerInfo === ce.containerInfo && Y.stateNode.implementation === ce.implementation) {
                                        g(ne, Y.sibling), Y = C(Y, ce.children || []), Y.return = ne, ne = Y;
                                        break e
                                    } else {
                                        g(ne, Y);
                                        break
                                    }
                                else f(ne, Y);
                                Y = Y.sibling
                            }
                            Y = ey(ce, ne.mode, ke),
                            Y.return = ne,
                            ne = Y
                        }
                        return N(ne);
                    case S:
                        return ht = ce._init, nr(ne, Y, ht(ce._payload), ke)
                }
                if (K(ce)) return Ye(ne, Y, ce, ke);
                if (B(ce)) return Xn(ne, Y, ce, ke);
                ih(ne, ce)
            }
            return typeof ce == "string" && ce !== "" || typeof ce == "number" ? (ce = "" + ce, Y !== null && Y.tag === 6 ? (g(ne, Y.sibling), Y = C(Y, ce), Y.return = ne, ne = Y) : (g(ne, Y), Y = $0(ce, ne.mode, ke), Y.return = ne, ne = Y), N(ne)) : g(ne, Y)
        }
        return nr
    }
    var _l = Uw(!0),
        zw = Uw(!1),
        lc = {},
        qi = Xi(lc),
        uc = Xi(lc),
        wl = Xi(lc);

    function Jr(u) {
        if (u === lc) throw Error(o(174));
        return u
    }

    function y0(u, f) {
        Et(wl, f), Et(uc, u), Et(qi, lc), u = se(f), ct(qi), Et(qi, u)
    }

    function Sl() {
        ct(qi), ct(uc), ct(wl)
    }

    function Gw(u) {
        var f = Jr(wl.current),
            g = Jr(qi.current);
        f = k(g, u.type, f), g !== f && (Et(uc, u), Et(qi, f))
    }

    function v0(u) {
        uc.current === u && (ct(qi), ct(uc))
    }
    var Zt = Xi(0);

    function rh(u) {
        for (var f = u; f !== null;) {
            if (f.tag === 13) {
                var g = f.memoizedState;
                if (g !== null && (g = g.dehydrated, g === null || Gd(g) || nc(g))) return f
            } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
                if (f.flags & 128) return f
            } else if (f.child !== null) {
                f.child.return = f, f = f.child;
                continue
            }
            if (f === u) break;
            for (; f.sibling === null;) {
                if (f.return === null || f.return === u) return null;
                f = f.return
            }
            f.sibling.return = f.return, f = f.sibling
        }
        return null
    }
    var A0 = [];

    function x0() {
        for (var u = 0; u < A0.length; u++) {
            var f = A0[u];
            we ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null
        }
        A0.length = 0
    }
    var sh = a.ReactCurrentDispatcher,
        $i = a.ReactCurrentBatchConfig,
        Ml = 0,
        ln = null,
        Wn = null,
        Ln = null,
        oh = !1,
        cc = !1,
        fc = 0,
        jI = 0;

    function jn() {
        throw Error(o(321))
    }

    function _0(u, f) {
        if (f === null) return !1;
        for (var g = 0; g < f.length && g < u.length; g++)
            if (!Vr(u[g], f[g])) return !1;
        return !0
    }

    function w0(u, f, g, w, C, T) {
        if (Ml = T, ln = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, sh.current = u === null || u.memoizedState === null ? KI : YI, u = g(w, C), cc) {
            T = 0;
            do {
                if (cc = !1, fc = 0, 25 <= T) throw Error(o(301));
                T += 1, Ln = Wn = null, f.updateQueue = null, sh.current = ZI, u = g(w, C)
            } while (cc)
        }
        if (sh.current = fh, f = Wn !== null && Wn.next !== null, Ml = 0, Ln = Wn = ln = null, oh = !1, f) throw Error(o(300));
        return u
    }

    function S0() {
        var u = fc !== 0;
        return fc = 0, u
    }

    function gs() {
        var u = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Ln === null ? ln.memoizedState = Ln = u : Ln = Ln.next = u, Ln
    }

    function Xr() {
        if (Wn === null) {
            var u = ln.alternate;
            u = u !== null ? u.memoizedState : null
        } else u = Wn.next;
        var f = Ln === null ? ln.memoizedState : Ln.next;
        if (f !== null) Ln = f, Wn = u;
        else {
            if (u === null) throw Error(o(310));
            Wn = u, u = {
                memoizedState: Wn.memoizedState,
                baseState: Wn.baseState,
                baseQueue: Wn.baseQueue,
                queue: Wn.queue,
                next: null
            }, Ln === null ? ln.memoizedState = Ln = u : Ln = Ln.next = u
        }
        return Ln
    }

    function sa(u, f) {
        return typeof f == "function" ? f(u) : f
    }

    function ah(u) {
        var f = Xr(),
            g = f.queue;
        if (g === null) throw Error(o(311));
        g.lastRenderedReducer = u;
        var w = Wn,
            C = w.baseQueue,
            T = g.pending;
        if (T !== null) {
            if (C !== null) {
                var N = C.next;
                C.next = T.next, T.next = N
            }
            w.baseQueue = C = T, g.pending = null
        }
        if (C !== null) {
            T = C.next, w = w.baseState;
            var X = N = null,
                de = null,
                be = T;
            do {
                var Ve = be.lane;
                if ((Ml & Ve) === Ve) de !== null && (de = de.next = {
                    lane: 0,
                    action: be.action,
                    hasEagerState: be.hasEagerState,
                    eagerState: be.eagerState,
                    next: null
                }), w = be.hasEagerState ? be.eagerState : u(w, be.action);
                else {
                    var ot = {
                        lane: Ve,
                        action: be.action,
                        hasEagerState: be.hasEagerState,
                        eagerState: be.eagerState,
                        next: null
                    };
                    de === null ? (X = de = ot, N = w) : de = de.next = ot, ln.lanes |= Ve, El |= Ve
                }
                be = be.next
            } while (be !== null && be !== T);
            de === null ? N = w : de.next = X, Vr(w, f.memoizedState) || (Pi = !0), f.memoizedState = w, f.baseState = N, f.baseQueue = de, g.lastRenderedState = w
        }
        if (u = g.interleaved, u !== null) {
            C = u;
            do T = C.lane, ln.lanes |= T, El |= T, C = C.next; while (C !== u)
        } else C === null && (g.lanes = 0);
        return [f.memoizedState, g.dispatch]
    }

    function lh(u) {
        var f = Xr(),
            g = f.queue;
        if (g === null) throw Error(o(311));
        g.lastRenderedReducer = u;
        var w = g.dispatch,
            C = g.pending,
            T = f.memoizedState;
        if (C !== null) {
            g.pending = null;
            var N = C = C.next;
            do T = u(T, N.action), N = N.next; while (N !== C);
            Vr(T, f.memoizedState) || (Pi = !0), f.memoizedState = T, f.baseQueue === null && (f.baseState = T), g.lastRenderedState = T
        }
        return [T, w]
    }

    function Hw() {}

    function Vw(u, f) {
        var g = ln,
            w = Xr(),
            C = f(),
            T = !Vr(w.memoizedState, C);
        if (T && (w.memoizedState = C, Pi = !0), w = w.queue, hc(Jw.bind(null, g, w, u), [u]), w.getSnapshot !== f || T || Ln !== null && Ln.memoizedState.tag & 1) {
            if (g.flags |= 2048, dc(9, jw.bind(null, g, w, C, f), void 0, null), yn === null) throw Error(o(349));
            Ml & 30 || Ww(g, f, C)
        }
        return C
    }

    function Ww(u, f, g) {
        u.flags |= 16384, u = {
            getSnapshot: f,
            value: g
        }, f = ln.updateQueue, f === null ? (f = {
            lastEffect: null,
            stores: null
        }, ln.updateQueue = f, f.stores = [u]) : (g = f.stores, g === null ? f.stores = [u] : g.push(u))
    }

    function jw(u, f, g, w) {
        f.value = g, f.getSnapshot = w, Xw(f) && er(u, 1, -1)
    }

    function Jw(u, f, g) {
        return g(function() {
            Xw(f) && er(u, 1, -1)
        })
    }

    function Xw(u) {
        var f = u.getSnapshot;
        u = u.value;
        try {
            var g = f();
            return !Vr(u, g)
        } catch {
            return !0
        }
    }

    function M0(u) {
        var f = gs();
        return typeof u == "function" && (u = u()), f.memoizedState = f.baseState = u, u = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: sa,
            lastRenderedState: u
        }, f.queue = u, u = u.dispatch = QI.bind(null, ln, u), [f.memoizedState, u]
    }

    function dc(u, f, g, w) {
        return u = {
            tag: u,
            create: f,
            destroy: g,
            deps: w,
            next: null
        }, f = ln.updateQueue, f === null ? (f = {
            lastEffect: null,
            stores: null
        }, ln.updateQueue = f, f.lastEffect = u.next = u) : (g = f.lastEffect, g === null ? f.lastEffect = u.next = u : (w = g.next, g.next = u, u.next = w, f.lastEffect = u)), u
    }

    function Qw() {
        return Xr().memoizedState
    }

    function uh(u, f, g, w) {
        var C = gs();
        ln.flags |= u, C.memoizedState = dc(1 | f, g, void 0, w === void 0 ? null : w)
    }

    function ch(u, f, g, w) {
        var C = Xr();
        w = w === void 0 ? null : w;
        var T = void 0;
        if (Wn !== null) {
            var N = Wn.memoizedState;
            if (T = N.destroy, w !== null && _0(w, N.deps)) {
                C.memoizedState = dc(f, g, T, w);
                return
            }
        }
        ln.flags |= u, C.memoizedState = dc(1 | f, g, T, w)
    }

    function C0(u, f) {
        return uh(8390656, 8, u, f)
    }

    function hc(u, f) {
        return ch(2048, 8, u, f)
    }

    function Kw(u, f) {
        return ch(4, 2, u, f)
    }

    function Yw(u, f) {
        return ch(4, 4, u, f)
    }

    function Zw(u, f) {
        if (typeof f == "function") return u = u(), f(u),
            function() {
                f(null)
            };
        if (f != null) return u = u(), f.current = u,
            function() {
                f.current = null
            }
    }

    function qw(u, f, g) {
        return g = g != null ? g.concat([u]) : null, ch(4, 4, Zw.bind(null, f, u), g)
    }

    function E0() {}

    function $w(u, f) {
        var g = Xr();
        f = f === void 0 ? null : f;
        var w = g.memoizedState;
        return w !== null && f !== null && _0(f, w[1]) ? w[0] : (g.memoizedState = [u, f], u)
    }

    function eS(u, f) {
        var g = Xr();
        f = f === void 0 ? null : f;
        var w = g.memoizedState;
        return w !== null && f !== null && _0(f, w[1]) ? w[0] : (u = u(), g.memoizedState = [u, f], u)
    }

    function JI(u, f) {
        var g = Rt;
        Rt = g !== 0 && 4 > g ? g : 4, u(!0);
        var w = $i.transition;
        $i.transition = {};
        try {
            u(!1), f()
        } finally {
            Rt = g, $i.transition = w
        }
    }

    function tS() {
        return Xr().memoizedState
    }

    function XI(u, f, g) {
        var w = eo(u);
        g = {
            lane: w,
            action: g,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, nS(u) ? iS(f, g) : (rS(u, f, g), g = ii(), u = er(u, w, g), u !== null && sS(u, f, w))
    }

    function QI(u, f, g) {
        var w = eo(u),
            C = {
                lane: w,
                action: g,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
        if (nS(u)) iS(f, C);
        else {
            rS(u, f, C);
            var T = u.alternate;
            if (u.lanes === 0 && (T === null || T.lanes === 0) && (T = f.lastRenderedReducer, T !== null)) try {
                var N = f.lastRenderedState,
                    X = T(N, g);
                if (C.hasEagerState = !0, C.eagerState = X, Vr(X, N)) return
            } catch {} finally {}
            g = ii(), u = er(u, w, g), u !== null && sS(u, f, w)
        }
    }

    function nS(u) {
        var f = u.alternate;
        return u === ln || f !== null && f === ln
    }

    function iS(u, f) {
        cc = oh = !0;
        var g = u.pending;
        g === null ? f.next = f : (f.next = g.next, g.next = f), u.pending = f
    }

    function rS(u, f, g) {
        yn !== null && u.mode & 1 && !(gt & 2) ? (u = f.interleaved, u === null ? (g.next = g, jr === null ? jr = [f] : jr.push(f)) : (g.next = u.next, u.next = g), f.interleaved = g) : (u = f.pending, u === null ? g.next = g : (g.next = u.next, u.next = g), f.pending = g)
    }

    function sS(u, f, g) {
        if (g & 4194240) {
            var w = f.lanes;
            w &= u.pendingLanes, g |= w, f.lanes = g, e0(u, g)
        }
    }
    var fh = {
            readContext: Ki,
            useCallback: jn,
            useContext: jn,
            useEffect: jn,
            useImperativeHandle: jn,
            useInsertionEffect: jn,
            useLayoutEffect: jn,
            useMemo: jn,
            useReducer: jn,
            useRef: jn,
            useState: jn,
            useDebugValue: jn,
            useDeferredValue: jn,
            useTransition: jn,
            useMutableSource: jn,
            useSyncExternalStore: jn,
            useId: jn,
            unstable_isNewReconciler: !1
        },
        KI = {
            readContext: Ki,
            useCallback: function(u, f) {
                return gs().memoizedState = [u, f === void 0 ? null : f], u
            },
            useContext: Ki,
            useEffect: C0,
            useImperativeHandle: function(u, f, g) {
                return g = g != null ? g.concat([u]) : null, uh(4194308, 4, Zw.bind(null, f, u), g)
            },
            useLayoutEffect: function(u, f) {
                return uh(4194308, 4, u, f)
            },
            useInsertionEffect: function(u, f) {
                return uh(4, 2, u, f)
            },
            useMemo: function(u, f) {
                var g = gs();
                return f = f === void 0 ? null : f, u = u(), g.memoizedState = [u, f], u
            },
            useReducer: function(u, f, g) {
                var w = gs();
                return f = g !== void 0 ? g(f) : f, w.memoizedState = w.baseState = f, u = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: u,
                    lastRenderedState: f
                }, w.queue = u, u = u.dispatch = XI.bind(null, ln, u), [w.memoizedState, u]
            },
            useRef: function(u) {
                var f = gs();
                return u = {
                    current: u
                }, f.memoizedState = u
            },
            useState: M0,
            useDebugValue: E0,
            useDeferredValue: function(u) {
                var f = M0(u),
                    g = f[0],
                    w = f[1];
                return C0(function() {
                    var C = $i.transition;
                    $i.transition = {};
                    try {
                        w(u)
                    } finally {
                        $i.transition = C
                    }
                }, [u]), g
            },
            useTransition: function() {
                var u = M0(!1),
                    f = u[0];
                return u = JI.bind(null, u[1]), gs().memoizedState = u, [f, u]
            },
            useMutableSource: function() {},
            useSyncExternalStore: function(u, f, g) {
                var w = ln,
                    C = gs();
                if (Xt) {
                    if (g === void 0) throw Error(o(407));
                    g = g()
                } else {
                    if (g = f(), yn === null) throw Error(o(349));
                    Ml & 30 || Ww(w, f, g)
                }
                C.memoizedState = g;
                var T = {
                    value: g,
                    getSnapshot: f
                };
                return C.queue = T, C0(Jw.bind(null, w, T, u), [u]), w.flags |= 2048, dc(9, jw.bind(null, w, T, g, f), void 0, null), g
            },
            useId: function() {
                var u = gs(),
                    f = yn.identifierPrefix;
                if (Xt) {
                    var g = ms,
                        w = ps;
                    g = (w & ~(1 << 32 - Ar(w) - 1)).toString(32) + g, f = ":" + f + "R" + g, g = fc++, 0 < g && (f += "H" + g.toString(32)), f += ":"
                } else g = jI++, f = ":" + f + "r" + g.toString(32) + ":";
                return u.memoizedState = f
            },
            unstable_isNewReconciler: !1
        },
        YI = {
            readContext: Ki,
            useCallback: $w,
            useContext: Ki,
            useEffect: hc,
            useImperativeHandle: qw,
            useInsertionEffect: Kw,
            useLayoutEffect: Yw,
            useMemo: eS,
            useReducer: ah,
            useRef: Qw,
            useState: function() {
                return ah(sa)
            },
            useDebugValue: E0,
            useDeferredValue: function(u) {
                var f = ah(sa),
                    g = f[0],
                    w = f[1];
                return hc(function() {
                    var C = $i.transition;
                    $i.transition = {};
                    try {
                        w(u)
                    } finally {
                        $i.transition = C
                    }
                }, [u]), g
            },
            useTransition: function() {
                var u = ah(sa)[0],
                    f = Xr().memoizedState;
                return [u, f]
            },
            useMutableSource: Hw,
            useSyncExternalStore: Vw,
            useId: tS,
            unstable_isNewReconciler: !1
        },
        ZI = {
            readContext: Ki,
            useCallback: $w,
            useContext: Ki,
            useEffect: hc,
            useImperativeHandle: qw,
            useInsertionEffect: Kw,
            useLayoutEffect: Yw,
            useMemo: eS,
            useReducer: lh,
            useRef: Qw,
            useState: function() {
                return lh(sa)
            },
            useDebugValue: E0,
            useDeferredValue: function(u) {
                var f = lh(sa),
                    g = f[0],
                    w = f[1];
                return hc(function() {
                    var C = $i.transition;
                    $i.transition = {};
                    try {
                        w(u)
                    } finally {
                        $i.transition = C
                    }
                }, [u]), g
            },
            useTransition: function() {
                var u = lh(sa)[0],
                    f = Xr().memoizedState;
                return [u, f]
            },
            useMutableSource: Hw,
            useSyncExternalStore: Vw,
            useId: tS,
            unstable_isNewReconciler: !1
        };

    function b0(u, f) {
        try {
            var g = "",
                w = f;
            do g += WI(w), w = w.return; while (w);
            var C = g
        } catch (T) {
            C = `
Error generating stack: ` + T.message + `
` + T.stack
        }
        return {
            value: u,
            source: f,
            stack: C
        }
    }

    function T0(u, f) {
        try {
            console.error(f.value)
        } catch (g) {
            setTimeout(function() {
                throw g
            })
        }
    }
    var qI = typeof WeakMap == "function" ? WeakMap : Map;

    function oS(u, f, g) {
        g = hs(-1, g), g.tag = 3, g.payload = {
            element: null
        };
        var w = f.value;
        return g.callback = function() {
            bh || (bh = !0, J0 = w), T0(u, f)
        }, g
    }

    function aS(u, f, g) {
        g = hs(-1, g), g.tag = 3;
        var w = u.type.getDerivedStateFromError;
        if (typeof w == "function") {
            var C = f.value;
            g.payload = function() {
                return w(C)
            }, g.callback = function() {
                T0(u, f)
            }
        }
        var T = u.stateNode;
        return T !== null && typeof T.componentDidCatch == "function" && (g.callback = function() {
            T0(u, f), typeof w != "function" && (qs === null ? qs = new Set([this]) : qs.add(this));
            var N = f.stack;
            this.componentDidCatch(f.value, {
                componentStack: N !== null ? N : ""
            })
        }), g
    }

    function lS(u, f, g) {
        var w = u.pingCache;
        if (w === null) {
            w = u.pingCache = new qI;
            var C = new Set;
            w.set(f, C)
        } else C = w.get(f), C === void 0 && (C = new Set, w.set(f, C));
        C.has(g) || (C.add(g), u = dL.bind(null, u, f, g), f.then(u, u))
    }

    function uS(u) {
        do {
            var f;
            if ((f = u.tag === 13) && (f = u.memoizedState, f = f !== null ? f.dehydrated !== null : !0), f) return u;
            u = u.return
        } while (u !== null);
        return null
    }

    function cS(u, f, g, w, C) {
        return u.mode & 1 ? (u.flags |= 65536, u.lanes = C, u) : (u === f ? u.flags |= 65536 : (u.flags |= 128, g.flags |= 131072, g.flags &= -52805, g.tag === 1 && (g.alternate === null ? g.tag = 17 : (f = hs(-1, 1), f.tag = 2, Zs(g, f))), g.lanes |= 1), u)
    }

    function Qr(u) {
        u.flags |= 4
    }

    function fS(u, f) {
        if (u !== null && u.child === f.child) return !0;
        if (f.flags & 16) return !1;
        for (u = f.child; u !== null;) {
            if (u.flags & 12854 || u.subtreeFlags & 12854) return !1;
            u = u.sibling
        }
        return !0
    }
    var pc, mc, dh, hh;
    if (Le) pc = function(u, f) {
        for (var g = f.child; g !== null;) {
            if (g.tag === 5 || g.tag === 6) j(u, g.stateNode);
            else if (g.tag !== 4 && g.child !== null) {
                g.child.return = g, g = g.child;
                continue
            }
            if (g === f) break;
            for (; g.sibling === null;) {
                if (g.return === null || g.return === f) return;
                g = g.return
            }
            g.sibling.return = g.return, g = g.sibling
        }
    }, mc = function() {}, dh = function(u, f, g, w, C) {
        if (u = u.memoizedProps, u !== w) {
            var T = f.stateNode,
                N = Jr(qi.current);
            g = ve(T, g, u, w, C, N), (f.updateQueue = g) && Qr(f)
        }
    }, hh = function(u, f, g, w) {
        g !== w && Qr(f)
    };
    else if (he) {
        pc = function(u, f, g, w) {
            for (var C = f.child; C !== null;) {
                if (C.tag === 5) {
                    var T = C.stateNode;
                    g && w && (T = Ot(T, C.type, C.memoizedProps, C)), j(u, T)
                } else if (C.tag === 6) T = C.stateNode, g && w && (T = ji(T, C.memoizedProps, C)), j(u, T);
                else if (C.tag !== 4) {
                    if (C.tag === 22 && C.memoizedState !== null) T = C.child, T !== null && (T.return = C), pc(u, C, !0, !0);
                    else if (C.child !== null) {
                        C.child.return = C, C = C.child;
                        continue
                    }
                }
                if (C === f) break;
                for (; C.sibling === null;) {
                    if (C.return === null || C.return === f) return;
                    C = C.return
                }
                C.sibling.return = C.return, C = C.sibling
            }
        };
        var dS = function(u, f, g, w) {
            for (var C = f.child; C !== null;) {
                if (C.tag === 5) {
                    var T = C.stateNode;
                    g && w && (T = Ot(T, C.type, C.memoizedProps, C)), dn(u, T)
                } else if (C.tag === 6) T = C.stateNode, g && w && (T = ji(T, C.memoizedProps, C)), dn(u, T);
                else if (C.tag !== 4) {
                    if (C.tag === 22 && C.memoizedState !== null) T = C.child, T !== null && (T.return = C), dS(u, C, !0, !0);
                    else if (C.child !== null) {
                        C.child.return = C, C = C.child;
                        continue
                    }
                }
                if (C === f) break;
                for (; C.sibling === null;) {
                    if (C.return === null || C.return === f) return;
                    C = C.return
                }
                C.sibling.return = C.return, C = C.sibling
            }
        };
        mc = function(u, f) {
            var g = f.stateNode;
            if (!fS(u, f)) {
                u = g.containerInfo;
                var w = Bt(u);
                dS(w, f, !1, !1), g.pendingChildren = w, Qr(f), Pn(u, w)
            }
        }, dh = function(u, f, g, w, C) {
            var T = u.stateNode,
                N = u.memoizedProps;
            if ((u = fS(u, f)) && N === w) f.stateNode = T;
            else {
                var X = f.stateNode,
                    de = Jr(qi.current),
                    be = null;
                N !== w && (be = ve(X, g, N, w, C, de)), u && be === null ? f.stateNode = T : (T = Ke(T, be, g, N, w, f, u, X), re(T, g, w, C, de) && Qr(f), f.stateNode = T, u ? Qr(f) : pc(T, f, !1, !1))
            }
        }, hh = function(u, f, g, w) {
            g !== w ? (u = Jr(wl.current), g = Jr(qi.current), f.stateNode = q(w, u, g, f), Qr(f)) : f.stateNode = u.stateNode
        }
    } else mc = function() {}, dh = function() {}, hh = function() {};

    function gc(u, f) {
        if (!Xt) switch (u.tailMode) {
            case "hidden":
                f = u.tail;
                for (var g = null; f !== null;) f.alternate !== null && (g = f), f = f.sibling;
                g === null ? u.tail = null : g.sibling = null;
                break;
            case "collapsed":
                g = u.tail;
                for (var w = null; g !== null;) g.alternate !== null && (w = g), g = g.sibling;
                w === null ? f || u.tail === null ? u.tail = null : u.tail.sibling = null : w.sibling = null
        }
    }

    function Jn(u) {
        var f = u.alternate !== null && u.alternate.child === u.child,
            g = 0,
            w = 0;
        if (f)
            for (var C = u.child; C !== null;) g |= C.lanes | C.childLanes, w |= C.subtreeFlags & 14680064, w |= C.flags & 14680064, C.return = u, C = C.sibling;
        else
            for (C = u.child; C !== null;) g |= C.lanes | C.childLanes, w |= C.subtreeFlags, w |= C.flags, C.return = u, C = C.sibling;
        return u.subtreeFlags |= w, u.childLanes = g, f
    }

    function $I(u, f, g) {
        var w = f.pendingProps;
        switch (h0(f), f.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return Jn(f), null;
            case 1:
                return mi(f.type) && Hd(), Jn(f), null;
            case 3:
                return w = f.stateNode, Sl(), ct(Rn), ct(Ft), x0(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (u === null || u.child === null) && (oc(f) ? Qr(f) : u === null || u.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024, _r !== null && (K0(_r), _r = null))), mc(u, f), Jn(f), null;
            case 5:
                v0(f), g = Jr(wl.current);
                var C = f.type;
                if (u !== null && f.stateNode != null) dh(u, f, C, w, g), u.ref !== f.ref && (f.flags |= 512, f.flags |= 2097152);
                else {
                    if (!w) {
                        if (f.stateNode === null) throw Error(o(166));
                        return Jn(f), null
                    }
                    if (u = Jr(qi.current), oc(f)) {
                        if (!ae) throw Error(o(175));
                        u = qe(f.stateNode, f.type, f.memoizedProps, g, u, f, !sc), f.updateQueue = u, u !== null && Qr(f)
                    } else {
                        var T = ie(C, w, g, u, f);
                        pc(T, f, !1, !1), f.stateNode = T, re(T, C, w, g, u) && Qr(f)
                    }
                    f.ref !== null && (f.flags |= 512, f.flags |= 2097152)
                }
                return Jn(f), null;
            case 6:
                if (u && f.stateNode != null) hh(u, f, u.memoizedProps, w);
                else {
                    if (typeof w != "string" && f.stateNode === null) throw Error(o(166));
                    if (u = Jr(wl.current), g = Jr(qi.current), oc(f)) {
                        if (!ae) throw Error(o(176));
                        if (u = f.stateNode, w = f.memoizedProps, (g = st(u, w, f, !sc)) && (C = Ti, C !== null)) switch (T = (C.mode & 1) !== 0, C.tag) {
                            case 3:
                                vr(C.stateNode.containerInfo, u, w, T);
                                break;
                            case 5:
                                ls(C.type, C.memoizedProps, C.stateNode, u, w, T)
                        }
                        g && Qr(f)
                    } else f.stateNode = q(w, u, g, f)
                }
                return Jn(f), null;
            case 13:
                if (ct(Zt), w = f.memoizedState, Xt && Bi !== null && f.mode & 1 && !(f.flags & 128)) {
                    for (u = Bi; u;) u = ee(u);
                    return xl(), f.flags |= 98560, f
                }
                if (w !== null && w.dehydrated !== null) {
                    if (w = oc(f), u === null) {
                        if (!w) throw Error(o(318));
                        if (!ae) throw Error(o(344));
                        if (u = f.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317));
                        ft(u, f)
                    } else xl(), !(f.flags & 128) && (f.memoizedState = null), f.flags |= 4;
                    return Jn(f), null
                }
                return _r !== null && (K0(_r), _r = null), f.flags & 128 ? (f.lanes = g, f) : (w = w !== null, g = !1, u === null ? oc(f) : g = u.memoizedState !== null, w && !g && (f.child.flags |= 8192, f.mode & 1 && (u === null || Zt.current & 1 ? Sn === 0 && (Sn = 3) : Z0())), f.updateQueue !== null && (f.flags |= 4), Jn(f), null);
            case 4:
                return Sl(), mc(u, f), u === null && ze(f.stateNode.containerInfo), Jn(f), null;
            case 10:
                return a0(f.type._context), Jn(f), null;
            case 17:
                return mi(f.type) && Hd(), Jn(f), null;
            case 19:
                if (ct(Zt), C = f.memoizedState, C === null) return Jn(f), null;
                if (w = (f.flags & 128) !== 0, T = C.rendering, T === null)
                    if (w) gc(C, !1);
                    else {
                        if (Sn !== 0 || u !== null && u.flags & 128)
                            for (u = f.child; u !== null;) {
                                if (T = rh(u), T !== null) {
                                    for (f.flags |= 128, gc(C, !1), u = T.updateQueue, u !== null && (f.updateQueue = u, f.flags |= 4), f.subtreeFlags = 0, u = g, w = f.child; w !== null;) g = w, C = u, g.flags &= 14680066, T = g.alternate, T === null ? (g.childLanes = 0, g.lanes = C, g.child = null, g.subtreeFlags = 0, g.memoizedProps = null, g.memoizedState = null, g.updateQueue = null, g.dependencies = null, g.stateNode = null) : (g.childLanes = T.childLanes, g.lanes = T.lanes, g.child = T.child, g.subtreeFlags = 0, g.deletions = null, g.memoizedProps = T.memoizedProps, g.memoizedState = T.memoizedState, g.updateQueue = T.updateQueue, g.type = T.type, C = T.dependencies, g.dependencies = C === null ? null : {
                                        lanes: C.lanes,
                                        firstContext: C.firstContext
                                    }), w = w.sibling;
                                    return Et(Zt, Zt.current & 1 | 2), f.child
                                }
                                u = u.sibling
                            }
                        C.tail !== null && In() > j0 && (f.flags |= 128, w = !0, gc(C, !1), f.lanes = 4194304)
                    }
                else {
                    if (!w)
                        if (u = rh(T), u !== null) {
                            if (f.flags |= 128, w = !0, u = u.updateQueue, u !== null && (f.updateQueue = u, f.flags |= 4), gc(C, !0), C.tail === null && C.tailMode === "hidden" && !T.alternate && !Xt) return Jn(f), null
                        } else 2 * In() - C.renderingStartTime > j0 && g !== 1073741824 && (f.flags |= 128, w = !0, gc(C, !1), f.lanes = 4194304);
                    C.isBackwards ? (T.sibling = f.child, f.child = T) : (u = C.last, u !== null ? u.sibling = T : f.child = T, C.last = T)
                }
                return C.tail !== null ? (f = C.tail, C.rendering = f, C.tail = f.sibling, C.renderingStartTime = In(), f.sibling = null, u = Zt.current, Et(Zt, w ? u & 1 | 2 : u & 1), f) : (Jn(f), null);
            case 22:
            case 23:
                return Y0(), w = f.memoizedState !== null, u !== null && u.memoizedState !== null !== w && (f.flags |= 8192), w && f.mode & 1 ? Ri & 1073741824 && (Jn(f), Le && f.subtreeFlags & 6 && (f.flags |= 8192)) : Jn(f), null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(o(156, f.tag))
    }
    var eL = a.ReactCurrentOwner,
        Pi = !1;

    function ni(u, f, g, w) {
        f.child = u === null ? zw(f, null, g, w) : _l(f, u.child, g, w)
    }

    function hS(u, f, g, w, C) {
        g = g.render;
        var T = f.ref;
        return yl(f, C), w = w0(u, f, g, w, T, C), g = S0(), u !== null && !Pi ? (f.updateQueue = u.updateQueue, f.flags &= -2053, u.lanes &= ~C, ys(u, f, C)) : (Xt && g && d0(f), f.flags |= 1, ni(u, f, w, C), f.child)
    }

    function pS(u, f, g, w, C) {
        if (u === null) {
            var T = g.type;
            return typeof T == "function" && !q0(T) && T.defaultProps === void 0 && g.compare === null && g.defaultProps === void 0 ? (f.tag = 15, f.type = T, mS(u, f, T, w, C)) : (u = Dh(g.type, null, w, f, f.mode, C), u.ref = f.ref, u.return = f, f.child = u)
        }
        if (T = u.child, !(u.lanes & C)) {
            var N = T.memoizedProps;
            if (g = g.compare, g = g !== null ? g : Kd, g(N, w) && u.ref === f.ref) return ys(u, f, C)
        }
        return f.flags |= 1, u = no(T, w), u.ref = f.ref, u.return = f, f.child = u
    }

    function mS(u, f, g, w, C) {
        if (u !== null && Kd(u.memoizedProps, w) && u.ref === f.ref)
            if (Pi = !1, (u.lanes & C) !== 0) u.flags & 131072 && (Pi = !0);
            else return f.lanes = u.lanes, ys(u, f, C);
        return B0(u, f, g, w, C)
    }

    function gS(u, f, g) {
        var w = f.pendingProps,
            C = w.children,
            T = u !== null ? u.memoizedState : null;
        if (w.mode === "hidden")
            if (!(f.mode & 1)) f.memoizedState = {
                baseLanes: 0,
                cachePool: null
            }, Et(Cl, Ri), Ri |= g;
            else if (g & 1073741824) f.memoizedState = {
            baseLanes: 0,
            cachePool: null
        }, w = T !== null ? T.baseLanes : g, Et(Cl, Ri), Ri |= w;
        else return u = T !== null ? T.baseLanes | g : g, f.lanes = f.childLanes = 1073741824, f.memoizedState = {
            baseLanes: u,
            cachePool: null
        }, f.updateQueue = null, Et(Cl, Ri), Ri |= u, null;
        else T !== null ? (w = T.baseLanes | g, f.memoizedState = null) : w = g, Et(Cl, Ri), Ri |= w;
        return ni(u, f, C, g), f.child
    }

    function yS(u, f) {
        var g = f.ref;
        (u === null && g !== null || u !== null && u.ref !== g) && (f.flags |= 512, f.flags |= 2097152)
    }

    function B0(u, f, g, w, C) {
        var T = mi(g) ? cs : Ft.current;
        return T = fs(f, T), yl(f, C), g = w0(u, f, g, w, T, C), w = S0(), u !== null && !Pi ? (f.updateQueue = u.updateQueue, f.flags &= -2053, u.lanes &= ~C, ys(u, f, C)) : (Xt && w && d0(f), f.flags |= 1, ni(u, f, g, C), f.child)
    }

    function vS(u, f, g, w, C) {
        if (mi(g)) {
            var T = !0;
            Vd(f)
        } else T = !1;
        if (yl(f, C), f.stateNode === null) u !== null && (u.alternate = null, f.alternate = null, f.flags |= 2), Iw(f, g, w), f0(f, g, w, C), w = !0;
        else if (u === null) {
            var N = f.stateNode,
                X = f.memoizedProps;
            N.props = X;
            var de = N.context,
                be = g.contextType;
            typeof be == "object" && be !== null ? be = Ki(be) : (be = mi(g) ? cs : Ft.current, be = fs(f, be));
            var Ve = g.getDerivedStateFromProps,
                ot = typeof Ve == "function" || typeof N.getSnapshotBeforeUpdate == "function";
            ot || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (X !== w || de !== be) && Lw(f, N, w, be), Ys = !1;
            var et = f.memoizedState;
            N.state = et, $d(f, w, N, C), de = f.memoizedState, X !== w || et !== de || Rn.current || Ys ? (typeof Ve == "function" && (c0(f, g, Ve, w), de = f.memoizedState), (X = Ys || Rw(f, g, X, w, et, de, be)) ? (ot || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (typeof N.componentWillMount == "function" && N.componentWillMount(), typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount()), typeof N.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = w, f.memoizedState = de), N.props = w, N.state = de, N.context = be, w = X) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308), w = !1)
        } else {
            N = f.stateNode, bw(u, f), X = f.memoizedProps, be = f.type === f.elementType ? X : xr(f.type, X), N.props = be, ot = f.pendingProps, et = N.context, de = g.contextType, typeof de == "object" && de !== null ? de = Ki(de) : (de = mi(g) ? cs : Ft.current, de = fs(f, de));
            var Ut = g.getDerivedStateFromProps;
            (Ve = typeof Ut == "function" || typeof N.getSnapshotBeforeUpdate == "function") || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (X !== ot || et !== de) && Lw(f, N, w, de), Ys = !1, et = f.memoizedState, N.state = et, $d(f, w, N, C);
            var Ye = f.memoizedState;
            X !== ot || et !== Ye || Rn.current || Ys ? (typeof Ut == "function" && (c0(f, g, Ut, w), Ye = f.memoizedState), (be = Ys || Rw(f, g, be, w, et, Ye, de) || !1) ? (Ve || typeof N.UNSAFE_componentWillUpdate != "function" && typeof N.componentWillUpdate != "function" || (typeof N.componentWillUpdate == "function" && N.componentWillUpdate(w, Ye, de), typeof N.UNSAFE_componentWillUpdate == "function" && N.UNSAFE_componentWillUpdate(w, Ye, de)), typeof N.componentDidUpdate == "function" && (f.flags |= 4), typeof N.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof N.componentDidUpdate != "function" || X === u.memoizedProps && et === u.memoizedState || (f.flags |= 4), typeof N.getSnapshotBeforeUpdate != "function" || X === u.memoizedProps && et === u.memoizedState || (f.flags |= 1024), f.memoizedProps = w, f.memoizedState = Ye), N.props = w, N.state = Ye, N.context = de, w = be) : (typeof N.componentDidUpdate != "function" || X === u.memoizedProps && et === u.memoizedState || (f.flags |= 4), typeof N.getSnapshotBeforeUpdate != "function" || X === u.memoizedProps && et === u.memoizedState || (f.flags |= 1024), w = !1)
        }
        return P0(u, f, g, w, T, C)
    }

    function P0(u, f, g, w, C, T) {
        yS(u, f);
        var N = (f.flags & 128) !== 0;
        if (!w && !N) return C && ww(f, g, !1), ys(u, f, T);
        w = f.stateNode, eL.current = f;
        var X = N && typeof g.getDerivedStateFromError != "function" ? null : w.render();
        return f.flags |= 1, u !== null && N ? (f.child = _l(f, u.child, null, T), f.child = _l(f, null, X, T)) : ni(u, f, X, T), f.memoizedState = w.state, C && ww(f, g, !0), f.child
    }

    function AS(u) {
        var f = u.stateNode;
        f.pendingContext ? xw(u, f.pendingContext, f.pendingContext !== f.context) : f.context && xw(u, f.context, !1), y0(u, f.containerInfo)
    }

    function xS(u, f, g, w, C) {
        return xl(), g0(C), f.flags |= 256, ni(u, f, g, w), f.child
    }
    var ph = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };

    function mh(u) {
        return {
            baseLanes: u,
            cachePool: null
        }
    }

    function _S(u, f, g) {
        var w = f.pendingProps,
            C = Zt.current,
            T = !1,
            N = (f.flags & 128) !== 0,
            X;
        if ((X = N) || (X = u !== null && u.memoizedState === null ? !1 : (C & 2) !== 0), X ? (T = !0, f.flags &= -129) : (u === null || u.memoizedState !== null) && (C |= 1), Et(Zt, C & 1), u === null) return m0(f), u = f.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (f.mode & 1 ? nc(u) ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1, null) : (C = w.children, u = w.fallback, T ? (w = f.mode, T = f.child, C = {
            mode: "hidden",
            children: C
        }, !(w & 1) && T !== null ? (T.childLanes = 0, T.pendingProps = C) : T = Fh(C, w, 0, null), u = fa(u, w, g, null), T.return = f, u.return = f, T.sibling = u, f.child = T, f.child.memoizedState = mh(g), f.memoizedState = ph, u) : R0(f, C));
        if (C = u.memoizedState, C !== null) {
            if (X = C.dehydrated, X !== null) {
                if (N) return f.flags & 256 ? (f.flags &= -257, gh(u, f, g, Error(o(422)))) : f.memoizedState !== null ? (f.child = u.child, f.flags |= 128, null) : (T = w.fallback, C = f.mode, w = Fh({
                    mode: "visible",
                    children: w.children
                }, C, 0, null), T = fa(T, C, g, null), T.flags |= 2, w.return = f, T.return = f, w.sibling = T, f.child = w, f.mode & 1 && _l(f, u.child, null, g), f.child.memoizedState = mh(g), f.memoizedState = ph, T);
                if (!(f.mode & 1)) f = gh(u, f, g, null);
                else if (nc(X)) f = gh(u, f, g, Error(o(419)));
                else if (w = (g & u.childLanes) !== 0, Pi || w) {
                    if (w = yn, w !== null) {
                        switch (g & -g) {
                            case 4:
                                T = 2;
                                break;
                            case 16:
                                T = 8;
                                break;
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                            case 67108864:
                                T = 32;
                                break;
                            case 536870912:
                                T = 268435456;
                                break;
                            default:
                                T = 0
                        }
                        w = T & (w.suspendedLanes | g) ? 0 : T, w !== 0 && w !== C.retryLane && (C.retryLane = w, er(u, w, -1))
                    }
                    Z0(), f = gh(u, f, g, Error(o(421)))
                } else Gd(X) ? (f.flags |= 128, f.child = u.child, f = hL.bind(null, u), F(X, f), f = null) : (g = C.treeContext, ae && (Bi = ye(X), Ti = f, Xt = !0, _r = null, sc = !1, g !== null && (Yi[Zi++] = ps, Yi[Zi++] = ms, Yi[Zi++] = ia, ps = g.id, ms = g.overflow, ia = f)), f = R0(f, f.pendingProps.children), f.flags |= 4096);
                return f
            }
            return T ? (w = SS(u, f, w.children, w.fallback, g), T = f.child, C = u.child.memoizedState, T.memoizedState = C === null ? mh(g) : {
                baseLanes: C.baseLanes | g,
                cachePool: null
            }, T.childLanes = u.childLanes & ~g, f.memoizedState = ph, w) : (g = wS(u, f, w.children, g), f.memoizedState = null, g)
        }
        return T ? (w = SS(u, f, w.children, w.fallback, g), T = f.child, C = u.child.memoizedState, T.memoizedState = C === null ? mh(g) : {
            baseLanes: C.baseLanes | g,
            cachePool: null
        }, T.childLanes = u.childLanes & ~g, f.memoizedState = ph, w) : (g = wS(u, f, w.children, g), f.memoizedState = null, g)
    }

    function R0(u, f) {
        return f = Fh({
            mode: "visible",
            children: f
        }, u.mode, 0, null), f.return = u, u.child = f
    }

    function wS(u, f, g, w) {
        var C = u.child;
        return u = C.sibling, g = no(C, {
            mode: "visible",
            children: g
        }), !(f.mode & 1) && (g.lanes = w), g.return = f, g.sibling = null, u !== null && (w = f.deletions, w === null ? (f.deletions = [u], f.flags |= 16) : w.push(u)), f.child = g
    }

    function SS(u, f, g, w, C) {
        var T = f.mode;
        u = u.child;
        var N = u.sibling,
            X = {
                mode: "hidden",
                children: g
            };
        return !(T & 1) && f.child !== u ? (g = f.child, g.childLanes = 0, g.pendingProps = X, f.deletions = null) : (g = no(u, X), g.subtreeFlags = u.subtreeFlags & 14680064), N !== null ? w = no(N, w) : (w = fa(w, T, C, null), w.flags |= 2), w.return = f, g.return = f, g.sibling = w, f.child = g, w
    }

    function gh(u, f, g, w) {
        return w !== null && g0(w), _l(f, u.child, null, g), u = R0(f, f.pendingProps.children), u.flags |= 2, f.memoizedState = null, u
    }

    function MS(u, f, g) {
        u.lanes |= f;
        var w = u.alternate;
        w !== null && (w.lanes |= f), l0(u.return, f, g)
    }

    function I0(u, f, g, w, C) {
        var T = u.memoizedState;
        T === null ? u.memoizedState = {
            isBackwards: f,
            rendering: null,
            renderingStartTime: 0,
            last: w,
            tail: g,
            tailMode: C
        } : (T.isBackwards = f, T.rendering = null, T.renderingStartTime = 0, T.last = w, T.tail = g, T.tailMode = C)
    }

    function CS(u, f, g) {
        var w = f.pendingProps,
            C = w.revealOrder,
            T = w.tail;
        if (ni(u, f, w.children, g), w = Zt.current, w & 2) w = w & 1 | 2, f.flags |= 128;
        else {
            if (u !== null && u.flags & 128) e: for (u = f.child; u !== null;) {
                if (u.tag === 13) u.memoizedState !== null && MS(u, g, f);
                else if (u.tag === 19) MS(u, g, f);
                else if (u.child !== null) {
                    u.child.return = u, u = u.child;
                    continue
                }
                if (u === f) break e;
                for (; u.sibling === null;) {
                    if (u.return === null || u.return === f) break e;
                    u = u.return
                }
                u.sibling.return = u.return, u = u.sibling
            }
            w &= 1
        }
        if (Et(Zt, w), !(f.mode & 1)) f.memoizedState = null;
        else switch (C) {
            case "forwards":
                for (g = f.child, C = null; g !== null;) u = g.alternate, u !== null && rh(u) === null && (C = g), g = g.sibling;
                g = C, g === null ? (C = f.child, f.child = null) : (C = g.sibling, g.sibling = null), I0(f, !1, C, g, T);
                break;
            case "backwards":
                for (g = null, C = f.child, f.child = null; C !== null;) {
                    if (u = C.alternate, u !== null && rh(u) === null) {
                        f.child = C;
                        break
                    }
                    u = C.sibling, C.sibling = g, g = C, C = u
                }
                I0(f, !0, g, null, T);
                break;
            case "together":
                I0(f, !1, null, null, void 0);
                break;
            default:
                f.memoizedState = null
        }
        return f.child
    }

    function ys(u, f, g) {
        if (u !== null && (f.dependencies = u.dependencies), El |= f.lanes, !(g & f.childLanes)) return null;
        if (u !== null && f.child !== u.child) throw Error(o(153));
        if (f.child !== null) {
            for (u = f.child, g = no(u, u.pendingProps), f.child = g, g.return = f; u.sibling !== null;) u = u.sibling, g = g.sibling = no(u, u.pendingProps), g.return = f;
            g.sibling = null
        }
        return f.child
    }

    function tL(u, f, g) {
        switch (f.tag) {
            case 3:
                AS(f), xl();
                break;
            case 5:
                Gw(f);
                break;
            case 1:
                mi(f.type) && Vd(f);
                break;
            case 4:
                y0(f, f.stateNode.containerInfo);
                break;
            case 10:
                Ew(f, f.type._context, f.memoizedProps.value);
                break;
            case 13:
                var w = f.memoizedState;
                if (w !== null) return w.dehydrated !== null ? (Et(Zt, Zt.current & 1), f.flags |= 128, null) : g & f.child.childLanes ? _S(u, f, g) : (Et(Zt, Zt.current & 1), u = ys(u, f, g), u !== null ? u.sibling : null);
                Et(Zt, Zt.current & 1);
                break;
            case 19:
                if (w = (g & f.childLanes) !== 0, u.flags & 128) {
                    if (w) return CS(u, f, g);
                    f.flags |= 128
                }
                var C = f.memoizedState;
                if (C !== null && (C.rendering = null, C.tail = null, C.lastEffect = null), Et(Zt, Zt.current), w) break;
                return null;
            case 22:
            case 23:
                return f.lanes = 0, gS(u, f, g)
        }
        return ys(u, f, g)
    }

    function nL(u, f) {
        switch (h0(f), f.tag) {
            case 1:
                return mi(f.type) && Hd(), u = f.flags, u & 65536 ? (f.flags = u & -65537 | 128, f) : null;
            case 3:
                return Sl(), ct(Rn), ct(Ft), x0(), u = f.flags, u & 65536 && !(u & 128) ? (f.flags = u & -65537 | 128, f) : null;
            case 5:
                return v0(f), null;
            case 13:
                if (ct(Zt), u = f.memoizedState, u !== null && u.dehydrated !== null) {
                    if (f.alternate === null) throw Error(o(340));
                    xl()
                }
                return u = f.flags, u & 65536 ? (f.flags = u & -65537 | 128, f) : null;
            case 19:
                return ct(Zt), null;
            case 4:
                return Sl(), null;
            case 10:
                return a0(f.type._context), null;
            case 22:
            case 23:
                return Y0(), null;
            case 24:
                return null;
            default:
                return null
        }
    }
    var yh = !1,
        oa = !1,
        iL = typeof WeakSet == "function" ? WeakSet : Set,
        Fe = null;

    function vh(u, f) {
        var g = u.ref;
        if (g !== null)
            if (typeof g == "function") try {
                g(null)
            } catch (w) {
                vi(u, f, w)
            } else g.current = null
    }

    function L0(u, f, g) {
        try {
            g()
        } catch (w) {
            vi(u, f, w)
        }
    }
    var ES = !1;

    function rL(u, f) {
        for (V(u.containerInfo), Fe = f; Fe !== null;)
            if (u = Fe, f = u.child, (u.subtreeFlags & 1028) !== 0 && f !== null) f.return = u, Fe = f;
            else
                for (; Fe !== null;) {
                    u = Fe;
                    try {
                        var g = u.alternate;
                        if (u.flags & 1024) switch (u.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (g !== null) {
                                    var w = g.memoizedProps,
                                        C = g.memoizedState,
                                        T = u.stateNode,
                                        N = T.getSnapshotBeforeUpdate(u.elementType === u.type ? w : xr(u.type, w), C);
                                    T.__reactInternalSnapshotBeforeUpdate = N
                                }
                                break;
                            case 3:
                                Le && Ue(u.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                        }
                    } catch (X) {
                        vi(u, u.return, X)
                    }
                    if (f = u.sibling, f !== null) {
                        f.return = u.return, Fe = f;
                        break
                    }
                    Fe = u.return
                }
        return g = ES, ES = !1, g
    }

    function aa(u, f, g) {
        var w = f.updateQueue;
        if (w = w !== null ? w.lastEffect : null, w !== null) {
            var C = w = w.next;
            do {
                if ((C.tag & u) === u) {
                    var T = C.destroy;
                    C.destroy = void 0, T !== void 0 && L0(f, g, T)
                }
                C = C.next
            } while (C !== w)
        }
    }

    function yc(u, f) {
        if (f = f.updateQueue, f = f !== null ? f.lastEffect : null, f !== null) {
            var g = f = f.next;
            do {
                if ((g.tag & u) === u) {
                    var w = g.create;
                    g.destroy = w()
                }
                g = g.next
            } while (g !== f)
        }
    }

    function D0(u) {
        var f = u.ref;
        if (f !== null) {
            var g = u.stateNode;
            switch (u.tag) {
                case 5:
                    u = te(g);
                    break;
                default:
                    u = g
            }
            typeof f == "function" ? f(u) : f.current = u
        }
    }

    function bS(u, f, g) {
        if (Hr && typeof Hr.onCommitFiberUnmount == "function") try {
            Hr.onCommitFiberUnmount(Xd, f)
        } catch {}
        switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (u = f.updateQueue, u !== null && (u = u.lastEffect, u !== null)) {
                    var w = u = u.next;
                    do {
                        var C = w,
                            T = C.destroy;
                        C = C.tag, T !== void 0 && (C & 2 || C & 4) && L0(f, g, T), w = w.next
                    } while (w !== u)
                }
                break;
            case 1:
                if (vh(f, g), u = f.stateNode, typeof u.componentWillUnmount == "function") try {
                    u.props = f.memoizedProps, u.state = f.memoizedState, u.componentWillUnmount()
                } catch (N) {
                    vi(f, g, N)
                }
                break;
            case 5:
                vh(f, g);
                break;
            case 4:
                Le ? LS(u, f, g) : he && he && (f = f.stateNode.containerInfo, g = Bt(f), Gr(f, g))
        }
    }

    function TS(u, f, g) {
        for (var w = f;;)
            if (bS(u, w, g), w.child === null || Le && w.tag === 4) {
                if (w === f) break;
                for (; w.sibling === null;) {
                    if (w.return === null || w.return === f) return;
                    w = w.return
                }
                w.sibling.return = w.return, w = w.sibling
            } else w.child.return = w, w = w.child
    }

    function BS(u) {
        var f = u.alternate;
        f !== null && (u.alternate = null, BS(f)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (f = u.stateNode, f !== null && Ze(f)), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null
    }

    function PS(u) {
        return u.tag === 5 || u.tag === 3 || u.tag === 4
    }

    function RS(u) {
        e: for (;;) {
            for (; u.sibling === null;) {
                if (u.return === null || PS(u.return)) return null;
                u = u.return
            }
            for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18;) {
                if (u.flags & 2 || u.child === null || u.tag === 4) continue e;
                u.child.return = u, u = u.child
            }
            if (!(u.flags & 2)) return u.stateNode
        }
    }

    function IS(u) {
        if (Le) {
            e: {
                for (var f = u.return; f !== null;) {
                    if (PS(f)) break e;
                    f = f.return
                }
                throw Error(o(160))
            }
            var g = f;
            switch (g.tag) {
                case 5:
                    f = g.stateNode, g.flags & 32 && (yt(f), g.flags &= -33), g = RS(u), k0(u, g, f);
                    break;
                case 3:
                case 4:
                    f = g.stateNode.containerInfo, g = RS(u), F0(u, g, f);
                    break;
                default:
                    throw Error(o(161))
            }
        }
    }

    function F0(u, f, g) {
        var w = u.tag;
        if (w === 5 || w === 6) u = u.stateNode, f ? _e(g, u, f) : De(g, u);
        else if (w !== 4 && (u = u.child, u !== null))
            for (F0(u, f, g), u = u.sibling; u !== null;) F0(u, f, g), u = u.sibling
    }

    function k0(u, f, g) {
        var w = u.tag;
        if (w === 5 || w === 6) u = u.stateNode, f ? ue(g, u, f) : tt(g, u);
        else if (w !== 4 && (u = u.child, u !== null))
            for (k0(u, f, g), u = u.sibling; u !== null;) k0(u, f, g), u = u.sibling
    }

    function LS(u, f, g) {
        for (var w = f, C = !1, T, N;;) {
            if (!C) {
                C = w.return;
                e: for (;;) {
                    if (C === null) throw Error(o(160));
                    switch (T = C.stateNode, C.tag) {
                        case 5:
                            N = !1;
                            break e;
                        case 3:
                            T = T.containerInfo, N = !0;
                            break e;
                        case 4:
                            T = T.containerInfo, N = !0;
                            break e
                    }
                    C = C.return
                }
                C = !0
            }
            if (w.tag === 5 || w.tag === 6) TS(u, w, g), N ? $e(T, w.stateNode) : Te(T, w.stateNode);
            else if (w.tag === 18) N ? on(T, w.stateNode) : _t(T, w.stateNode);
            else if (w.tag === 4) {
                if (w.child !== null) {
                    T = w.stateNode.containerInfo, N = !0, w.child.return = w, w = w.child;
                    continue
                }
            } else if (bS(u, w, g), w.child !== null) {
                w.child.return = w, w = w.child;
                continue
            }
            if (w === f) break;
            for (; w.sibling === null;) {
                if (w.return === null || w.return === f) return;
                w = w.return, w.tag === 4 && (C = !1)
            }
            w.sibling.return = w.return, w = w.sibling
        }
    }

    function N0(u, f) {
        if (Le) {
            switch (f.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    aa(3, f, f.return), yc(3, f), aa(5, f, f.return);
                    return;
                case 1:
                    return;
                case 5:
                    var g = f.stateNode;
                    if (g != null) {
                        var w = f.memoizedProps;
                        u = u !== null ? u.memoizedProps : w;
                        var C = f.type,
                            T = f.updateQueue;
                        f.updateQueue = null, T !== null && H(g, T, C, u, w, f)
                    }
                    return;
                case 6:
                    if (f.stateNode === null) throw Error(o(162));
                    g = f.memoizedProps, ge(f.stateNode, u !== null ? u.memoizedProps : g, g);
                    return;
                case 3:
                    ae && u !== null && u.memoizedState.isDehydrated && Mt(f.stateNode.containerInfo);
                    return;
                case 12:
                    return;
                case 13:
                    Ah(f);
                    return;
                case 19:
                    Ah(f);
                    return;
                case 17:
                    return
            }
            throw Error(o(163))
        }
        switch (f.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                aa(3, f, f.return), yc(3, f), aa(5, f, f.return);
                return;
            case 12:
                return;
            case 13:
                Ah(f);
                return;
            case 19:
                Ah(f);
                return;
            case 3:
                ae && u !== null && u.memoizedState.isDehydrated && Mt(f.stateNode.containerInfo);
                break;
            case 22:
            case 23:
                return
        }
        e: if (he) {
            switch (f.tag) {
                case 1:
                case 5:
                case 6:
                    break e;
                case 3:
                case 4:
                    f = f.stateNode, Gr(f.containerInfo, f.pendingChildren);
                    break e
            }
            throw Error(o(163))
        }
    }

    function Ah(u) {
        var f = u.updateQueue;
        if (f !== null) {
            u.updateQueue = null;
            var g = u.stateNode;
            g === null && (g = u.stateNode = new iL), f.forEach(function(w) {
                var C = pL.bind(null, u, w);
                g.has(w) || (g.add(w), w.then(C, C))
            })
        }
    }

    function sL(u, f) {
        for (Fe = f; Fe !== null;) {
            f = Fe;
            var g = f.deletions;
            if (g !== null)
                for (var w = 0; w < g.length; w++) {
                    var C = g[w];
                    try {
                        var T = u;
                        Le ? LS(T, C, f) : TS(T, C, f);
                        var N = C.alternate;
                        N !== null && (N.return = null), C.return = null
                    } catch (Qe) {
                        vi(C, f, Qe)
                    }
                }
            if (g = f.child, f.subtreeFlags & 12854 && g !== null) g.return = f, Fe = g;
            else
                for (; Fe !== null;) {
                    f = Fe;
                    try {
                        var X = f.flags;
                        if (X & 32 && Le && yt(f.stateNode), X & 512) {
                            var de = f.alternate;
                            if (de !== null) {
                                var be = de.ref;
                                be !== null && (typeof be == "function" ? be(null) : be.current = null)
                            }
                        }
                        if (X & 8192) switch (f.tag) {
                            case 13:
                                if (f.memoizedState !== null) {
                                    var Ve = f.alternate;
                                    (Ve === null || Ve.memoizedState === null) && (W0 = In())
                                }
                                break;
                            case 22:
                                var ot = f.memoizedState !== null,
                                    et = f.alternate,
                                    Ut = et !== null && et.memoizedState !== null;
                                if (g = f, Le) {
                                    e: if (w = g, C = ot, T = null, Le)
                                        for (var Ye = w;;) {
                                            if (Ye.tag === 5) {
                                                if (T === null) {
                                                    T = Ye;
                                                    var Xn = Ye.stateNode;
                                                    C ? Vt(Xn) : fe(Ye.stateNode, Ye.memoizedProps)
                                                }
                                            } else if (Ye.tag === 6) {
                                                if (T === null) {
                                                    var nr = Ye.stateNode;
                                                    C ? Q(nr) : Ae(nr, Ye.memoizedProps)
                                                }
                                            } else if ((Ye.tag !== 22 && Ye.tag !== 23 || Ye.memoizedState === null || Ye === w) && Ye.child !== null) {
                                                Ye.child.return = Ye, Ye = Ye.child;
                                                continue
                                            }
                                            if (Ye === w) break;
                                            for (; Ye.sibling === null;) {
                                                if (Ye.return === null || Ye.return === w) break e;
                                                T === Ye && (T = null), Ye = Ye.return
                                            }
                                            T === Ye && (T = null), Ye.sibling.return = Ye.return, Ye = Ye.sibling
                                        }
                                }
                                if (ot && !Ut && g.mode & 1) {
                                    Fe = g;
                                    for (var ne = g.child; ne !== null;) {
                                        for (g = Fe = ne; Fe !== null;) {
                                            w = Fe;
                                            var Y = w.child;
                                            switch (w.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    aa(4, w, w.return);
                                                    break;
                                                case 1:
                                                    vh(w, w.return);
                                                    var ce = w.stateNode;
                                                    if (typeof ce.componentWillUnmount == "function") {
                                                        var ke = w.return;
                                                        try {
                                                            ce.props = w.memoizedProps, ce.state = w.memoizedState, ce.componentWillUnmount()
                                                        } catch (Qe) {
                                                            vi(w, ke, Qe)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    vh(w, w.return);
                                                    break;
                                                case 22:
                                                    if (w.memoizedState !== null) {
                                                        kS(g);
                                                        continue
                                                    }
                                            }
                                            Y !== null ? (Y.return = w, Fe = Y) : kS(g)
                                        }
                                        ne = ne.sibling
                                    }
                                }
                        }
                        switch (X & 4102) {
                            case 2:
                                IS(f), f.flags &= -3;
                                break;
                            case 6:
                                IS(f), f.flags &= -3, N0(f.alternate, f);
                                break;
                            case 4096:
                                f.flags &= -4097;
                                break;
                            case 4100:
                                f.flags &= -4097, N0(f.alternate, f);
                                break;
                            case 4:
                                N0(f.alternate, f)
                        }
                    } catch (Qe) {
                        vi(f, f.return, Qe)
                    }
                    if (g = f.sibling, g !== null) {
                        g.return = f.return, Fe = g;
                        break
                    }
                    Fe = f.return
                }
        }
    }

    function oL(u, f, g) {
        Fe = u, DS(u)
    }

    function DS(u, f, g) {
        for (var w = (u.mode & 1) !== 0; Fe !== null;) {
            var C = Fe,
                T = C.child;
            if (C.tag === 22 && w) {
                var N = C.memoizedState !== null || yh;
                if (!N) {
                    var X = C.alternate,
                        de = X !== null && X.memoizedState !== null || oa;
                    X = yh;
                    var be = oa;
                    if (yh = N, (oa = de) && !be)
                        for (Fe = C; Fe !== null;) N = Fe, de = N.child, N.tag === 22 && N.memoizedState !== null ? NS(C) : de !== null ? (de.return = N, Fe = de) : NS(C);
                    for (; T !== null;) Fe = T, DS(T), T = T.sibling;
                    Fe = C, yh = X, oa = be
                }
                FS(u)
            } else C.subtreeFlags & 8772 && T !== null ? (T.return = C, Fe = T) : FS(u)
        }
    }

    function FS(u) {
        for (; Fe !== null;) {
            var f = Fe;
            if (f.flags & 8772) {
                var g = f.alternate;
                try {
                    if (f.flags & 8772) switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                            oa || yc(5, f);
                            break;
                        case 1:
                            var w = f.stateNode;
                            if (f.flags & 4 && !oa)
                                if (g === null) w.componentDidMount();
                                else {
                                    var C = f.elementType === f.type ? g.memoizedProps : xr(f.type, g.memoizedProps);
                                    w.componentDidUpdate(C, g.memoizedState, w.__reactInternalSnapshotBeforeUpdate)
                                } var T = f.updateQueue;
                            T !== null && Bw(f, T, w);
                            break;
                        case 3:
                            var N = f.updateQueue;
                            if (N !== null) {
                                if (g = null, f.child !== null) switch (f.child.tag) {
                                    case 5:
                                        g = te(f.child.stateNode);
                                        break;
                                    case 1:
                                        g = f.child.stateNode
                                }
                                Bw(f, N, g)
                            }
                            break;
                        case 5:
                            var X = f.stateNode;
                            g === null && f.flags & 4 && Xe(X, f.type, f.memoizedProps, f);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (ae && f.memoizedState === null) {
                                var de = f.alternate;
                                if (de !== null) {
                                    var be = de.memoizedState;
                                    if (be !== null) {
                                        var Ve = be.dehydrated;
                                        Ve !== null && xt(Ve)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                    }
                    oa || f.flags & 512 && D0(f)
                } catch (ot) {
                    vi(f, f.return, ot)
                }
            }
            if (f === u) {
                Fe = null;
                break
            }
            if (g = f.sibling, g !== null) {
                g.return = f.return, Fe = g;
                break
            }
            Fe = f.return
        }
    }

    function kS(u) {
        for (; Fe !== null;) {
            var f = Fe;
            if (f === u) {
                Fe = null;
                break
            }
            var g = f.sibling;
            if (g !== null) {
                g.return = f.return, Fe = g;
                break
            }
            Fe = f.return
        }
    }

    function NS(u) {
        for (; Fe !== null;) {
            var f = Fe;
            try {
                switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var g = f.return;
                        try {
                            yc(4, f)
                        } catch (de) {
                            vi(f, g, de)
                        }
                        break;
                    case 1:
                        var w = f.stateNode;
                        if (typeof w.componentDidMount == "function") {
                            var C = f.return;
                            try {
                                w.componentDidMount()
                            } catch (de) {
                                vi(f, C, de)
                            }
                        }
                        var T = f.return;
                        try {
                            D0(f)
                        } catch (de) {
                            vi(f, T, de)
                        }
                        break;
                    case 5:
                        var N = f.return;
                        try {
                            D0(f)
                        } catch (de) {
                            vi(f, N, de)
                        }
                }
            } catch (de) {
                vi(f, f.return, de)
            }
            if (f === u) {
                Fe = null;
                break
            }
            var X = f.sibling;
            if (X !== null) {
                X.return = f.return, Fe = X;
                break
            }
            Fe = f.return
        }
    }
    var xh = 0,
        _h = 1,
        wh = 2,
        Sh = 3,
        Mh = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var vc = Symbol.for;
        xh = vc("selector.component"), _h = vc("selector.has_pseudo_class"), wh = vc("selector.role"), Sh = vc("selector.test_id"), Mh = vc("selector.text")
    }

    function O0(u) {
        var f = Ce(u);
        if (f != null) {
            if (typeof f.memoizedProps["data-testname"] != "string") throw Error(o(364));
            return f
        }
        if (u = St(u), u === null) throw Error(o(362));
        return u.stateNode.current
    }

    function U0(u, f) {
        switch (f.$$typeof) {
            case xh:
                if (u.type === f.value) return !0;
                break;
            case _h:
                e: {
                    f = f.value,
                    u = [u, 0];
                    for (var g = 0; g < u.length;) {
                        var w = u[g++],
                            C = u[g++],
                            T = f[C];
                        if (w.tag !== 5 || !oe(w)) {
                            for (; T != null && U0(w, T);) C++, T = f[C];
                            if (C === f.length) {
                                f = !0;
                                break e
                            } else
                                for (w = w.child; w !== null;) u.push(w, C), w = w.sibling
                        }
                    }
                    f = !1
                }
                return f;
            case wh:
                if (u.tag === 5 && Se(u.stateNode, f.value)) return !0;
                break;
            case Mh:
                if ((u.tag === 5 || u.tag === 6) && (u = L(u), u !== null && 0 <= u.indexOf(f.value))) return !0;
                break;
            case Sh:
                if (u.tag === 5 && (u = u.memoizedProps["data-testname"], typeof u == "string" && u.toLowerCase() === f.value.toLowerCase())) return !0;
                break;
            default:
                throw Error(o(365))
        }
        return !1
    }

    function z0(u) {
        switch (u.$$typeof) {
            case xh:
                return "<" + (R(u.value) || "Unknown") + ">";
            case _h:
                return ":has(" + (z0(u) || "") + ")";
            case wh:
                return '[role="' + u.value + '"]';
            case Mh:
                return '"' + u.value + '"';
            case Sh:
                return '[data-testname="' + u.value + '"]';
            default:
                throw Error(o(365))
        }
    }

    function OS(u, f) {
        var g = [];
        u = [u, 0];
        for (var w = 0; w < u.length;) {
            var C = u[w++],
                T = u[w++],
                N = f[T];
            if (C.tag !== 5 || !oe(C)) {
                for (; N != null && U0(C, N);) T++, N = f[T];
                if (T === f.length) g.push(C);
                else
                    for (C = C.child; C !== null;) u.push(C, T), C = C.sibling
            }
        }
        return g
    }

    function G0(u, f) {
        if (!vt) throw Error(o(363));
        u = O0(u), u = OS(u, f), f = [], u = Array.from(u);
        for (var g = 0; g < u.length;) {
            var w = u[g++];
            if (w.tag === 5) oe(w) || f.push(w.stateNode);
            else
                for (w = w.child; w !== null;) u.push(w), w = w.sibling
        }
        return f
    }
    var aL = Math.ceil,
        Ch = a.ReactCurrentDispatcher,
        H0 = a.ReactCurrentOwner,
        hn = a.ReactCurrentBatchConfig,
        gt = 0,
        yn = null,
        vn = null,
        On = 0,
        Ri = 0,
        Cl = Xi(0),
        Sn = 0,
        Ac = null,
        El = 0,
        Eh = 0,
        V0 = 0,
        xc = null,
        gi = null,
        W0 = 0,
        j0 = 1 / 0;

    function bl() {
        j0 = In() + 500
    }
    var bh = !1,
        J0 = null,
        qs = null,
        Th = !1,
        $s = null,
        Bh = 0,
        _c = 0,
        X0 = null,
        Ph = -1,
        Rh = 0;

    function ii() {
        return gt & 6 ? In() : Ph !== -1 ? Ph : Ph = In()
    }

    function eo(u) {
        return u.mode & 1 ? gt & 2 && On !== 0 ? On & -On : VI.transition !== null ? (Rh === 0 && (u = Wd, Wd <<= 1, !(Wd & 4194240) && (Wd = 64), Rh = u), Rh) : (u = Rt, u !== 0 ? u : Pe()) : 1
    }

    function er(u, f, g) {
        if (50 < _c) throw _c = 0, X0 = null, Error(o(185));
        var w = Ih(u, f);
        return w === null ? null : (rc(w, f, g), (!(gt & 2) || w !== yn) && (w === yn && (!(gt & 2) && (Eh |= f), Sn === 4 && to(w, On)), yi(w, g), f === 1 && gt === 0 && !(u.mode & 1) && (bl(), Qd && Wr())), w)
    }

    function Ih(u, f) {
        u.lanes |= f;
        var g = u.alternate;
        for (g !== null && (g.lanes |= f), g = u, u = u.return; u !== null;) u.childLanes |= f, g = u.alternate, g !== null && (g.childLanes |= f), g = u, u = u.return;
        return g.tag === 3 ? g.stateNode : null
    }

    function yi(u, f) {
        var g = u.callbackNode;
        DI(u, f);
        var w = Jd(u, u === yn ? On : 0);
        if (w === 0) g !== null && Mw(g), u.callbackNode = null, u.callbackPriority = 0;
        else if (f = w & -w, u.callbackPriority !== f) {
            if (g != null && Mw(g), f === 1) u.tag === 0 ? HI(zS.bind(null, u)) : Cw(zS.bind(null, u)), Je ? je(function() {
                gt === 0 && Wr()
            }) : t0(n0, Wr), g = null;
            else {
                switch (Sw(w)) {
                    case 1:
                        g = n0;
                        break;
                    case 4:
                        g = OI;
                        break;
                    case 16:
                        g = i0;
                        break;
                    case 536870912:
                        g = UI;
                        break;
                    default:
                        g = i0
                }
                g = KS(g, US.bind(null, u))
            }
            u.callbackPriority = f, u.callbackNode = g
        }
    }

    function US(u, f) {
        if (Ph = -1, Rh = 0, gt & 6) throw Error(o(327));
        var g = u.callbackNode;
        if (ca() && u.callbackNode !== g) return null;
        var w = Jd(u, u === yn ? On : 0);
        if (w === 0) return null;
        if (w & 30 || w & u.expiredLanes || f) f = Lh(u, w);
        else {
            f = w;
            var C = gt;
            gt |= 2;
            var T = VS();
            (yn !== u || On !== f) && (bl(), la(u, f));
            do try {
                cL();
                break
            } catch (X) {
                HS(u, X)
            }
            while (1);
            o0(), Ch.current = T, gt = C, vn !== null ? f = 0 : (yn = null, On = 0, f = Sn)
        }
        if (f !== 0) {
            if (f === 2 && (C = qg(u), C !== 0 && (w = C, f = Q0(u, C))), f === 1) throw g = Ac, la(u, 0), to(u, w), yi(u, In()), g;
            if (f === 6) to(u, w);
            else {
                if (C = u.current.alternate, !(w & 30) && !lL(C) && (f = Lh(u, w), f === 2 && (T = qg(u), T !== 0 && (w = T, f = Q0(u, T))), f === 1)) throw g = Ac, la(u, 0), to(u, w), yi(u, In()), g;
                switch (u.finishedWork = C, u.finishedLanes = w, f) {
                    case 0:
                    case 1:
                        throw Error(o(345));
                    case 2:
                        ua(u, gi);
                        break;
                    case 3:
                        if (to(u, w), (w & 130023424) === w && (f = W0 + 500 - In(), 10 < f)) {
                            if (Jd(u, 0) !== 0) break;
                            if (C = u.suspendedLanes, (C & w) !== w) {
                                ii(), u.pingedLanes |= u.suspendedLanes & C;
                                break
                            }
                            u.timeoutHandle = Ne(ua.bind(null, u, gi), f);
                            break
                        }
                        ua(u, gi);
                        break;
                    case 4:
                        if (to(u, w), (w & 4194240) === w) break;
                        for (f = u.eventTimes, C = -1; 0 < w;) {
                            var N = 31 - Ar(w);
                            T = 1 << N, N = f[N], N > C && (C = N), w &= ~T
                        }
                        if (w = C, w = In() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * aL(w / 1960)) - w, 10 < w) {
                            u.timeoutHandle = Ne(ua.bind(null, u, gi), w);
                            break
                        }
                        ua(u, gi);
                        break;
                    case 5:
                        ua(u, gi);
                        break;
                    default:
                        throw Error(o(329))
                }
            }
        }
        return yi(u, In()), u.callbackNode === g ? US.bind(null, u) : null
    }

    function Q0(u, f) {
        var g = xc;
        return u.current.memoizedState.isDehydrated && (la(u, f).flags |= 256), u = Lh(u, f), u !== 2 && (f = gi, gi = g, f !== null && K0(f)), u
    }

    function K0(u) {
        gi === null ? gi = u : gi.push.apply(gi, u)
    }

    function lL(u) {
        for (var f = u;;) {
            if (f.flags & 16384) {
                var g = f.updateQueue;
                if (g !== null && (g = g.stores, g !== null))
                    for (var w = 0; w < g.length; w++) {
                        var C = g[w],
                            T = C.getSnapshot;
                        C = C.value;
                        try {
                            if (!Vr(T(), C)) return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (g = f.child, f.subtreeFlags & 16384 && g !== null) g.return = f, f = g;
            else {
                if (f === u) break;
                for (; f.sibling === null;) {
                    if (f.return === null || f.return === u) return !0;
                    f = f.return
                }
                f.sibling.return = f.return, f = f.sibling
            }
        }
        return !0
    }

    function to(u, f) {
        for (f &= ~V0, f &= ~Eh, u.suspendedLanes |= f, u.pingedLanes &= ~f, u = u.expirationTimes; 0 < f;) {
            var g = 31 - Ar(f),
                w = 1 << g;
            u[g] = -1, f &= ~w
        }
    }

    function zS(u) {
        if (gt & 6) throw Error(o(327));
        ca();
        var f = Jd(u, 0);
        if (!(f & 1)) return yi(u, In()), null;
        var g = Lh(u, f);
        if (u.tag !== 0 && g === 2) {
            var w = qg(u);
            w !== 0 && (f = w, g = Q0(u, w))
        }
        if (g === 1) throw g = Ac, la(u, 0), to(u, f), yi(u, In()), g;
        if (g === 6) throw Error(o(345));
        return u.finishedWork = u.current.alternate, u.finishedLanes = f, ua(u, gi), yi(u, In()), null
    }

    function GS(u) {
        $s !== null && $s.tag === 0 && !(gt & 6) && ca();
        var f = gt;
        gt |= 1;
        var g = hn.transition,
            w = Rt;
        try {
            if (hn.transition = null, Rt = 1, u) return u()
        } finally {
            Rt = w, hn.transition = g, gt = f, !(gt & 6) && Wr()
        }
    }

    function Y0() {
        Ri = Cl.current, ct(Cl)
    }

    function la(u, f) {
        u.finishedWork = null, u.finishedLanes = 0;
        var g = u.timeoutHandle;
        if (g !== He && (u.timeoutHandle = He, Oe(g)), vn !== null)
            for (g = vn.return; g !== null;) {
                var w = g;
                switch (h0(w), w.tag) {
                    case 1:
                        w = w.type.childContextTypes, w != null && Hd();
                        break;
                    case 3:
                        Sl(), ct(Rn), ct(Ft), x0();
                        break;
                    case 5:
                        v0(w);
                        break;
                    case 4:
                        Sl();
                        break;
                    case 13:
                        ct(Zt);
                        break;
                    case 19:
                        ct(Zt);
                        break;
                    case 10:
                        a0(w.type._context);
                        break;
                    case 22:
                    case 23:
                        Y0()
                }
                g = g.return
            }
        if (yn = u, vn = u = no(u.current, null), On = Ri = f, Sn = 0, Ac = null, V0 = Eh = El = 0, gi = xc = null, jr !== null) {
            for (f = 0; f < jr.length; f++)
                if (g = jr[f], w = g.interleaved, w !== null) {
                    g.interleaved = null;
                    var C = w.next,
                        T = g.pending;
                    if (T !== null) {
                        var N = T.next;
                        T.next = C, w.next = N
                    }
                    g.pending = w
                } jr = null
        }
        return u
    }

    function HS(u, f) {
        do {
            var g = vn;
            try {
                if (o0(), sh.current = fh, oh) {
                    for (var w = ln.memoizedState; w !== null;) {
                        var C = w.queue;
                        C !== null && (C.pending = null), w = w.next
                    }
                    oh = !1
                }
                if (Ml = 0, Ln = Wn = ln = null, cc = !1, fc = 0, H0.current = null, g === null || g.return === null) {
                    Sn = 1, Ac = f, vn = null;
                    break
                }
                e: {
                    var T = u,
                        N = g.return,
                        X = g,
                        de = f;
                    if (f = On, X.flags |= 32768, de !== null && typeof de == "object" && typeof de.then == "function") {
                        var be = de,
                            Ve = X,
                            ot = Ve.tag;
                        if (!(Ve.mode & 1) && (ot === 0 || ot === 11 || ot === 15)) {
                            var et = Ve.alternate;
                            et ? (Ve.updateQueue = et.updateQueue, Ve.memoizedState = et.memoizedState, Ve.lanes = et.lanes) : (Ve.updateQueue = null, Ve.memoizedState = null)
                        }
                        var Ut = uS(N);
                        if (Ut !== null) {
                            Ut.flags &= -257, cS(Ut, N, X, T, f), Ut.mode & 1 && lS(T, be, f), f = Ut, de = be;
                            var Ye = f.updateQueue;
                            if (Ye === null) {
                                var Xn = new Set;
                                Xn.add(de), f.updateQueue = Xn
                            } else Ye.add(de);
                            break e
                        } else {
                            if (!(f & 1)) {
                                lS(T, be, f), Z0();
                                break e
                            }
                            de = Error(o(426))
                        }
                    } else if (Xt && X.mode & 1) {
                        var nr = uS(N);
                        if (nr !== null) {
                            !(nr.flags & 65536) && (nr.flags |= 256), cS(nr, N, X, T, f), g0(de);
                            break e
                        }
                    }
                    T = de,
                    Sn !== 4 && (Sn = 2),
                    xc === null ? xc = [T] : xc.push(T),
                    de = b0(de, X),
                    X = N;do {
                        switch (X.tag) {
                            case 3:
                                X.flags |= 65536, f &= -f, X.lanes |= f;
                                var ne = oS(X, de, f);
                                Tw(X, ne);
                                break e;
                            case 1:
                                T = de;
                                var Y = X.type,
                                    ce = X.stateNode;
                                if (!(X.flags & 128) && (typeof Y.getDerivedStateFromError == "function" || ce !== null && typeof ce.componentDidCatch == "function" && (qs === null || !qs.has(ce)))) {
                                    X.flags |= 65536, f &= -f, X.lanes |= f;
                                    var ke = aS(X, T, f);
                                    Tw(X, ke);
                                    break e
                                }
                        }
                        X = X.return
                    } while (X !== null)
                }
                jS(g)
            } catch (Qe) {
                f = Qe, vn === g && g !== null && (vn = g = g.return);
                continue
            }
            break
        } while (1)
    }

    function VS() {
        var u = Ch.current;
        return Ch.current = fh, u === null ? fh : u
    }

    function Z0() {
        (Sn === 0 || Sn === 3 || Sn === 2) && (Sn = 4), yn === null || !(El & 268435455) && !(Eh & 268435455) || to(yn, On)
    }

    function Lh(u, f) {
        var g = gt;
        gt |= 2;
        var w = VS();
        yn === u && On === f || la(u, f);
        do try {
            uL();
            break
        } catch (C) {
            HS(u, C)
        }
        while (1);
        if (o0(), gt = g, Ch.current = w, vn !== null) throw Error(o(261));
        return yn = null, On = 0, Sn
    }

    function uL() {
        for (; vn !== null;) WS(vn)
    }

    function cL() {
        for (; vn !== null && !kI();) WS(vn)
    }

    function WS(u) {
        var f = QS(u.alternate, u, Ri);
        u.memoizedProps = u.pendingProps, f === null ? jS(u) : vn = f, H0.current = null
    }

    function jS(u) {
        var f = u;
        do {
            var g = f.alternate;
            if (u = f.return, f.flags & 32768) {
                if (g = nL(g, f), g !== null) {
                    g.flags &= 32767, vn = g;
                    return
                }
                if (u !== null) u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null;
                else {
                    Sn = 6, vn = null;
                    return
                }
            } else if (g = $I(g, f, Ri), g !== null) {
                vn = g;
                return
            }
            if (f = f.sibling, f !== null) {
                vn = f;
                return
            }
            vn = f = u
        } while (f !== null);
        Sn === 0 && (Sn = 5)
    }

    function ua(u, f) {
        var g = Rt,
            w = hn.transition;
        try {
            hn.transition = null, Rt = 1, fL(u, f, g)
        } finally {
            hn.transition = w, Rt = g
        }
        return null
    }

    function fL(u, f, g) {
        do ca(); while ($s !== null);
        if (gt & 6) throw Error(o(327));
        var w = u.finishedWork,
            C = u.finishedLanes;
        if (w === null) return null;
        if (u.finishedWork = null, u.finishedLanes = 0, w === u.current) throw Error(o(177));
        u.callbackNode = null, u.callbackPriority = 0;
        var T = w.lanes | w.childLanes;
        if (FI(u, T), u === yn && (vn = yn = null, On = 0), !(w.subtreeFlags & 2064) && !(w.flags & 2064) || Th || (Th = !0, KS(i0, function() {
                return ca(), null
            })), T = (w.flags & 15990) !== 0, w.subtreeFlags & 15990 || T) {
            T = hn.transition, hn.transition = null;
            var N = Rt;
            Rt = 1;
            var X = gt;
            gt |= 4, H0.current = null, rL(u, w), sL(u, w), J(u.containerInfo), u.current = w, oL(w), NI(), gt = X, Rt = N, hn.transition = T
        } else u.current = w;
        if (Th && (Th = !1, $s = u, Bh = C), T = u.pendingLanes, T === 0 && (qs = null), zI(w.stateNode), yi(u, In()), f !== null)
            for (g = u.onRecoverableError, w = 0; w < f.length; w++) g(f[w]);
        if (bh) throw bh = !1, u = J0, J0 = null, u;
        return Bh & 1 && u.tag !== 0 && ca(), T = u.pendingLanes, T & 1 ? u === X0 ? _c++ : (_c = 0, X0 = u) : _c = 0, Wr(), null
    }

    function ca() {
        if ($s !== null) {
            var u = Sw(Bh),
                f = hn.transition,
                g = Rt;
            try {
                if (hn.transition = null, Rt = 16 > u ? 16 : u, $s === null) var w = !1;
                else {
                    if (u = $s, $s = null, Bh = 0, gt & 6) throw Error(o(331));
                    var C = gt;
                    for (gt |= 4, Fe = u.current; Fe !== null;) {
                        var T = Fe,
                            N = T.child;
                        if (Fe.flags & 16) {
                            var X = T.deletions;
                            if (X !== null) {
                                for (var de = 0; de < X.length; de++) {
                                    var be = X[de];
                                    for (Fe = be; Fe !== null;) {
                                        var Ve = Fe;
                                        switch (Ve.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                aa(8, Ve, T)
                                        }
                                        var ot = Ve.child;
                                        if (ot !== null) ot.return = Ve, Fe = ot;
                                        else
                                            for (; Fe !== null;) {
                                                Ve = Fe;
                                                var et = Ve.sibling,
                                                    Ut = Ve.return;
                                                if (BS(Ve), Ve === be) {
                                                    Fe = null;
                                                    break
                                                }
                                                if (et !== null) {
                                                    et.return = Ut, Fe = et;
                                                    break
                                                }
                                                Fe = Ut
                                            }
                                    }
                                }
                                var Ye = T.alternate;
                                if (Ye !== null) {
                                    var Xn = Ye.child;
                                    if (Xn !== null) {
                                        Ye.child = null;
                                        do {
                                            var nr = Xn.sibling;
                                            Xn.sibling = null, Xn = nr
                                        } while (Xn !== null)
                                    }
                                }
                                Fe = T
                            }
                        }
                        if (T.subtreeFlags & 2064 && N !== null) N.return = T, Fe = N;
                        else e: for (; Fe !== null;) {
                            if (T = Fe, T.flags & 2048) switch (T.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    aa(9, T, T.return)
                            }
                            var ne = T.sibling;
                            if (ne !== null) {
                                ne.return = T.return, Fe = ne;
                                break e
                            }
                            Fe = T.return
                        }
                    }
                    var Y = u.current;
                    for (Fe = Y; Fe !== null;) {
                        N = Fe;
                        var ce = N.child;
                        if (N.subtreeFlags & 2064 && ce !== null) ce.return = N, Fe = ce;
                        else e: for (N = Y; Fe !== null;) {
                            if (X = Fe, X.flags & 2048) try {
                                switch (X.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        yc(9, X)
                                }
                            } catch (Qe) {
                                vi(X, X.return, Qe)
                            }
                            if (X === N) {
                                Fe = null;
                                break e
                            }
                            var ke = X.sibling;
                            if (ke !== null) {
                                ke.return = X.return, Fe = ke;
                                break e
                            }
                            Fe = X.return
                        }
                    }
                    if (gt = C, Wr(), Hr && typeof Hr.onPostCommitFiberRoot == "function") try {
                        Hr.onPostCommitFiberRoot(Xd, u)
                    } catch {}
                    w = !0
                }
                return w
            } finally {
                Rt = g, hn.transition = f
            }
        }
        return !1
    }

    function JS(u, f, g) {
        f = b0(g, f), f = oS(u, f, 1), Zs(u, f), f = ii(), u = Ih(u, 1), u !== null && (rc(u, 1, f), yi(u, f))
    }

    function vi(u, f, g) {
        if (u.tag === 3) JS(u, u, g);
        else
            for (; f !== null;) {
                if (f.tag === 3) {
                    JS(f, u, g);
                    break
                } else if (f.tag === 1) {
                    var w = f.stateNode;
                    if (typeof f.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (qs === null || !qs.has(w))) {
                        u = b0(g, u), u = aS(f, u, 1), Zs(f, u), u = ii(), f = Ih(f, 1), f !== null && (rc(f, 1, u), yi(f, u));
                        break
                    }
                }
                f = f.return
            }
    }

    function dL(u, f, g) {
        var w = u.pingCache;
        w !== null && w.delete(f), f = ii(), u.pingedLanes |= u.suspendedLanes & g, yn === u && (On & g) === g && (Sn === 4 || Sn === 3 && (On & 130023424) === On && 500 > In() - W0 ? la(u, 0) : V0 |= g), yi(u, f)
    }

    function XS(u, f) {
        f === 0 && (u.mode & 1 ? (f = jd, jd <<= 1, !(jd & 130023424) && (jd = 4194304)) : f = 1);
        var g = ii();
        u = Ih(u, f), u !== null && (rc(u, f, g), yi(u, g))
    }

    function hL(u) {
        var f = u.memoizedState,
            g = 0;
        f !== null && (g = f.retryLane), XS(u, g)
    }

    function pL(u, f) {
        var g = 0;
        switch (u.tag) {
            case 13:
                var w = u.stateNode,
                    C = u.memoizedState;
                C !== null && (g = C.retryLane);
                break;
            case 19:
                w = u.stateNode;
                break;
            default:
                throw Error(o(314))
        }
        w !== null && w.delete(f), XS(u, g)
    }
    var QS;
    QS = function(u, f, g) {
        if (u !== null)
            if (u.memoizedProps !== f.pendingProps || Rn.current) Pi = !0;
            else {
                if (!(u.lanes & g) && !(f.flags & 128)) return Pi = !1, tL(u, f, g);
                Pi = !!(u.flags & 131072)
            }
        else Pi = !1, Xt && f.flags & 1048576 && Dw(f, nh, f.index);
        switch (f.lanes = 0, f.tag) {
            case 2:
                var w = f.type;
                u !== null && (u.alternate = null, f.alternate = null, f.flags |= 2), u = f.pendingProps;
                var C = fs(f, Ft.current);
                yl(f, g), C = w0(null, f, w, u, C, g);
                var T = S0();
                return f.flags |= 1, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0 ? (f.tag = 1, f.memoizedState = null, f.updateQueue = null, mi(w) ? (T = !0, Vd(f)) : T = !1, f.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, u0(f), C.updater = eh, f.stateNode = C, C._reactInternals = f, f0(f, w, u, g), f = P0(null, f, w, !0, T, g)) : (f.tag = 0, Xt && T && d0(f), ni(null, f, C, g), f = f.child), f;
            case 16:
                w = f.elementType;
                e: {
                    switch (u !== null && (u.alternate = null, f.alternate = null, f.flags |= 2), u = f.pendingProps, C = w._init, w = C(w._payload), f.type = w, C = f.tag = gL(w), u = xr(w, u), C) {
                        case 0:
                            f = B0(null, f, w, u, g);
                            break e;
                        case 1:
                            f = vS(null, f, w, u, g);
                            break e;
                        case 11:
                            f = hS(null, f, w, u, g);
                            break e;
                        case 14:
                            f = pS(null, f, w, xr(w.type, u), g);
                            break e
                    }
                    throw Error(o(306, w, ""))
                }
                return f;
            case 0:
                return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : xr(w, C), B0(u, f, w, C, g);
            case 1:
                return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : xr(w, C), vS(u, f, w, C, g);
            case 3:
                e: {
                    if (AS(f), u === null) throw Error(o(387));w = f.pendingProps,
                    T = f.memoizedState,
                    C = T.element,
                    bw(u, f),
                    $d(f, w, null, g);
                    var N = f.memoizedState;
                    if (w = N.element, ae && T.isDehydrated)
                        if (T = {
                                element: w,
                                isDehydrated: !1,
                                cache: N.cache,
                                transitions: N.transitions
                            }, f.updateQueue.baseState = T, f.memoizedState = T, f.flags & 256) {
                            C = Error(o(423)), f = xS(u, f, w, g, C);
                            break e
                        } else if (w !== C) {
                        C = Error(o(424)), f = xS(u, f, w, g, C);
                        break e
                    } else
                        for (ae && (Bi = $(f.stateNode.containerInfo), Ti = f, Xt = !0, _r = null, sc = !1), g = zw(f, null, w, g), f.child = g; g;) g.flags = g.flags & -3 | 4096, g = g.sibling;
                    else {
                        if (xl(), w === C) {
                            f = ys(u, f, g);
                            break e
                        }
                        ni(u, f, w, g)
                    }
                    f = f.child
                }
                return f;
            case 5:
                return Gw(f), u === null && m0(f), w = f.type, C = f.pendingProps, T = u !== null ? u.memoizedProps : null, N = C.children, xe(w, C) ? N = null : T !== null && xe(w, T) && (f.flags |= 32), yS(u, f), ni(u, f, N, g), f.child;
            case 6:
                return u === null && m0(f), null;
            case 13:
                return _S(u, f, g);
            case 4:
                return y0(f, f.stateNode.containerInfo), w = f.pendingProps, u === null ? f.child = _l(f, null, w, g) : ni(u, f, w, g), f.child;
            case 11:
                return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : xr(w, C), hS(u, f, w, C, g);
            case 7:
                return ni(u, f, f.pendingProps, g), f.child;
            case 8:
                return ni(u, f, f.pendingProps.children, g), f.child;
            case 12:
                return ni(u, f, f.pendingProps.children, g), f.child;
            case 10:
                e: {
                    if (w = f.type._context, C = f.pendingProps, T = f.memoizedProps, N = C.value, Ew(f, w, N), T !== null)
                        if (Vr(T.value, N)) {
                            if (T.children === C.children && !Rn.current) {
                                f = ys(u, f, g);
                                break e
                            }
                        } else
                            for (T = f.child, T !== null && (T.return = f); T !== null;) {
                                var X = T.dependencies;
                                if (X !== null) {
                                    N = T.child;
                                    for (var de = X.firstContext; de !== null;) {
                                        if (de.context === w) {
                                            if (T.tag === 1) {
                                                de = hs(-1, g & -g), de.tag = 2;
                                                var be = T.updateQueue;
                                                if (be !== null) {
                                                    be = be.shared;
                                                    var Ve = be.pending;
                                                    Ve === null ? de.next = de : (de.next = Ve.next, Ve.next = de), be.pending = de
                                                }
                                            }
                                            T.lanes |= g, de = T.alternate, de !== null && (de.lanes |= g), l0(T.return, g, f), X.lanes |= g;
                                            break
                                        }
                                        de = de.next
                                    }
                                } else if (T.tag === 10) N = T.type === f.type ? null : T.child;
                                else if (T.tag === 18) {
                                    if (N = T.return, N === null) throw Error(o(341));
                                    N.lanes |= g, X = N.alternate, X !== null && (X.lanes |= g), l0(N, g, f), N = T.sibling
                                } else N = T.child;
                                if (N !== null) N.return = T;
                                else
                                    for (N = T; N !== null;) {
                                        if (N === f) {
                                            N = null;
                                            break
                                        }
                                        if (T = N.sibling, T !== null) {
                                            T.return = N.return, N = T;
                                            break
                                        }
                                        N = N.return
                                    }
                                T = N
                            }
                    ni(u, f, C.children, g),
                    f = f.child
                }
                return f;
            case 9:
                return C = f.type, w = f.pendingProps.children, yl(f, g), C = Ki(C), w = w(C), f.flags |= 1, ni(u, f, w, g), f.child;
            case 14:
                return w = f.type, C = xr(w, f.pendingProps), C = xr(w.type, C), pS(u, f, w, C, g);
            case 15:
                return mS(u, f, f.type, f.pendingProps, g);
            case 17:
                return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : xr(w, C), u !== null && (u.alternate = null, f.alternate = null, f.flags |= 2), f.tag = 1, mi(w) ? (u = !0, Vd(f)) : u = !1, yl(f, g), Iw(f, w, C), f0(f, w, C, g), P0(null, f, w, !0, u, g);
            case 19:
                return CS(u, f, g);
            case 22:
                return gS(u, f, g)
        }
        throw Error(o(156, f.tag))
    };

    function KS(u, f) {
        return t0(u, f)
    }

    function mL(u, f, g, w) {
        this.tag = u, this.key = g, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
    }

    function tr(u, f, g, w) {
        return new mL(u, f, g, w)
    }

    function q0(u) {
        return u = u.prototype, !(!u || !u.isReactComponent)
    }

    function gL(u) {
        if (typeof u == "function") return q0(u) ? 1 : 0;
        if (u != null) {
            if (u = u.$$typeof, u === y) return 11;
            if (u === _) return 14
        }
        return 2
    }

    function no(u, f) {
        var g = u.alternate;
        return g === null ? (g = tr(u.tag, f, u.key, u.mode), g.elementType = u.elementType, g.type = u.type, g.stateNode = u.stateNode, g.alternate = u, u.alternate = g) : (g.pendingProps = f, g.type = u.type, g.flags = 0, g.subtreeFlags = 0, g.deletions = null), g.flags = u.flags & 14680064, g.childLanes = u.childLanes, g.lanes = u.lanes, g.child = u.child, g.memoizedProps = u.memoizedProps, g.memoizedState = u.memoizedState, g.updateQueue = u.updateQueue, f = u.dependencies, g.dependencies = f === null ? null : {
            lanes: f.lanes,
            firstContext: f.firstContext
        }, g.sibling = u.sibling, g.index = u.index, g.ref = u.ref, g
    }

    function Dh(u, f, g, w, C, T) {
        var N = 2;
        if (w = u, typeof u == "function") q0(u) && (N = 1);
        else if (typeof u == "string") N = 5;
        else e: switch (u) {
            case d:
                return fa(g.children, C, T, f);
            case h:
                N = 8, C |= 8;
                break;
            case p:
                return u = tr(12, g, f, C | 2), u.elementType = p, u.lanes = T, u;
            case A:
                return u = tr(13, g, f, C), u.elementType = A, u.lanes = T, u;
            case x:
                return u = tr(19, g, f, C), u.elementType = x, u.lanes = T, u;
            case M:
                return Fh(g, C, T, f);
            default:
                if (typeof u == "object" && u !== null) switch (u.$$typeof) {
                    case m:
                        N = 10;
                        break e;
                    case v:
                        N = 9;
                        break e;
                    case y:
                        N = 11;
                        break e;
                    case _:
                        N = 14;
                        break e;
                    case S:
                        N = 16, w = null;
                        break e
                }
                throw Error(o(130, u == null ? u : typeof u, ""))
        }
        return f = tr(N, g, f, C), f.elementType = u, f.type = w, f.lanes = T, f
    }

    function fa(u, f, g, w) {
        return u = tr(7, u, w, f), u.lanes = g, u
    }

    function Fh(u, f, g, w) {
        return u = tr(22, u, w, f), u.elementType = M, u.lanes = g, u.stateNode = {}, u
    }

    function $0(u, f, g) {
        return u = tr(6, u, null, f), u.lanes = g, u
    }

    function ey(u, f, g) {
        return f = tr(4, u.children !== null ? u.children : [], u.key, f), f.lanes = g, f.stateNode = {
            containerInfo: u.containerInfo,
            pendingChildren: null,
            implementation: u.implementation
        }, f
    }

    function yL(u, f, g, w, C) {
        this.tag = f, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = He, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = $g(0), this.expirationTimes = $g(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = $g(0), this.identifierPrefix = w, this.onRecoverableError = C, ae && (this.mutableSourceEagerHydrationData = null)
    }

    function YS(u, f, g, w, C, T, N, X, de) {
        return u = new yL(u, f, g, X, de), f === 1 ? (f = 1, T === !0 && (f |= 8)) : f = 0, T = tr(3, null, null, f), u.current = T, T.stateNode = u, T.memoizedState = {
            element: w,
            isDehydrated: g,
            cache: null,
            transitions: null
        }, u0(T), u
    }

    function ZS(u) {
        if (!u) return Qi;
        u = u._reactInternals;
        e: {
            if (P(u) !== u || u.tag !== 1) throw Error(o(170));
            var f = u;do {
                switch (f.tag) {
                    case 3:
                        f = f.stateNode.context;
                        break e;
                    case 1:
                        if (mi(f.type)) {
                            f = f.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                f = f.return
            } while (f !== null);
            throw Error(o(171))
        }
        if (u.tag === 1) {
            var g = u.type;
            if (mi(g)) return _w(u, g, f)
        }
        return f
    }

    function qS(u) {
        var f = u._reactInternals;
        if (f === void 0) throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","), Error(o(268, u)));
        return u = Z(f), u === null ? null : u.stateNode
    }

    function $S(u, f) {
        if (u = u.memoizedState, u !== null && u.dehydrated !== null) {
            var g = u.retryLane;
            u.retryLane = g !== 0 && g < f ? g : f
        }
    }

    function ty(u, f) {
        $S(u, f), (u = u.alternate) && $S(u, f)
    }

    function vL(u) {
        return u = Z(u), u === null ? null : u.stateNode
    }

    function AL() {
        return null
    }
    return t.attemptContinuousHydration = function(u) {
        if (u.tag === 13) {
            var f = ii();
            er(u, 134217728, f), ty(u, 134217728)
        }
    }, t.attemptHydrationAtCurrentPriority = function(u) {
        if (u.tag === 13) {
            var f = ii(),
                g = eo(u);
            er(u, g, f), ty(u, g)
        }
    }, t.attemptSynchronousHydration = function(u) {
        switch (u.tag) {
            case 3:
                var f = u.stateNode;
                if (f.current.memoizedState.isDehydrated) {
                    var g = ic(f.pendingLanes);
                    g !== 0 && (e0(f, g | 1), yi(f, In()), !(gt & 6) && (bl(), Wr()))
                }
                break;
            case 13:
                var w = ii();
                GS(function() {
                    return er(u, 1, w)
                }), ty(u, 1)
        }
    }, t.batchedUpdates = function(u, f) {
        var g = gt;
        gt |= 1;
        try {
            return u(f)
        } finally {
            gt = g, gt === 0 && (bl(), Qd && Wr())
        }
    }, t.createComponentSelector = function(u) {
        return {
            $$typeof: xh,
            value: u
        }
    }, t.createContainer = function(u, f, g, w, C, T, N) {
        return YS(u, f, !1, null, g, w, C, T, N)
    }, t.createHasPseudoClassSelector = function(u) {
        return {
            $$typeof: _h,
            value: u
        }
    }, t.createHydrationContainer = function(u, f, g, w, C, T, N, X, de) {
        return u = YS(g, w, !0, u, C, T, N, X, de), u.context = ZS(null), g = u.current, w = ii(), C = eo(g), T = hs(w, C), T.callback = f ?? null, Zs(g, T), u.current.lanes = C, rc(u, C, w), yi(u, w), u
    }, t.createPortal = function(u, f, g) {
        var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: c,
            key: w == null ? null : "" + w,
            children: u,
            containerInfo: f,
            implementation: g
        }
    }, t.createRoleSelector = function(u) {
        return {
            $$typeof: wh,
            value: u
        }
    }, t.createTestNameSelector = function(u) {
        return {
            $$typeof: Sh,
            value: u
        }
    }, t.createTextSelector = function(u) {
        return {
            $$typeof: Mh,
            value: u
        }
    }, t.deferredUpdates = function(u) {
        var f = Rt,
            g = hn.transition;
        try {
            return hn.transition = null, Rt = 16, u()
        } finally {
            Rt = f, hn.transition = g
        }
    }, t.discreteUpdates = function(u, f, g, w, C) {
        var T = Rt,
            N = hn.transition;
        try {
            return hn.transition = null, Rt = 1, u(f, g, w, C)
        } finally {
            Rt = T, hn.transition = N, gt === 0 && bl()
        }
    }, t.findAllNodes = G0, t.findBoundingRects = function(u, f) {
        if (!vt) throw Error(o(363));
        f = G0(u, f), u = [];
        for (var g = 0; g < f.length; g++) u.push(O(f[g]));
        for (f = u.length - 1; 0 < f; f--) {
            g = u[f];
            for (var w = g.x, C = w + g.width, T = g.y, N = T + g.height, X = f - 1; 0 <= X; X--)
                if (f !== X) {
                    var de = u[X],
                        be = de.x,
                        Ve = be + de.width,
                        ot = de.y,
                        et = ot + de.height;
                    if (w >= be && T >= ot && C <= Ve && N <= et) {
                        u.splice(f, 1);
                        break
                    } else if (w !== be || g.width !== de.width || et < T || ot > N) {
                        if (!(T !== ot || g.height !== de.height || Ve < w || be > C)) {
                            be > w && (de.width += be - w, de.x = w), Ve < C && (de.width = C - be), u.splice(f, 1);
                            break
                        }
                    } else {
                        ot > T && (de.height += ot - T, de.y = T), et < N && (de.height = N - ot), u.splice(f, 1);
                        break
                    }
                }
        }
        return u
    }, t.findHostInstance = qS, t.findHostInstanceWithNoPortals = function(u) {
        return u = z(u), u = u !== null ? G(u) : null, u === null ? null : u.stateNode
    }, t.findHostInstanceWithWarning = function(u) {
        return qS(u)
    }, t.flushControlled = function(u) {
        var f = gt;
        gt |= 1;
        var g = hn.transition,
            w = Rt;
        try {
            hn.transition = null, Rt = 1, u()
        } finally {
            Rt = w, hn.transition = g, gt = f, gt === 0 && (bl(), Wr())
        }
    }, t.flushPassiveEffects = ca, t.flushSync = GS, t.focusWithin = function(u, f) {
        if (!vt) throw Error(o(363));
        for (u = O0(u), f = OS(u, f), f = Array.from(f), u = 0; u < f.length;) {
            var g = f[u++];
            if (!oe(g)) {
                if (g.tag === 5 && Ee(g.stateNode)) return !0;
                for (g = g.child; g !== null;) f.push(g), g = g.sibling
            }
        }
        return !1
    }, t.getCurrentUpdatePriority = function() {
        return Rt
    }, t.getFindAllNodesFailureDescription = function(u, f) {
        if (!vt) throw Error(o(363));
        var g = 0,
            w = [];
        u = [O0(u), 0];
        for (var C = 0; C < u.length;) {
            var T = u[C++],
                N = u[C++],
                X = f[N];
            if ((T.tag !== 5 || !oe(T)) && (U0(T, X) && (w.push(z0(X)), N++, N > g && (g = N)), N < f.length))
                for (T = T.child; T !== null;) u.push(T, N), T = T.sibling
        }
        if (g < f.length) {
            for (u = []; g < f.length; g++) u.push(z0(f[g]));
            return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ")
        }
        return null
    }, t.getPublicRootInstance = function(u) {
        if (u = u.current, !u.child) return null;
        switch (u.child.tag) {
            case 5:
                return te(u.child.stateNode);
            default:
                return u.child.stateNode
        }
    }, t.injectIntoDevTools = function(u) {
        if (u = {
                bundleType: u.bundleType,
                version: u.version,
                rendererPackageName: u.rendererPackageName,
                rendererConfig: u.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: a.ReactCurrentDispatcher,
                findHostInstanceByFiber: vL,
                findFiberByHostInstance: u.findFiberByHostInstance || AL,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329"
            }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") u = !1;
        else {
            var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (f.isDisabled || !f.supportsFiber) u = !0;
            else {
                try {
                    Xd = f.inject(u), Hr = f
                } catch {}
                u = !!f.checkDCE
            }
        }
        return u
    }, t.isAlreadyRendering = function() {
        return !1
    }, t.observeVisibleRects = function(u, f, g, w) {
        if (!vt) throw Error(o(363));
        u = G0(u, f);
        var C = Be(u, g, w).disconnect;
        return {
            disconnect: function() {
                C()
            }
        }
    }, t.registerMutableSourceForHydration = function(u, f) {
        var g = f._getVersion;
        g = g(f._source), u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [f, g] : u.mutableSourceEagerHydrationData.push(f, g)
    }, t.runWithPriority = function(u, f) {
        var g = Rt;
        try {
            return Rt = u, f()
        } finally {
            Rt = g
        }
    }, t.shouldError = function() {
        return null
    }, t.shouldSuspend = function() {
        return !1
    }, t.updateContainer = function(u, f, g, w) {
        var C = f.current,
            T = ii(),
            N = eo(C);
        return g = ZS(g), f.context === null ? f.context = g : f.pendingContext = g, f = hs(T, N), f.payload = {
            element: u
        }, w = w === void 0 ? null : w, w !== null && (f.callback = w), Zs(C, f), u = er(C, N, T), u !== null && qd(u, C, N), N
    }, t
};
(function(n) {
    n.exports = O5
})(k5);
const U5 = xT(xx);

function D3(n, e, t = (i, r) => i === r) {
    if (n === e) return !0;
    if (!n || !e) return !1;
    const i = n.length;
    if (e.length !== i) return !1;
    for (let r = 0; r < i; r++)
        if (!t(n[r], e[r])) return !1;
    return !0
}
const Ts = [];

function F3(n, e, t = !1, i = {}) {
    for (const s of Ts)
        if (D3(e, s.keys, s.equal)) {
            if (t) return;
            if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response")) return s.response;
            if (!t) throw s.promise
        } const r = {
        keys: e,
        equal: i.equal,
        promise: n(...e).then(s => r.response = s).then(() => {
            i.lifespan && i.lifespan > 0 && setTimeout(() => {
                const s = Ts.indexOf(r);
                s !== -1 && Ts.splice(s, 1)
            }, i.lifespan)
        }).catch(s => r.error = s)
    };
    if (Ts.push(r), !t) throw r.promise
}
const z5 = (n, e, t) => F3(n, e, !1, t),
    G5 = (n, e, t) => void F3(n, e, !0, t),
    H5 = n => {
        if (n === void 0 || n.length === 0) Ts.splice(0, Ts.length);
        else {
            const e = Ts.find(t => D3(n, t.keys, t.equal));
            if (e) {
                const t = Ts.indexOf(e);
                t !== -1 && Ts.splice(t, 1)
            }
        }
    };
var OE, UE;
const V5 = (n, ...e) => e.reduce((t, i) => t == null ? void 0 : t[i], n),
    Xl = "ColorManagement" in Ax && V5(Ax, "ColorManagement") || null,
    k3 = n => n && n.isOrthographicCamera,
    W5 = n => n && n.hasOwnProperty("current"),
    Fd = typeof window < "u" && ((OE = window.document) != null && OE.createElement || ((UE = window.navigator) == null ? void 0 : UE.product) === "ReactNative") ? U.useLayoutEffect : U.useEffect;

function N3(n) {
    const e = U.useRef(n);
    return Fd(() => void(e.current = n), [n]), e
}

function j5({
    set: n
}) {
    return Fd(() => (n(new Promise(() => null)), () => n(!1)), [n]), null
}
class O3 extends U.Component {
    constructor(...e) {
        super(...e), this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
O3.getDerivedStateFromError = () => ({
    error: !0
});
const U3 = "__default",
    zE = new Map,
    J5 = n => n && !!n.memoized && !!n.changes;

function z3(n) {
    const e = typeof window < "u" ? window.devicePixelRatio : 1;
    return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n
}
const Hc = n => {
        var e;
        return (e = n.__r3f) == null ? void 0 : e.root.getState()
    },
    qt = {
        obj: n => n === Object(n) && !qt.arr(n) && typeof n != "function",
        fun: n => typeof n == "function",
        str: n => typeof n == "string",
        num: n => typeof n == "number",
        boo: n => typeof n == "boolean",
        und: n => n === void 0,
        arr: n => Array.isArray(n),
        equ(n, e, {
            arrays: t = "shallow",
            objects: i = "reference",
            strict: r = !0
        } = {}) {
            if (typeof n != typeof e || !!n != !!e) return !1;
            if (qt.str(n) || qt.num(n)) return n === e;
            const s = qt.obj(n);
            if (s && i === "reference") return n === e;
            const o = qt.arr(n);
            if (o && t === "reference") return n === e;
            if ((o || s) && n === e) return !0;
            let a;
            for (a in n)
                if (!(a in e)) return !1;
            for (a in r ? e : n)
                if (n[a] !== e[a]) return !1;
            if (qt.und(a)) {
                if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0;
                if (n !== e) return !1
            }
            return !0
        }
    };

function X5(n) {
    const e = {
        nodes: {},
        materials: {}
    };
    return n && n.traverse(t => {
        t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material)
    }), e
}

function Q5(n) {
    n.dispose && n.type !== "Scene" && n.dispose();
    for (const e in n) e.dispose == null || e.dispose(), delete n[e]
}

function Ql(n, e) {
    const t = n;
    return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }), n
}

function _x(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-"),
            r = i.pop();
        return t = i.reduce((s, o) => s[o], n), {
            target: t,
            key: r
        }
    } else return {
        target: t,
        key: e
    }
}
const GE = /-\d+$/;

function cv(n, e, t) {
    if (qt.str(t)) {
        if (GE.test(t)) {
            const s = t.replace(GE, ""),
                {
                    target: o,
                    key: a
                } = _x(n, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {
            target: i,
            key: r
        } = _x(n, t);
        e.__r3f.previousAttach = i[r], i[r] = e
    } else e.__r3f.previousAttach = t(n, e)
}

function HE(n, e, t) {
    var i, r;
    if (qt.str(t)) {
        const {
            target: s,
            key: o
        } = _x(n, t), a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else(i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
    (r = e.__r3f) == null || delete r.previousAttach
}

function G3(n, {
    children: e,
    key: t,
    ref: i,
    ...r
}, {
    children: s,
    key: o,
    ref: a,
    ...l
} = {}, c = !1) {
    var d;
    const h = (d = n == null ? void 0 : n.__r3f) != null ? d : {},
        p = Object.entries(r),
        m = [];
    if (c) {
        const y = Object.keys(l);
        for (let A = 0; A < y.length; A++) r.hasOwnProperty(y[A]) || p.unshift([y[A], U3 + "remove"])
    }
    p.forEach(([y, A]) => {
        var x;
        if ((x = n.__r3f) != null && x.primitive && y === "object" || qt.equ(A, l[y])) return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y)) return m.push([y, A, !0, []]);
        let _ = [];
        y.includes("-") && (_ = y.split("-")), m.push([y, A, !1, _]);
        for (const S in r) {
            const M = r[S];
            S.startsWith(`${y}-`) && m.push([S, M, !1, S.split("-")])
        }
    });
    const v = {
        ...r
    };
    return h.memoizedProps && h.memoizedProps.args && (v.args = h.memoizedProps.args), h.memoizedProps && h.memoizedProps.attach && (v.attach = h.memoizedProps.attach), {
        memoized: v,
        changes: m
    }
}

function fv(n, e) {
    var t, i, r;
    const s = (t = n.__r3f) != null ? t : {},
        o = s.root,
        a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {},
        {
            memoized: l,
            changes: c
        } = J5(e) ? e : G3(n, e),
        d = s.eventCount;
    n.__r3f && (n.__r3f.memoizedProps = l);
    for (let p = 0; p < c.length; p++) {
        let [m, v, y, A] = c[p], x = n, _ = x[m];
        if (A.length && (_ = A.reduce((S, M) => S[M], n), !(_ && _.set))) {
            const [S, ...M] = A.reverse();
            x = M.reverse().reduce((b, B) => b[B], n), m = S
        }
        if (v === U3 + "remove")
            if (x.constructor) {
                let S = zE.get(x.constructor);
                S || (S = new x.constructor, zE.set(x.constructor, S)), v = S[m]
            } else v = 0;
        if (y) v ? s.handlers[m] = v : delete s.handlers[m], s.eventCount = Object.keys(s.handlers).length;
        else if (_ && _.set && (_.copy || _ instanceof Ka)) {
            if (Array.isArray(v)) _.fromArray ? _.fromArray(v) : _.set(...v);
            else if (_.copy && v && v.constructor && _.constructor === v.constructor) _.copy(v);
            else if (v !== void 0) {
                const S = _ instanceof Ie;
                !S && _.setScalar ? _.setScalar(v) : _ instanceof Ka && v instanceof Ka ? _.mask = v.mask : _.set(v), !Xl && !a.linear && S && _.convertSRGBToLinear()
            }
        } else x[m] = v, !a.linear && x[m] instanceof Yt && x[m].format === xi && x[m].type === Vs && (x[m].encoding = Ct);
        Kl(n)
    }
    if (s.parent && a.internal && n.raycast && d !== s.eventCount) {
        const p = a.internal.interaction.indexOf(n);
        p > -1 && a.internal.interaction.splice(p, 1), s.eventCount && a.internal.interaction.push(n)
    }
    return !(c.length === 1 && c[0][0] === "onUpdate") && c.length && (r = n.__r3f) != null && r.parent && wx(n), n
}

function Kl(n) {
    var e, t;
    const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    i && i.internal.frames === 0 && i.invalidate()
}

function wx(n) {
    n.onUpdate == null || n.onUpdate(n)
}

function K5(n, e) {
    n.manual || (k3(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld())
}

function Op(n) {
    return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}

function Y5() {
    var n;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e) return Co.DefaultEventPriority;
    switch ((n = e.event) == null ? void 0 : n.type) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
            return Co.DiscreteEventPriority;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
            return Co.ContinuousEventPriority;
        default:
            return Co.DefaultEventPriority
    }
}

function H3(n, e, t, i) {
    const r = t.get(e);
    r && (t.delete(e), t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)))
}

function Z5(n, e) {
    const {
        internal: t
    } = n.getState();
    t.interaction = t.interaction.filter(i => i !== e), t.initialHits = t.initialHits.filter(i => i !== e), t.hovered.forEach((i, r) => {
        (i.eventObject === e || i.object === e) && t.hovered.delete(r)
    }), t.capturedMap.forEach((i, r) => {
        H3(t.capturedMap, e, i, r)
    })
}

function q5(n) {
    function e(l) {
        const {
            internal: c
        } = n.getState(), d = l.offsetX - c.initialClick[0], h = l.offsetY - c.initialClick[1];
        return Math.round(Math.sqrt(d * d + h * h))
    }

    function t(l) {
        return l.filter(c => ["Move", "Over", "Enter", "Out", "Leave"].some(d => {
            var h;
            return (h = c.__r3f) == null ? void 0 : h.handlers["onPointer" + d]
        }))
    }

    function i(l, c) {
        const d = n.getState(),
            h = new Set,
            p = [],
            m = c ? c(d.internal.interaction) : d.internal.interaction;
        for (let x = 0; x < m.length; x++) {
            const _ = Hc(m[x]);
            _ && (_.raycaster.camera = void 0)
        }
        d.previousRoot || d.events.compute == null || d.events.compute(l, d);

        function v(x) {
            const _ = Hc(x);
            if (!_ || !_.events.enabled || _.raycaster.camera === null) return [];
            if (_.raycaster.camera === void 0) {
                var S;
                _.events.compute == null || _.events.compute(l, _, (S = _.previousRoot) == null ? void 0 : S.getState()), _.raycaster.camera === void 0 && (_.raycaster.camera = null)
            }
            return _.raycaster.camera ? _.raycaster.intersectObject(x, !0) : []
        }
        let y = m.flatMap(v).sort((x, _) => {
            const S = Hc(x.object),
                M = Hc(_.object);
            return !S || !M ? x.distance - _.distance : M.events.priority - S.events.priority || x.distance - _.distance
        }).filter(x => {
            const _ = Op(x);
            return h.has(_) ? !1 : (h.add(_), !0)
        });
        d.events.filter && (y = d.events.filter(y, d));
        for (const x of y) {
            let _ = x.object;
            for (; _;) {
                var A;
                (A = _.__r3f) != null && A.eventCount && p.push({
                    ...x,
                    eventObject: _
                }), _ = _.parent
            }
        }
        if ("pointerId" in l && d.internal.capturedMap.has(l.pointerId))
            for (let x of d.internal.capturedMap.get(l.pointerId).values()) h.has(Op(x.intersection)) || p.push(x.intersection);
        return p
    }

    function r(l, c, d, h) {
        const p = n.getState();
        if (l.length) {
            const m = {
                stopped: !1
            };
            for (const v of l) {
                const y = Hc(v.object) || p,
                    {
                        raycaster: A,
                        pointer: x,
                        camera: _,
                        internal: S
                    } = y,
                    M = new D(x.x, x.y, 0).unproject(_),
                    b = I => {
                        var z, Z;
                        return (z = (Z = S.capturedMap.get(I)) == null ? void 0 : Z.has(v.eventObject)) != null ? z : !1
                    },
                    B = I => {
                        const z = {
                            intersection: v,
                            target: c.target
                        };
                        S.capturedMap.has(I) ? S.capturedMap.get(I).set(v.eventObject, z) : S.capturedMap.set(I, new Map([
                            [v.eventObject, z]
                        ])), c.target.setPointerCapture(I)
                    },
                    R = I => {
                        const z = S.capturedMap.get(I);
                        z && H3(S.capturedMap, v.eventObject, z, I)
                    };
                let E = {};
                for (let I in c) {
                    let z = c[I];
                    typeof z != "function" && (E[I] = z)
                }
                let P = {
                    ...v,
                    ...E,
                    pointer: x,
                    intersections: l,
                    stopped: m.stopped,
                    delta: d,
                    unprojectedPoint: M,
                    ray: A.ray,
                    camera: _,
                    stopPropagation() {
                        const I = "pointerId" in c && S.capturedMap.get(c.pointerId);
                        if ((!I || I.has(v.eventObject)) && (P.stopped = m.stopped = !0, S.hovered.size && Array.from(S.hovered.values()).find(z => z.eventObject === v.eventObject))) {
                            const z = l.slice(0, l.indexOf(v));
                            s([...z, v])
                        }
                    },
                    target: {
                        hasPointerCapture: b,
                        setPointerCapture: B,
                        releasePointerCapture: R
                    },
                    currentTarget: {
                        hasPointerCapture: b,
                        setPointerCapture: B,
                        releasePointerCapture: R
                    },
                    nativeEvent: c
                };
                if (h(P), m.stopped === !0) break
            }
        }
        return l
    }

    function s(l) {
        const {
            internal: c
        } = n.getState();
        for (const d of c.hovered.values())
            if (!l.length || !l.find(h => h.object === d.object && h.index === d.index && h.instanceId === d.instanceId)) {
                const p = d.eventObject.__r3f,
                    m = p == null ? void 0 : p.handlers;
                if (c.hovered.delete(Op(d)), p != null && p.eventCount) {
                    const v = {
                        ...d,
                        intersections: l
                    };
                    m.onPointerOut == null || m.onPointerOut(v), m.onPointerLeave == null || m.onPointerLeave(v)
                }
            }
    }

    function o(l, c) {
        for (let d = 0; d < c.length; d++) {
            const h = c[d].__r3f;
            h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(l)
        }
    }

    function a(l) {
        switch (l) {
            case "onPointerLeave":
            case "onPointerCancel":
                return () => s([]);
            case "onLostPointerCapture":
                return c => {
                    const {
                        internal: d
                    } = n.getState();
                    "pointerId" in c && d.capturedMap.has(c.pointerId) && (d.capturedMap.delete(c.pointerId), s([]))
                }
        }
        return function(d) {
            const {
                onPointerMissed: h,
                internal: p
            } = n.getState();
            p.lastEvent.current = d;
            const m = l === "onPointerMove",
                v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
                A = i(d, m ? t : void 0),
                x = v ? e(d) : 0;
            l === "onPointerDown" && (p.initialClick = [d.offsetX, d.offsetY], p.initialHits = A.map(S => S.eventObject)), v && !A.length && x <= 2 && (o(d, p.interaction), h && h(d)), m && s(A);

            function _(S) {
                const M = S.eventObject,
                    b = M.__r3f,
                    B = b == null ? void 0 : b.handlers;
                if (b != null && b.eventCount)
                    if (m) {
                        if (B.onPointerOver || B.onPointerEnter || B.onPointerOut || B.onPointerLeave) {
                            const R = Op(S),
                                E = p.hovered.get(R);
                            E ? E.stopped && S.stopPropagation() : (p.hovered.set(R, S), B.onPointerOver == null || B.onPointerOver(S), B.onPointerEnter == null || B.onPointerEnter(S))
                        }
                        B.onPointerMove == null || B.onPointerMove(S)
                    } else {
                        const R = B[l];
                        R ? (!v || p.initialHits.includes(M)) && (o(d, p.interaction.filter(E => !p.initialHits.includes(E))), R(S)) : v && p.initialHits.includes(M) && o(d, p.interaction.filter(E => !p.initialHits.includes(E)))
                    }
            }
            r(A, d, x, _)
        }
    }
    return {
        handlePointer: a
    }
}
let Sx = {},
    $5 = n => void(Sx = {
        ...Sx,
        ...n
    });

function e9(n, e) {
    function t(d, {
        args: h = [],
        attach: p,
        ...m
    }, v) {
        let y = `${d[0].toUpperCase()}${d.slice(1)}`,
            A;
        if (d === "primitive") {
            if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
            const x = m.object;
            A = Ql(x, {
                type: d,
                root: v,
                attach: p,
                primitive: !0
            })
        } else {
            const x = Sx[y];
            if (!x) throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(h)) throw new Error("R3F: The args prop must be an array!");
            A = Ql(new x(...h), {
                type: d,
                root: v,
                attach: p,
                memoizedProps: {
                    args: h
                }
            })
        }
        return A.__r3f.attach === void 0 && (A instanceof ut ? A.__r3f.attach = "geometry" : A instanceof wn && (A.__r3f.attach = "material")), y !== "inject" && fv(A, m), A
    }

    function i(d, h) {
        let p = !1;
        if (h) {
            var m, v;
            (m = h.__r3f) != null && m.attach ? cv(d, h, h.__r3f.attach) : h.isObject3D && d.isObject3D && (d.add(h), p = !0), p || (v = d.__r3f) == null || v.objects.push(h), h.__r3f || Ql(h, {}), h.__r3f.parent = d, wx(h), Kl(h)
        }
    }

    function r(d, h, p) {
        let m = !1;
        if (h) {
            var v, y;
            if ((v = h.__r3f) != null && v.attach) cv(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                h.parent = d, h.dispatchEvent({
                    type: "added"
                });
                const A = d.children.filter(_ => _ !== h),
                    x = A.indexOf(p);
                d.children = [...A.slice(0, x), h, ...A.slice(x)], m = !0
            }
            m || (y = d.__r3f) == null || y.objects.push(h), h.__r3f || Ql(h, {}), h.__r3f.parent = d, wx(h), Kl(h)
        }
    }

    function s(d, h, p = !1) {
        d && [...d].forEach(m => o(h, m, p))
    }

    function o(d, h, p) {
        if (h) {
            var m, v, y;
            if (h.__r3f && (h.__r3f.parent = null), (m = d.__r3f) != null && m.objects && (d.__r3f.objects = d.__r3f.objects.filter(M => M !== h)), (v = h.__r3f) != null && v.attach) HE(d, h, h.__r3f.attach);
            else if (h.isObject3D && d.isObject3D) {
                var A;
                d.remove(h), (A = h.__r3f) != null && A.root && Z5(h.__r3f.root, h)
            }
            const _ = (y = h.__r3f) == null ? void 0 : y.primitive,
                S = p === void 0 ? h.dispose !== null && !_ : p;
            if (!_) {
                var x;
                s((x = h.__r3f) == null ? void 0 : x.objects, h, S), s(h.children, h, S)
            }
            h.__r3f && (delete h.__r3f.root, delete h.__r3f.objects, delete h.__r3f.handlers, delete h.__r3f.memoizedProps, _ || delete h.__r3f), S && h.dispose && h.type !== "Scene" && td.unstable_scheduleCallback(td.unstable_IdlePriority, () => {
                try {
                    h.dispose()
                } catch {}
            }), Kl(d)
        }
    }

    function a(d, h, p, m) {
        var v;
        const y = (v = d.__r3f) == null ? void 0 : v.parent;
        if (!y) return;
        const A = t(h, p, d.__r3f.root);
        if (d.children) {
            for (const x of d.children) x.__r3f && i(A, x);
            d.children = d.children.filter(x => !x.__r3f)
        }
        d.__r3f.objects.forEach(x => i(A, x)), d.__r3f.objects = [], d.__r3f.autoRemovedBeforeAppend || o(y, d), A.parent && (A.__r3f.autoRemovedBeforeAppend = !0), i(y, A), A.raycast && A.__r3f.eventCount && A.__r3f.root.getState().internal.interaction.push(A), [m, m.alternate].forEach(x => {
            x !== null && (x.stateNode = A, x.ref && (typeof x.ref == "function" ? x.ref(A) : x.ref.current = A))
        })
    }
    const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
    return {
        reconciler: U5({
            createInstance: t,
            removeChild: o,
            appendChild: i,
            appendInitialChild: i,
            insertBefore: r,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (d, h) => {
                if (!h) return;
                const p = d.getState().scene;
                p.__r3f && (p.__r3f.root = d, i(p, h))
            },
            removeChildFromContainer: (d, h) => {
                h && o(d.getState().scene, h)
            },
            insertInContainerBefore: (d, h, p) => {
                if (!h || !p) return;
                const m = d.getState().scene;
                m.__r3f && r(m, h, p)
            },
            getRootHostContext: () => null,
            getChildHostContext: d => d,
            finalizeInitialChildren(d) {
                var h;
                const p = (h = d == null ? void 0 : d.__r3f) != null ? h : {};
                return Boolean(p.handlers)
            },
            prepareUpdate(d, h, p, m) {
                if (d.__r3f.primitive && m.object && m.object !== d) return [!0]; {
                    const {
                        args: v = [],
                        children: y,
                        ...A
                    } = m, {
                        args: x = [],
                        children: _,
                        ...S
                    } = p;
                    if (!Array.isArray(v)) throw new Error("R3F: the args prop must be an array!");
                    if (v.some((b, B) => b !== x[B])) return [!0];
                    const M = G3(d, A, S, !0);
                    return M.changes.length ? [!1, M] : null
                }
            },
            commitUpdate(d, [h, p], m, v, y, A) {
                h ? a(d, m, y, A) : fv(d, p)
            },
            commitMount(d, h, p, m) {
                var v;
                const y = (v = d.__r3f) != null ? v : {};
                d.raycast && y.handlers && y.eventCount && d.__r3f.root.getState().internal.interaction.push(d)
            },
            getPublicInstance: d => d,
            prepareForCommit: () => null,
            preparePortalMount: d => Ql(d.getState().scene),
            resetAfterCommit: () => {},
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(d) {
                var h;
                const {
                    attach: p,
                    parent: m
                } = (h = d.__r3f) != null ? h : {};
                p && m && HE(m, d, p), d.isObject3D && (d.visible = !1), Kl(d)
            },
            unhideInstance(d, h) {
                var p;
                const {
                    attach: m,
                    parent: v
                } = (p = d.__r3f) != null ? p : {};
                m && v && cv(v, d, m), (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0), Kl(d)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: () => e ? e() : Co.DefaultEventPriority,
            beforeActiveInstanceBlur: () => {},
            afterActiveInstanceBlur: () => {},
            detachDeletedInstance: () => {},
            now: typeof performance < "u" && qt.fun(performance.now) ? performance.now : qt.fun(Date.now) ? Date.now : () => 0,
            scheduleTimeout: qt.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: qt.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: fv
    }
}
const V3 = n => !!(n != null && n.render),
    W3 = U.createContext(null),
    t9 = (n, e) => {
        const t = I3((a, l) => {
                const c = new D,
                    d = new D,
                    h = new D;

                function p(x = l().camera, _ = d, S = l().size) {
                    const {
                        width: M,
                        height: b,
                        top: B,
                        left: R
                    } = S, E = M / b;
                    _ instanceof D ? h.copy(_) : h.set(..._);
                    const P = x.getWorldPosition(c).distanceTo(h);
                    if (k3(x)) return {
                        width: M / x.zoom,
                        height: b / x.zoom,
                        top: B,
                        left: R,
                        factor: 1,
                        distance: P,
                        aspect: E
                    }; {
                        const I = x.fov * Math.PI / 180,
                            z = 2 * Math.tan(I / 2) * P,
                            Z = z * (M / b);
                        return {
                            width: Z,
                            height: z,
                            top: B,
                            left: R,
                            factor: M / Z,
                            distance: P,
                            aspect: E
                        }
                    }
                }
                let m;
                const v = x => a(_ => ({
                        performance: {
                            ..._.performance,
                            current: x
                        }
                    })),
                    y = new me;
                return {
                    set: a,
                    get: l,
                    gl: null,
                    camera: null,
                    raycaster: null,
                    events: {
                        priority: 1,
                        enabled: !0,
                        connected: !1
                    },
                    xr: null,
                    invalidate: (x = 1) => n(l(), x),
                    advance: (x, _) => e(x, _, l()),
                    legacy: !1,
                    linear: !1,
                    flat: !1,
                    scene: Ql(new f_),
                    controls: null,
                    clock: new L_,
                    pointer: y,
                    mouse: y,
                    frameloop: "always",
                    onPointerMissed: void 0,
                    performance: {
                        current: 1,
                        min: .5,
                        max: 1,
                        debounce: 200,
                        regress: () => {
                            const x = l();
                            m && clearTimeout(m), x.performance.current !== x.performance.min && v(x.performance.min), m = setTimeout(() => v(l().performance.max), x.performance.debounce)
                        }
                    },
                    size: {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        updateStyle: !1
                    },
                    viewport: {
                        initialDpr: 0,
                        dpr: 0,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: p
                    },
                    setEvents: x => a(_ => ({
                        ..._,
                        events: {
                            ..._.events,
                            ...x
                        }
                    })),
                    setSize: (x, _, S, M, b) => {
                        const B = l().camera,
                            R = {
                                width: x,
                                height: _,
                                top: M || 0,
                                left: b || 0,
                                updateStyle: S
                            };
                        a(E => ({
                            size: R,
                            viewport: {
                                ...E.viewport,
                                ...p(B, d, R)
                            }
                        }))
                    },
                    setDpr: x => a(_ => {
                        const S = z3(x);
                        return {
                            viewport: {
                                ..._.viewport,
                                dpr: S,
                                initialDpr: _.viewport.initialDpr || S
                            }
                        }
                    }),
                    setFrameloop: (x = "always") => {
                        const _ = l().clock;
                        _.stop(), _.elapsedTime = 0, x !== "never" && (_.start(), _.elapsedTime = 0), a(() => ({
                            frameloop: x
                        }))
                    },
                    previousRoot: void 0,
                    internal: {
                        active: !1,
                        priority: 0,
                        frames: 0,
                        lastEvent: U.createRef(),
                        interaction: [],
                        hovered: new Map,
                        subscribers: [],
                        initialClick: [0, 0],
                        initialHits: [],
                        capturedMap: new Map,
                        subscribe: (x, _, S) => {
                            const M = l().internal;
                            return M.priority = M.priority + (_ > 0 ? 1 : 0), M.subscribers.push({
                                ref: x,
                                priority: _,
                                store: S
                            }), M.subscribers = M.subscribers.sort((b, B) => b.priority - B.priority), () => {
                                const b = l().internal;
                                b != null && b.subscribers && (b.priority = b.priority - (_ > 0 ? 1 : 0), b.subscribers = b.subscribers.filter(B => B.ref !== x))
                            }
                        }
                    }
                }
            }),
            i = t.getState();
        let r = i.size,
            s = i.viewport.dpr,
            o = i.camera;
        return t.subscribe(() => {
            const {
                camera: a,
                size: l,
                viewport: c,
                gl: d,
                set: h
            } = t.getState();
            if (l !== r || c.dpr !== s) {
                var p;
                r = l, s = c.dpr, K5(a, l), d.setPixelRatio(c.dpr);
                const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement;
                d.setSize(l.width, l.height, m)
            }
            a !== o && (o = a, h(m => ({
                viewport: {
                    ...m.viewport,
                    ...m.viewport.getCurrentViewport(a)
                }
            })))
        }), t.subscribe(a => n(a)), t
    };
let Up, n9 = new Set,
    i9 = new Set,
    r9 = new Set;

function dv(n, e) {
    if (n.size)
        for (const {
                callback: t
            } of n.values()) t(e)
}

function Vc(n, e) {
    switch (n) {
        case "before":
            return dv(n9, e);
        case "after":
            return dv(i9, e);
        case "tail":
            return dv(r9, e)
    }
}
let hv, pv;

function mv(n, e, t) {
    let i = e.clock.getDelta();
    for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), hv = e.internal.subscribers, Up = 0; Up < hv.length; Up++) pv = hv[Up], pv.ref.current(pv.store.getState(), i, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames
}

function s9(n) {
    let e = !1,
        t, i, r;

    function s(l) {
        i = requestAnimationFrame(s), e = !0, t = 0, Vc("before", l);
        for (const d of n.values()) {
            var c;
            r = d.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((c = r.gl.xr) != null && c.isPresenting) && (t += mv(l, r))
        }
        if (Vc("after", l), t === 0) return Vc("tail", l), e = !1, cancelAnimationFrame(i)
    }

    function o(l, c = 1) {
        var d;
        if (!l) return n.forEach(h => o(h.store.getState()), c);
        (d = l.gl.xr) != null && d.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + c), e || (e = !0, requestAnimationFrame(s)))
    }

    function a(l, c = !0, d, h) {
        if (c && Vc("before", l), d) mv(l, d, h);
        else
            for (const p of n.values()) mv(l, p.store.getState());
        c && Vc("after", l)
    }
    return {
        loop: s,
        invalidate: o,
        advance: a
    }
}

function j3() {
    const n = U.useContext(W3);
    if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return n
}

function Fi(n = t => t, e) {
    return j3()(n, e)
}

function ec(n, e = 0) {
    const t = j3(),
        i = t.getState().internal.subscribe,
        r = N3(n);
    return Fd(() => i(r, e, t), [e, i, t]), null
}

function J3(n, e) {
    return function(t, ...i) {
        const r = new t;
        return n && n(r), Promise.all(i.map(s => new Promise((o, a) => r.load(s, l => {
            l.scene && Object.assign(l, X5(l.scene)), o(l)
        }, e, l => a(new Error(`Could not load ${s}: ${l.message})`))))))
    }
}

function ea(n, e, t, i) {
    const r = Array.isArray(e) ? e : [e],
        s = z5(J3(t, i), [n, ...r], {
            equal: qt.equ
        });
    return Array.isArray(e) ? s : s[0]
}
ea.preload = function(n, e, t) {
    const i = Array.isArray(e) ? e : [e];
    return G5(J3(t), [n, ...i])
};
ea.clear = function(n, e) {
    const t = Array.isArray(e) ? e : [e];
    return H5([n, ...t])
};
const zu = new Map,
    {
        invalidate: VE,
        advance: WE
    } = s9(zu),
    {
        reconciler: Xm,
        applyProps: Eo
    } = e9(zu, Y5),
    Wc = {
        objects: "shallow",
        strict: !1
    },
    o9 = (n, e) => {
        const t = typeof n == "function" ? n(e) : n;
        return V3(t) ? t : new c_({
            powerPreference: "high-performance",
            canvas: e,
            antialias: !0,
            alpha: !0,
            ...n
        })
    };

function a9(n, e) {
    if (e) return e;
    if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
        const {
            width: t,
            height: i,
            top: r,
            left: s
        } = n.parentElement.getBoundingClientRect();
        return {
            width: t,
            height: i,
            top: r,
            left: s
        }
    } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas) return {
        width: n.width,
        height: n.height,
        top: 0,
        left: 0
    };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}

function l9(n) {
    const e = zu.get(n),
        t = e == null ? void 0 : e.fiber,
        i = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const r = typeof reportError == "function" ? reportError : console.error,
        s = i || t9(VE, WE),
        o = t || Xm.createContainer(s, Co.ConcurrentRoot, null, !1, null, "", r, null);
    e || zu.set(n, {
        fiber: o,
        store: s
    });
    let a, l = !1;
    return {
        configure(c = {}) {
            let {
                gl: d,
                size: h,
                events: p,
                onCreated: m,
                shadows: v = !1,
                linear: y = !1,
                flat: A = !1,
                legacy: x = !1,
                orthographic: _ = !1,
                frameloop: S = "always",
                dpr: M = [1, 2],
                performance: b,
                raycaster: B,
                camera: R,
                onPointerMissed: E
            } = c, P = s.getState(), I = P.gl;
            P.gl || P.set({
                gl: I = o9(d, n)
            });
            let z = P.raycaster;
            z || P.set({
                raycaster: z = new P3
            });
            const {
                params: Z,
                ...W
            } = B || {};
            if (qt.equ(W, z, Wc) || Eo(z, {
                    ...W
                }), qt.equ(Z, z.params, Wc) || Eo(z, {
                    params: {
                        ...z.params,
                        ...Z
                    }
                }), !P.camera) {
                const k = R instanceof yd,
                    V = k ? R : _ ? new Fr(0, 0, 0, 0, .1, 1e3) : new Gt(75, 0, .1, 1e3);
                k || (V.position.z = 5, R && Eo(V, R), R != null && R.rotation || V.lookAt(0, 0, 0)), P.set({
                    camera: V
                })
            }
            if (!P.xr) {
                const k = (ie, j) => {
                        const re = s.getState();
                        re.frameloop !== "never" && WE(ie, !0, re, j)
                    },
                    V = () => {
                        const ie = s.getState();
                        ie.gl.xr.enabled = ie.gl.xr.isPresenting, ie.gl.xr.setAnimationLoop(ie.gl.xr.isPresenting ? k : null), ie.gl.xr.isPresenting || VE(ie)
                    },
                    J = {
                        connect() {
                            const ie = s.getState().gl;
                            ie.xr.addEventListener("sessionstart", V), ie.xr.addEventListener("sessionend", V)
                        },
                        disconnect() {
                            const ie = s.getState().gl;
                            ie.xr.removeEventListener("sessionstart", V), ie.xr.removeEventListener("sessionend", V)
                        }
                    };
                I.xr && J.connect(), P.set({
                    xr: J
                })
            }
            if (I.shadowMap) {
                const k = I.shadowMap.enabled,
                    V = I.shadowMap.type;
                if (I.shadowMap.enabled = !!v, qt.boo(v)) I.shadowMap.type = pf;
                else if (qt.str(v)) {
                    var G;
                    const J = {
                        basic: zB,
                        percentage: Cg,
                        soft: pf,
                        variance: ka
                    };
                    I.shadowMap.type = (G = J[v]) != null ? G : pf
                } else qt.obj(v) && Object.assign(I.shadowMap, v);
                (k !== I.shadowMap.enabled || V !== I.shadowMap.type) && (I.shadowMap.needsUpdate = !0)
            }
            Xl && ("enabled" in Xl ? Xl.enabled = !x : "legacyMode" in Xl && (Xl.legacyMode = x));
            const K = y ? Ws : Ct,
                te = A ? Dr : K1;
            I.outputEncoding !== K && (I.outputEncoding = K), I.toneMapping !== te && (I.toneMapping = te), P.legacy !== x && P.set(() => ({
                legacy: x
            })), P.linear !== y && P.set(() => ({
                linear: y
            })), P.flat !== A && P.set(() => ({
                flat: A
            })), d && !qt.fun(d) && !V3(d) && !qt.equ(d, I, Wc) && Eo(I, d), p && !P.events.handlers && P.set({
                events: p(s)
            });
            const se = a9(n, h);
            return qt.equ(se, P.size, Wc) || P.setSize(se.width, se.height, se.updateStyle, se.top, se.left), M && P.viewport.dpr !== z3(M) && P.setDpr(M), P.frameloop !== S && P.setFrameloop(S), P.onPointerMissed || P.set({
                onPointerMissed: E
            }), b && !qt.equ(b, P.performance, Wc) && P.set(k => ({
                performance: {
                    ...k.performance,
                    ...b
                }
            })), a = m, l = !0, this
        },
        render(c) {
            return l || this.configure(), Xm.updateContainer(U.createElement(u9, {
                store: s,
                children: c,
                onCreated: a,
                rootElement: n
            }), o, null, () => {}), s
        },
        unmount() {
            X3(n)
        }
    }
}

function u9({
    store: n,
    children: e,
    onCreated: t,
    rootElement: i
}) {
    return Fd(() => {
        const r = n.getState();
        r.set(s => ({
            internal: {
                ...s.internal,
                active: !0
            }
        })), t && t(r), n.getState().events.connected || r.events.connect == null || r.events.connect(i)
    }, []), U.createElement(W3.Provider, {
        value: n
    }, e)
}

function X3(n, e) {
    const t = zu.get(n),
        i = t == null ? void 0 : t.fiber;
    if (i) {
        const r = t == null ? void 0 : t.store.getState();
        r && (r.internal.active = !1), Xm.updateContainer(null, i, null, () => {
            r && setTimeout(() => {
                try {
                    var s, o, a, l;
                    r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = r.gl) != null && l.xr && r.xr.disconnect(), Q5(r), zu.delete(n), e && e(n)
                } catch {}
            }, 500)
        })
    }
}
Xm.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: U.version
});

function yr() {
    return yr = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }, yr.apply(this, arguments)
}

function Mx(n, e, t) {
    var i, r, s, o, a;
    e == null && (e = 100);

    function l() {
        var d = Date.now() - o;
        d < e && d >= 0 ? i = setTimeout(l, e - d) : (i = null, t || (a = n.apply(s, r), s = r = null))
    }
    var c = function() {
        s = this, r = arguments, o = Date.now();
        var d = t && !i;
        return i || (i = setTimeout(l, e)), d && (a = n.apply(s, r), s = r = null), a
    };
    return c.clear = function() {
        i && (clearTimeout(i), i = null)
    }, c.flush = function() {
        i && (a = n.apply(s, r), s = r = null, clearTimeout(i), i = null)
    }, c
}
Mx.debounce = Mx;
var jE = Mx;

function c9(n) {
    let {
        debounce: e,
        scroll: t,
        polyfill: i,
        offsetSize: r
    } = n === void 0 ? {
        debounce: 0,
        scroll: !1,
        offsetSize: !1
    } : n;
    const s = i || (typeof window > "u" ? class {} : window.ResizeObserver);
    if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    const [o, a] = U.useState({
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        bottom: 0,
        right: 0,
        x: 0,
        y: 0
    }), l = U.useRef({
        element: null,
        scrollContainers: null,
        resizeObserver: null,
        lastBounds: o
    }), c = e ? typeof e == "number" ? e : e.scroll : null, d = e ? typeof e == "number" ? e : e.resize : null, h = U.useRef(!1);
    U.useEffect(() => (h.current = !0, () => void(h.current = !1)));
    const [p, m, v] = U.useMemo(() => {
        const _ = () => {
            if (!l.current.element) return;
            const {
                left: S,
                top: M,
                width: b,
                height: B,
                bottom: R,
                right: E,
                x: P,
                y: I
            } = l.current.element.getBoundingClientRect(), z = {
                left: S,
                top: M,
                width: b,
                height: B,
                bottom: R,
                right: E,
                x: P,
                y: I
            };
            l.current.element instanceof HTMLElement && r && (z.height = l.current.element.offsetHeight, z.width = l.current.element.offsetWidth), Object.freeze(z), h.current && !p9(l.current.lastBounds, z) && a(l.current.lastBounds = z)
        };
        return [_, d ? jE(_, d) : _, c ? jE(_, c) : _]
    }, [a, r, c, d]);

    function y() {
        l.current.scrollContainers && (l.current.scrollContainers.forEach(_ => _.removeEventListener("scroll", v, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null)
    }

    function A() {
        l.current.element && (l.current.resizeObserver = new s(v), l.current.resizeObserver.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach(_ => _.addEventListener("scroll", v, {
            capture: !0,
            passive: !0
        })))
    }
    const x = _ => {
        !_ || _ === l.current.element || (y(), l.current.element = _, l.current.scrollContainers = Q3(_), A())
    };
    return d9(v, Boolean(t)), f9(m), U.useEffect(() => {
        y(), A()
    }, [t, v, m]), U.useEffect(() => y, []), [x, o, p]
}

function f9(n) {
    U.useEffect(() => {
        const e = n;
        return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e)
    }, [n])
}

function d9(n, e) {
    U.useEffect(() => {
        if (e) {
            const t = n;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }), () => void window.removeEventListener("scroll", t, !0)
        }
    }, [n, e])
}

function Q3(n) {
    const e = [];
    if (!n || n === document.body) return e;
    const {
        overflow: t,
        overflowX: i,
        overflowY: r
    } = window.getComputedStyle(n);
    return [t, i, r].some(s => s === "auto" || s === "scroll") && e.push(n), [...e, ...Q3(n.parentElement)]
}
const h9 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
    p9 = (n, e) => h9.every(t => n[t] === e[t]);
var m9 = Object.defineProperty,
    g9 = Object.defineProperties,
    y9 = Object.getOwnPropertyDescriptors,
    JE = Object.getOwnPropertySymbols,
    v9 = Object.prototype.hasOwnProperty,
    A9 = Object.prototype.propertyIsEnumerable,
    XE = (n, e, t) => e in n ? m9(n, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : n[e] = t,
    QE = (n, e) => {
        for (var t in e || (e = {})) v9.call(e, t) && XE(n, t, e[t]);
        if (JE)
            for (var t of JE(e)) A9.call(e, t) && XE(n, t, e[t]);
        return n
    },
    x9 = (n, e) => g9(n, y9(e));

function K3(n, e, t) {
    if (!n) return;
    if (t(n) === !0) return n;
    let i = e ? n.return : n.child;
    for (; i;) {
        const r = K3(i, e, t);
        if (r) return r;
        i = e ? null : i.sibling
    }
}

function Y3(n) {
    try {
        return Object.defineProperties(n, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return n
    }
}
const N_ = Y3(U.createContext(null));
class Z3 extends U.Component {
    render() {
        return U.createElement(N_.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}
const {
    ReactCurrentOwner: _9,
    ReactCurrentDispatcher: w9
} = U.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function S9() {
    const n = U.useContext(N_);
    if (!n) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = U.useId();
    return U.useMemo(() => {
        var i;
        return (i = _9.current) != null ? i : K3(n, !1, r => {
            let s = r.memoizedState;
            for (; s;) {
                if (s.memoizedState === e) return !0;
                s = s.next
            }
        })
    }, [n, e])
}

function M9() {
    var n, e;
    const t = S9(),
        [i] = U.useState(() => new Map);
    i.clear();
    let r = t;
    for (; r;) {
        const s = (n = r.type) == null ? void 0 : n._context;
        s && s !== N_ && !i.has(s) && i.set(s, (e = w9.current) == null ? void 0 : e.readContext(Y3(s))), r = r.return
    }
    return U.useMemo(() => Array.from(i.keys()).reduce((s, o) => a => U.createElement(s, null, U.createElement(o.Provider, x9(QE({}, a), {
        value: i.get(o)
    }))), s => U.createElement(Z3, QE({}, s))), [i])
}
const gv = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};

function C9(n) {
    const {
        handlePointer: e
    } = q5(n);
    return {
        priority: 1,
        enabled: !0,
        compute(t, i, r) {
            i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera)
        },
        connected: void 0,
        handlers: Object.keys(gv).reduce((t, i) => ({
            ...t,
            [i]: e(i)
        }), {}),
        update: () => {
            var t;
            const {
                events: i,
                internal: r
            } = n.getState();
            (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current)
        },
        connect: t => {
            var i;
            const {
                set: r,
                events: s
            } = n.getState();
            s.disconnect == null || s.disconnect(), r(o => ({
                events: {
                    ...o.events,
                    connected: t
                }
            })), Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
                const [l, c] = gv[o];
                t.addEventListener(l, a, {
                    passive: c
                })
            })
        },
        disconnect: () => {
            const {
                set: t,
                events: i
            } = n.getState();
            if (i.connected) {
                var r;
                Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
                    if (i && i.connected instanceof HTMLElement) {
                        const [a] = gv[s];
                        i.connected.removeEventListener(a, o)
                    }
                }), t(s => ({
                    events: {
                        ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}
const E9 = U.forwardRef(function({
        children: e,
        fallback: t,
        resize: i,
        style: r,
        gl: s,
        events: o = C9,
        eventSource: a,
        eventPrefix: l,
        shadows: c,
        linear: d,
        flat: h,
        legacy: p,
        orthographic: m,
        frameloop: v,
        dpr: y,
        performance: A,
        raycaster: x,
        camera: _,
        onPointerMissed: S,
        onCreated: M,
        ...b
    }, B) {
        U.useMemo(() => $5(Ax), []);
        const R = M9(),
            [E, P] = c9({
                scroll: !0,
                debounce: {
                    scroll: 50,
                    resize: 0
                },
                ...i
            }),
            I = U.useRef(null),
            z = U.useRef(null),
            [Z, W] = U.useState(null);
        U.useImperativeHandle(B, () => I.current);
        const G = N3(S),
            [K, te] = U.useState(!1),
            [se, k] = U.useState(!1);
        if (K) throw K;
        if (se) throw se;
        const V = U.useRef(null);
        P.width > 0 && P.height > 0 && Z && (V.current || (V.current = l9(Z)), V.current.configure({
            gl: s,
            events: o,
            shadows: c,
            linear: d,
            flat: h,
            legacy: p,
            orthographic: m,
            frameloop: v,
            dpr: y,
            performance: A,
            raycaster: x,
            camera: _,
            size: P,
            onPointerMissed: (...ie) => G.current == null ? void 0 : G.current(...ie),
            onCreated: ie => {
                ie.events.connect == null || ie.events.connect(a ? W5(a) ? a.current : a : z.current), l && ie.setEvents({
                    compute: (j, re) => {
                        const ve = j[l + "X"],
                            xe = j[l + "Y"];
                        re.pointer.set(ve / re.size.width * 2 - 1, -(xe / re.size.height) * 2 + 1), re.raycaster.setFromCamera(re.pointer, re.camera)
                    }
                }), M == null || M(ie)
            }
        }), V.current.render(U.createElement(R, null, U.createElement(O3, {
            set: k
        }, U.createElement(U.Suspense, {
            fallback: U.createElement(j5, {
                set: te
            })
        }, e))))), Fd(() => {
            W(I.current)
        }, []), U.useEffect(() => {
            if (Z) return () => X3(Z)
        }, [Z]);
        const J = a ? "none" : "auto";
        return U.createElement("div", yr({
            ref: z,
            style: {
                position: "relative",
                width: "100%",
                height: "100%",
                overflow: "hidden",
                pointerEvents: J,
                ...r
            }
        }, b), U.createElement("div", {
            ref: E,
            style: {
                width: "100%",
                height: "100%"
            }
        }, U.createElement("canvas", {
            ref: I,
            style: {
                display: "block"
            }
        }, t)))
    }),
    O_ = U.forwardRef(function(e, t) {
        return U.createElement(Z3, null, U.createElement(E9, yr({}, e, {
            ref: t
        })))
    }),
    kd = new D,
    U_ = new D,
    b9 = new D;

function T9(n, e, t) {
    const i = kd.setFromMatrixPosition(n.matrixWorld);
    i.project(e);
    const r = t.width / 2,
        s = t.height / 2;
    return [i.x * r + r, -(i.y * s) + s]
}

function B9(n, e) {
    const t = kd.setFromMatrixPosition(n.matrixWorld),
        i = U_.setFromMatrixPosition(e.matrixWorld),
        r = t.sub(i),
        s = e.getWorldDirection(b9);
    return r.angleTo(s) > Math.PI / 2
}

function P9(n, e, t, i) {
    const r = kd.setFromMatrixPosition(n.matrixWorld),
        s = r.clone();
    s.project(e), t.setFromCamera(s, e);
    const o = t.intersectObjects(i, !0);
    if (o.length) {
        const a = o[0].distance;
        return r.distanceTo(t.ray.origin) < a
    }
    return !0
}

function R9(n, e) {
    if (e instanceof Fr) return e.zoom;
    if (e instanceof Gt) {
        const t = kd.setFromMatrixPosition(n.matrixWorld),
            i = U_.setFromMatrixPosition(e.matrixWorld),
            r = e.fov * Math.PI / 180,
            s = t.distanceTo(i);
        return 1 / (2 * Math.tan(r / 2) * s)
    } else return 1
}

function I9(n, e, t) {
    if (e instanceof Gt || e instanceof Fr) {
        const i = kd.setFromMatrixPosition(n.matrixWorld),
            r = U_.setFromMatrixPosition(e.matrixWorld),
            s = i.distanceTo(r),
            o = (t[1] - t[0]) / (e.far - e.near),
            a = t[1] - o * e.far;
        return Math.round(o * s + a)
    }
}
const Cx = n => Math.abs(n) < 1e-10 ? 0 : n;

function q3(n, e, t = "") {
    let i = "matrix3d(";
    for (let r = 0; r !== 16; r++) i += Cx(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
    return t + i
}
const L9 = (n => e => q3(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
    D9 = (n => (e, t) => q3(e, n(t), "translate(-50%,-50%)"))(n => [1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]);

function F9(n) {
    return n && typeof n == "object" && "current" in n
}
const k9 = U.forwardRef(({
    children: n,
    eps: e = .001,
    style: t,
    className: i,
    prepend: r,
    center: s,
    fullscreen: o,
    portal: a,
    distanceFactor: l,
    sprite: c = !1,
    transform: d = !1,
    occlude: h,
    onOcclude: p,
    castShadow: m,
    receiveShadow: v,
    material: y,
    geometry: A,
    zIndexRange: x = [16777271, 0],
    calculatePosition: _ = T9,
    as: S = "div",
    wrapperClass: M,
    pointerEvents: b = "auto",
    ...B
}, R) => {
    const {
        gl: E,
        camera: P,
        scene: I,
        size: z,
        raycaster: Z,
        events: W,
        viewport: G
    } = Fi(), [K] = U.useState(() => document.createElement(S)), te = U.useRef(), se = U.useRef(null), k = U.useRef(0), V = U.useRef([0, 0]), J = U.useRef(null), ie = U.useRef(null), j = (a == null ? void 0 : a.current) || W.connected || E.domElement.parentNode, re = U.useRef(null), ve = U.useRef(!1), xe = U.useMemo(() => h && h !== "blending" || Array.isArray(h) && h.length && F9(h[0]), [h]);
    U.useLayoutEffect(() => {
        const we = E.domElement;
        h && h === "blending" ? (we.style.zIndex = `${Math.floor(x[0]/2)}`, we.style.position = "absolute", we.style.pointerEvents = "none") : (we.style.zIndex = null, we.style.position = null, we.style.pointerEvents = null)
    }, [h]), U.useLayoutEffect(() => {
        if (se.current) {
            const we = te.current = BB(K);
            if (I.updateMatrixWorld(), d) K.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
            else {
                const Le = _(se.current, P, z);
                K.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Le[0]}px,${Le[1]}px,0);transform-origin:0 0;`
            }
            return j && (r ? j.prepend(K) : j.appendChild(K)), () => {
                j && j.removeChild(K), we.unmount()
            }
        }
    }, [j, d]), U.useLayoutEffect(() => {
        M && (K.className = M)
    }, [M]);
    const q = U.useMemo(() => d ? {
            position: "absolute",
            top: 0,
            left: 0,
            width: z.width,
            height: z.height,
            transformStyle: "preserve-3d",
            pointerEvents: "none"
        } : {
            position: "absolute",
            transform: s ? "translate3d(-50%,-50%,0)" : "none",
            ...o && {
                top: -z.height / 2,
                left: -z.width / 2,
                width: z.width,
                height: z.height
            },
            ...t
        }, [t, s, o, z, d]),
        Ne = U.useMemo(() => ({
            position: "absolute",
            pointerEvents: b
        }), [b]);
    U.useLayoutEffect(() => {
        if (ve.current = !1, d) {
            var we;
            (we = te.current) == null || we.render(U.createElement("div", {
                ref: J,
                style: q
            }, U.createElement("div", {
                ref: ie,
                style: Ne
            }, U.createElement("div", {
                ref: R,
                className: i,
                style: t,
                children: n
            }))))
        } else {
            var Le;
            (Le = te.current) == null || Le.render(U.createElement("div", {
                ref: R,
                style: q,
                className: i,
                children: n
            }))
        }
    });
    const Oe = U.useRef(!0);
    ec(we => {
        if (se.current) {
            P.updateMatrixWorld(), se.current.updateWorldMatrix(!0, !1);
            const Le = d ? V.current : _(se.current, P, z);
            if (d || Math.abs(k.current - P.zoom) > e || Math.abs(V.current[0] - Le[0]) > e || Math.abs(V.current[1] - Le[1]) > e) {
                const he = B9(se.current, P);
                let ae = !1;
                xe && (h !== "blending" ? ae = [I] : Array.isArray(h) && (ae = h.map(Ze => Ze.current)));
                const Ce = Oe.current;
                if (ae) {
                    const Ze = P9(se.current, P, Z, ae);
                    Oe.current = Ze && !he
                } else Oe.current = !he;
                Ce !== Oe.current && (p ? p(!Oe.current) : K.style.display = Oe.current ? "block" : "none");
                const ze = Math.floor(x[0] / 2),
                    Pe = h ? xe ? [x[0], ze] : [ze - 1, 0] : x;
                if (K.style.zIndex = `${I9(se.current,P,Pe)}`, d) {
                    const [Ze, Je] = [z.width / 2, z.height / 2], je = P.projectionMatrix.elements[5] * Je, {
                        isOrthographicCamera: vt,
                        top: St,
                        left: O,
                        bottom: L,
                        right: oe
                    } = P, Se = L9(P.matrixWorldInverse), Ee = vt ? `scale(${je})translate(${Cx(-(oe+O)/2)}px,${Cx((St+L)/2)}px)` : `translateZ(${je}px)`;
                    let Be = se.current.matrixWorld;
                    c && (Be = P.matrixWorldInverse.clone().transpose().copyPosition(Be).scale(se.current.scale), Be.elements[3] = Be.elements[7] = Be.elements[11] = 0, Be.elements[15] = 1), K.style.width = z.width + "px", K.style.height = z.height + "px", K.style.perspective = vt ? "" : `${je}px`, J.current && ie.current && (J.current.style.transform = `${Ee}${Se}translate(${Ze}px,${Je}px)`, ie.current.style.transform = D9(Be, 1 / ((l || 10) / 400)))
                } else {
                    const Ze = l === void 0 ? 1 : R9(se.current, P) * l;
                    K.style.transform = `translate3d(${Le[0]}px,${Le[1]}px,0) scale(${Ze})`
                }
                V.current = Le, k.current = P.zoom
            }
        }
        if (!xe && re.current && !ve.current)
            if (d) {
                if (J.current) {
                    const Le = J.current.children[0];
                    if (Le != null && Le.clientWidth && Le != null && Le.clientHeight) {
                        const {
                            isOrthographicCamera: he
                        } = P;
                        if (he || A) B.scale && (Array.isArray(B.scale) ? B.scale instanceof D ? re.current.scale.copy(B.scale.clone().divideScalar(1)) : re.current.scale.set(1 / B.scale[0], 1 / B.scale[1], 1 / B.scale[2]) : re.current.scale.setScalar(1 / B.scale));
                        else {
                            const ae = (l || 10) / 400,
                                Ce = Le.clientWidth * ae,
                                ze = Le.clientHeight * ae;
                            re.current.scale.set(Ce, ze, 1)
                        }
                        ve.current = !0
                    }
                }
            } else {
                const Le = K.children[0];
                if (Le != null && Le.clientWidth && Le != null && Le.clientHeight) {
                    const he = 1 / G.factor,
                        ae = Le.clientWidth * he,
                        Ce = Le.clientHeight * he;
                    re.current.scale.set(ae, Ce, 1), ve.current = !0
                }
                re.current.lookAt(we.camera.position)
            }
    });
    const He = U.useMemo(() => ({
        vertexShader: d ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    }), [d]);
    return U.createElement("group", yr({}, B, {
        ref: se
    }), h && !xe && U.createElement("mesh", {
        castShadow: m,
        receiveShadow: v,
        ref: re
    }, A || U.createElement("planeGeometry", null), y || U.createElement("shaderMaterial", {
        side: Rr,
        vertexShader: He.vertexShader,
        fragmentShader: He.fragmentShader
    })))
});
let jc = 0;
const N9 = I3(n => (fu.onStart = (e, t, i) => {
    n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: (t - jc) / (i - jc) * 100
    })
}, fu.onLoad = () => {
    n({
        active: !1
    })
}, fu.onError = e => n(t => ({
    errors: [...t.errors, e]
})), fu.onProgress = (e, t, i) => {
    t === i && (jc = i), n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: (t - jc) / (i - jc) * 100 || 100
    })
}, {
    errors: [],
    active: !1,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
}));

function z_(n) {
    return function(e) {
        n.forEach(function(t) {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        })
    }
}

function Su(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t, n
}

function KE(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })), t.push.apply(t, i)
    }
    return t
}

function YE(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? KE(Object(t), !0).forEach(function(i) {
            Su(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : KE(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
new me;
new me;

function $3(n, e) {
    if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function")
}
var rr = function n(e, t, i) {
        var r = this;
        $3(this, n), Su(this, "dot2", function(s, o) {
            return r.x * s + r.y * o
        }), Su(this, "dot3", function(s, o, a) {
            return r.x * s + r.y * o + r.z * a
        }), this.x = e, this.y = t, this.z = i
    },
    O9 = [new rr(1, 1, 0), new rr(-1, 1, 0), new rr(1, -1, 0), new rr(-1, -1, 0), new rr(1, 0, 1), new rr(-1, 0, 1), new rr(1, 0, -1), new rr(-1, 0, -1), new rr(0, 1, 1), new rr(0, -1, 1), new rr(0, 1, -1), new rr(0, -1, -1)],
    ZE = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180],
    qE = new Array(512),
    $E = new Array(512),
    U9 = function(e) {
        e > 0 && e < 1 && (e *= 65536), e = Math.floor(e), e < 256 && (e |= e << 8);
        for (var t = 0; t < 256; t++) {
            var i;
            t & 1 ? i = ZE[t] ^ e & 255 : i = ZE[t] ^ e >> 8 & 255, qE[t] = qE[t + 256] = i, $E[t] = $E[t + 256] = O9[i % 12]
        }
    };
U9(0);

function z9(n) {
    if (typeof n == "number") n = Math.abs(n);
    else if (typeof n == "string") {
        var e = n;
        n = 0;
        for (var t = 0; t < e.length; t++) n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647
    }
    return n === 0 && (n = 311), n
}

function eb(n) {
    var e = z9(n);
    return function() {
        var t = e * 48271 % 2147483647;
        return e = t, t / 2147483647
    }
}
var G9 = function n(e) {
        var t = this;
        $3(this, n), Su(this, "seed", 0), Su(this, "init", function(i) {
            t.seed = i, t.value = eb(i)
        }), Su(this, "value", eb(this.seed)), this.init(e)
    },
    H9 = new G9(Math.random()),
    V9 = {
        radius: 1,
        center: [0, 0, 0]
    };

function W9(n, e) {
    for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : H9, i = YE(YE({}, V9), e), r = i.radius, s = i.center, o = 0; o < n.length; o += 3) {
        var a = Math.pow(t.value(), .3333333333333333),
            l = t.value() * 2 - 1,
            c = t.value() * 2 - 1,
            d = t.value() * 2 - 1,
            h = Math.sqrt(l * l + c * c + d * d);
        l = a * l / h, c = a * c / h, d = a * d / h, n[o] = l * r + s[0], n[o + 1] = c * r + s[1], n[o + 2] = d * r + s[2]
    }
    return n
}

function nd(n) {
    return nd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, nd(n)
}

function j9(n, e) {
    if (nd(n) !== "object" || n === null) return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var i = t.call(n, e || "default");
        if (nd(i) !== "object") return i;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}

function J9(n) {
    var e = j9(n, "string");
    return nd(e) === "symbol" ? e : String(e)
}

function lt(n, e, t) {
    return e = J9(e), e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t, n
}
const tb = (n, e) => (n % e + e) % e;
let X9 = class extends as {
    constructor(e, t) {
        super(), lt(this, "object", void 0), lt(this, "domElement", void 0), lt(this, "enabled", !0), lt(this, "target", new D), lt(this, "minDistance", 0), lt(this, "maxDistance", 1 / 0), lt(this, "minZoom", 0), lt(this, "maxZoom", 1 / 0), lt(this, "minPolarAngle", 0), lt(this, "maxPolarAngle", Math.PI), lt(this, "minAzimuthAngle", -1 / 0), lt(this, "maxAzimuthAngle", 1 / 0), lt(this, "enableDamping", !1), lt(this, "dampingFactor", .05), lt(this, "enableZoom", !0), lt(this, "zoomSpeed", 1), lt(this, "enableRotate", !0), lt(this, "rotateSpeed", 1), lt(this, "enablePan", !0), lt(this, "panSpeed", 1), lt(this, "screenSpacePanning", !0), lt(this, "keyPanSpeed", 7), lt(this, "autoRotate", !1), lt(this, "autoRotateSpeed", 2), lt(this, "reverseOrbit", !1), lt(this, "keys", {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        }), lt(this, "mouseButtons", {
            LEFT: Ma.ROTATE,
            MIDDLE: Ma.DOLLY,
            RIGHT: Ma.PAN
        }), lt(this, "touches", {
            ONE: Ca.ROTATE,
            TWO: Ca.DOLLY_PAN
        }), lt(this, "target0", void 0), lt(this, "position0", void 0), lt(this, "zoom0", void 0), lt(this, "_domElementKeyEvents", null), lt(this, "getPolarAngle", void 0), lt(this, "getAzimuthalAngle", void 0), lt(this, "setPolarAngle", void 0), lt(this, "setAzimuthalAngle", void 0), lt(this, "getDistance", void 0), lt(this, "listenToKeyEvents", void 0), lt(this, "saveState", void 0), lt(this, "reset", void 0), lt(this, "update", void 0), lt(this, "connect", void 0), lt(this, "dispose", void 0), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object instanceof Gt ? this.object.zoom : 1, this.getPolarAngle = () => d.phi, this.getAzimuthalAngle = () => d.theta, this.setPolarAngle = H => {
            let ue = tb(H, 2 * Math.PI),
                _e = d.phi;
            _e < 0 && (_e += 2 * Math.PI), ue < 0 && (ue += 2 * Math.PI);
            let Te = Math.abs(ue - _e);
            2 * Math.PI - Te < Te && (ue < _e ? ue += 2 * Math.PI : _e += 2 * Math.PI), h.phi = ue - _e, i.update()
        }, this.setAzimuthalAngle = H => {
            let ue = tb(H, 2 * Math.PI),
                _e = d.theta;
            _e < 0 && (_e += 2 * Math.PI), ue < 0 && (ue += 2 * Math.PI);
            let Te = Math.abs(ue - _e);
            2 * Math.PI - Te < Te && (ue < _e ? ue += 2 * Math.PI : _e += 2 * Math.PI), h.theta = ue - _e, i.update()
        }, this.getDistance = () => i.object.position.distanceTo(i.target), this.listenToKeyEvents = H => {
            H.addEventListener("keydown", oe), this._domElementKeyEvents = H
        }, this.saveState = () => {
            i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object instanceof Gt ? i.object.zoom : 1
        }, this.reset = () => {
            i.target.copy(i.target0), i.object.position.copy(i.position0), i.object instanceof Gt && (i.object.zoom = i.zoom0, i.object.updateProjectionMatrix()), i.dispatchEvent(r), i.update(), l = a.NONE
        }, this.update = (() => {
            const H = new D,
                ue = new Hn().setFromUnitVectors(e.up, new D(0, 1, 0)),
                _e = ue.clone().invert(),
                Te = new D,
                $e = new Hn,
                yt = 2 * Math.PI;
            return function() {
                const Q = i.object.position;
                H.copy(Q).sub(i.target), H.applyQuaternion(ue), d.setFromVector3(H), i.autoRotate && l === a.NONE && Z(I()), i.enableDamping ? (d.theta += h.theta * i.dampingFactor, d.phi += h.phi * i.dampingFactor) : (d.theta += h.theta, d.phi += h.phi);
                let fe = i.minAzimuthAngle,
                    Ae = i.maxAzimuthAngle;
                return isFinite(fe) && isFinite(Ae) && (fe < -Math.PI ? fe += yt : fe > Math.PI && (fe -= yt), Ae < -Math.PI ? Ae += yt : Ae > Math.PI && (Ae -= yt), fe <= Ae ? d.theta = Math.max(fe, Math.min(Ae, d.theta)) : d.theta = d.theta > (fe + Ae) / 2 ? Math.max(fe, d.theta) : Math.min(Ae, d.theta)), d.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, d.phi)), d.makeSafe(), d.radius *= p, d.radius = Math.max(i.minDistance, Math.min(i.maxDistance, d.radius)), i.enableDamping === !0 ? i.target.addScaledVector(m, i.dampingFactor) : i.target.add(m), H.setFromSpherical(d), H.applyQuaternion(_e), Q.copy(i.target).add(H), i.object.lookAt(i.target), i.enableDamping === !0 ? (h.theta *= 1 - i.dampingFactor, h.phi *= 1 - i.dampingFactor, m.multiplyScalar(1 - i.dampingFactor)) : (h.set(0, 0, 0), m.set(0, 0, 0)), p = 1, v || Te.distanceToSquared(i.object.position) > c || 8 * (1 - $e.dot(i.object.quaternion)) > c ? (i.dispatchEvent(r), Te.copy(i.object.position), $e.copy(i.object.quaternion), v = !1, !0) : !1
            }
        })(), this.connect = H => {
            H === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), i.domElement = H, i.domElement.style.touchAction = "none", i.domElement.addEventListener("contextmenu", Be), i.domElement.addEventListener("pointerdown", Ze), i.domElement.addEventListener("pointercancel", vt), i.domElement.addEventListener("wheel", L)
        }, this.dispose = () => {
            var H, ue, _e, Te, $e, yt;
            (H = i.domElement) === null || H === void 0 || H.removeEventListener("contextmenu", Be), (ue = i.domElement) === null || ue === void 0 || ue.removeEventListener("pointerdown", Ze), (_e = i.domElement) === null || _e === void 0 || _e.removeEventListener("pointercancel", vt), (Te = i.domElement) === null || Te === void 0 || Te.removeEventListener("wheel", L), ($e = i.domElement) === null || $e === void 0 || $e.ownerDocument.removeEventListener("pointermove", Je), (yt = i.domElement) === null || yt === void 0 || yt.ownerDocument.removeEventListener("pointerup", je), i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", oe)
        };
        const i = this,
            r = {
                type: "change"
            },
            s = {
                type: "start"
            },
            o = {
                type: "end"
            },
            a = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
        let l = a.NONE;
        const c = 1e-6,
            d = new vx,
            h = new vx;
        let p = 1;
        const m = new D;
        let v = !1;
        const y = new me,
            A = new me,
            x = new me,
            _ = new me,
            S = new me,
            M = new me,
            b = new me,
            B = new me,
            R = new me,
            E = [],
            P = {};

        function I() {
            return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed
        }

        function z() {
            return Math.pow(.95, i.zoomSpeed)
        }

        function Z(H) {
            i.reverseOrbit ? h.theta += H : h.theta -= H
        }

        function W(H) {
            i.reverseOrbit ? h.phi += H : h.phi -= H
        }
        const G = (() => {
                const H = new D;
                return function(_e, Te) {
                    H.setFromMatrixColumn(Te, 0), H.multiplyScalar(-_e), m.add(H)
                }
            })(),
            K = (() => {
                const H = new D;
                return function(_e, Te) {
                    i.screenSpacePanning === !0 ? H.setFromMatrixColumn(Te, 1) : (H.setFromMatrixColumn(Te, 0), H.crossVectors(i.object.up, H)), H.multiplyScalar(_e), m.add(H)
                }
            })(),
            te = (() => {
                const H = new D;
                return function(_e, Te) {
                    const $e = i.domElement;
                    if ($e && i.object instanceof Gt && i.object.isPerspectiveCamera) {
                        const yt = i.object.position;
                        H.copy(yt).sub(i.target);
                        let Vt = H.length();
                        Vt *= Math.tan(i.object.fov / 2 * Math.PI / 180), G(2 * _e * Vt / $e.clientHeight, i.object.matrix), K(2 * Te * Vt / $e.clientHeight, i.object.matrix)
                    } else $e && i.object instanceof Fr && i.object.isOrthographicCamera ? (G(_e * (i.object.right - i.object.left) / i.object.zoom / $e.clientWidth, i.object.matrix), K(Te * (i.object.top - i.object.bottom) / i.object.zoom / $e.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1)
                }
            })();

        function se(H) {
            i.object instanceof Gt && i.object.isPerspectiveCamera ? p /= H : i.object instanceof Fr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * H)), i.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
        }

        function k(H) {
            i.object instanceof Gt && i.object.isPerspectiveCamera ? p *= H : i.object instanceof Fr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / H)), i.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1)
        }

        function V(H) {
            y.set(H.clientX, H.clientY)
        }

        function J(H) {
            b.set(H.clientX, H.clientY)
        }

        function ie(H) {
            _.set(H.clientX, H.clientY)
        }

        function j(H) {
            A.set(H.clientX, H.clientY), x.subVectors(A, y).multiplyScalar(i.rotateSpeed);
            const ue = i.domElement;
            ue && (Z(2 * Math.PI * x.x / ue.clientHeight), W(2 * Math.PI * x.y / ue.clientHeight)), y.copy(A), i.update()
        }

        function re(H) {
            B.set(H.clientX, H.clientY), R.subVectors(B, b), R.y > 0 ? se(z()) : R.y < 0 && k(z()), b.copy(B), i.update()
        }

        function ve(H) {
            S.set(H.clientX, H.clientY), M.subVectors(S, _).multiplyScalar(i.panSpeed), te(M.x, M.y), _.copy(S), i.update()
        }

        function xe(H) {
            H.deltaY < 0 ? k(z()) : H.deltaY > 0 && se(z()), i.update()
        }

        function q(H) {
            let ue = !1;
            switch (H.code) {
                case i.keys.UP:
                    te(0, i.keyPanSpeed), ue = !0;
                    break;
                case i.keys.BOTTOM:
                    te(0, -i.keyPanSpeed), ue = !0;
                    break;
                case i.keys.LEFT:
                    te(i.keyPanSpeed, 0), ue = !0;
                    break;
                case i.keys.RIGHT:
                    te(-i.keyPanSpeed, 0), ue = !0;
                    break
            }
            ue && (H.preventDefault(), i.update())
        }

        function Ne() {
            if (E.length == 1) y.set(E[0].pageX, E[0].pageY);
            else {
                const H = .5 * (E[0].pageX + E[1].pageX),
                    ue = .5 * (E[0].pageY + E[1].pageY);
                y.set(H, ue)
            }
        }

        function Oe() {
            if (E.length == 1) _.set(E[0].pageX, E[0].pageY);
            else {
                const H = .5 * (E[0].pageX + E[1].pageX),
                    ue = .5 * (E[0].pageY + E[1].pageY);
                _.set(H, ue)
            }
        }

        function He() {
            const H = E[0].pageX - E[1].pageX,
                ue = E[0].pageY - E[1].pageY,
                _e = Math.sqrt(H * H + ue * ue);
            b.set(0, _e)
        }

        function we() {
            i.enableZoom && He(), i.enablePan && Oe()
        }

        function Le() {
            i.enableZoom && He(), i.enableRotate && Ne()
        }

        function he(H) {
            if (E.length == 1) A.set(H.pageX, H.pageY);
            else {
                const _e = Xe(H),
                    Te = .5 * (H.pageX + _e.x),
                    $e = .5 * (H.pageY + _e.y);
                A.set(Te, $e)
            }
            x.subVectors(A, y).multiplyScalar(i.rotateSpeed);
            const ue = i.domElement;
            ue && (Z(2 * Math.PI * x.x / ue.clientHeight), W(2 * Math.PI * x.y / ue.clientHeight)), y.copy(A)
        }

        function ae(H) {
            if (E.length == 1) S.set(H.pageX, H.pageY);
            else {
                const ue = Xe(H),
                    _e = .5 * (H.pageX + ue.x),
                    Te = .5 * (H.pageY + ue.y);
                S.set(_e, Te)
            }
            M.subVectors(S, _).multiplyScalar(i.panSpeed), te(M.x, M.y), _.copy(S)
        }

        function Ce(H) {
            const ue = Xe(H),
                _e = H.pageX - ue.x,
                Te = H.pageY - ue.y,
                $e = Math.sqrt(_e * _e + Te * Te);
            B.set(0, $e), R.set(0, Math.pow(B.y / b.y, i.zoomSpeed)), se(R.y), b.copy(B)
        }

        function ze(H) {
            i.enableZoom && Ce(H), i.enablePan && ae(H)
        }

        function Pe(H) {
            i.enableZoom && Ce(H), i.enableRotate && he(H)
        }

        function Ze(H) {
            if (i.enabled !== !1) {
                if (E.length === 0) {
                    var ue, _e;
                    (ue = i.domElement) === null || ue === void 0 || ue.ownerDocument.addEventListener("pointermove", Je), (_e = i.domElement) === null || _e === void 0 || _e.ownerDocument.addEventListener("pointerup", je)
                }
                tt(H), H.pointerType === "touch" ? Se(H) : St(H)
            }
        }

        function Je(H) {
            i.enabled !== !1 && (H.pointerType === "touch" ? Ee(H) : O(H))
        }

        function je(H) {
            if (De(H), E.length === 0) {
                var ue, _e, Te;
                (ue = i.domElement) === null || ue === void 0 || ue.releasePointerCapture(H.pointerId), (_e = i.domElement) === null || _e === void 0 || _e.ownerDocument.removeEventListener("pointermove", Je), (Te = i.domElement) === null || Te === void 0 || Te.ownerDocument.removeEventListener("pointerup", je)
            }
            i.dispatchEvent(o), l = a.NONE
        }

        function vt(H) {
            De(H)
        }

        function St(H) {
            let ue;
            switch (H.button) {
                case 0:
                    ue = i.mouseButtons.LEFT;
                    break;
                case 1:
                    ue = i.mouseButtons.MIDDLE;
                    break;
                case 2:
                    ue = i.mouseButtons.RIGHT;
                    break;
                default:
                    ue = -1
            }
            switch (ue) {
                case Ma.DOLLY:
                    if (i.enableZoom === !1) return;
                    J(H), l = a.DOLLY;
                    break;
                case Ma.ROTATE:
                    if (H.ctrlKey || H.metaKey || H.shiftKey) {
                        if (i.enablePan === !1) return;
                        ie(H), l = a.PAN
                    } else {
                        if (i.enableRotate === !1) return;
                        V(H), l = a.ROTATE
                    }
                    break;
                case Ma.PAN:
                    if (H.ctrlKey || H.metaKey || H.shiftKey) {
                        if (i.enableRotate === !1) return;
                        V(H), l = a.ROTATE
                    } else {
                        if (i.enablePan === !1) return;
                        ie(H), l = a.PAN
                    }
                    break;
                default:
                    l = a.NONE
            }
            l !== a.NONE && i.dispatchEvent(s)
        }

        function O(H) {
            if (i.enabled !== !1) switch (l) {
                case a.ROTATE:
                    if (i.enableRotate === !1) return;
                    j(H);
                    break;
                case a.DOLLY:
                    if (i.enableZoom === !1) return;
                    re(H);
                    break;
                case a.PAN:
                    if (i.enablePan === !1) return;
                    ve(H);
                    break
            }
        }

        function L(H) {
            i.enabled === !1 || i.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (H.preventDefault(), i.dispatchEvent(s), xe(H), i.dispatchEvent(o))
        }

        function oe(H) {
            i.enabled === !1 || i.enablePan === !1 || q(H)
        }

        function Se(H) {
            switch (ge(H), E.length) {
                case 1:
                    switch (i.touches.ONE) {
                        case Ca.ROTATE:
                            if (i.enableRotate === !1) return;
                            Ne(), l = a.TOUCH_ROTATE;
                            break;
                        case Ca.PAN:
                            if (i.enablePan === !1) return;
                            Oe(), l = a.TOUCH_PAN;
                            break;
                        default:
                            l = a.NONE
                    }
                    break;
                case 2:
                    switch (i.touches.TWO) {
                        case Ca.DOLLY_PAN:
                            if (i.enableZoom === !1 && i.enablePan === !1) return;
                            we(), l = a.TOUCH_DOLLY_PAN;
                            break;
                        case Ca.DOLLY_ROTATE:
                            if (i.enableZoom === !1 && i.enableRotate === !1) return;
                            Le(), l = a.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            l = a.NONE
                    }
                    break;
                default:
                    l = a.NONE
            }
            l !== a.NONE && i.dispatchEvent(s)
        }

        function Ee(H) {
            switch (ge(H), l) {
                case a.TOUCH_ROTATE:
                    if (i.enableRotate === !1) return;
                    he(H), i.update();
                    break;
                case a.TOUCH_PAN:
                    if (i.enablePan === !1) return;
                    ae(H), i.update();
                    break;
                case a.TOUCH_DOLLY_PAN:
                    if (i.enableZoom === !1 && i.enablePan === !1) return;
                    ze(H), i.update();
                    break;
                case a.TOUCH_DOLLY_ROTATE:
                    if (i.enableZoom === !1 && i.enableRotate === !1) return;
                    Pe(H), i.update();
                    break;
                default:
                    l = a.NONE
            }
        }

        function Be(H) {
            i.enabled !== !1 && H.preventDefault()
        }

        function tt(H) {
            E.push(H)
        }

        function De(H) {
            delete P[H.pointerId];
            for (let ue = 0; ue < E.length; ue++)
                if (E[ue].pointerId == H.pointerId) {
                    E.splice(ue, 1);
                    return
                }
        }

        function ge(H) {
            let ue = P[H.pointerId];
            ue === void 0 && (ue = new me, P[H.pointerId] = ue), ue.set(H.pageX, H.pageY)
        }

        function Xe(H) {
            const ue = H.pointerId === E[0].pointerId ? E[1] : E[0];
            return P[ue.pointerId]
        }
        t !== void 0 && this.connect(t), this.update()
    }
};
class G_ extends hi {
    constructor(e) {
        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
            return new q9(t)
        }), this.register(function(t) {
            return new sV(t)
        }), this.register(function(t) {
            return new oV(t)
        }), this.register(function(t) {
            return new eV(t)
        }), this.register(function(t) {
            return new tV(t)
        }), this.register(function(t) {
            return new nV(t)
        }), this.register(function(t) {
            return new iV(t)
        }), this.register(function(t) {
            return new Z9(t)
        }), this.register(function(t) {
            return new rV(t)
        }), this.register(function(t) {
            return new $9(t)
        }), this.register(function(t) {
            return new K9(t)
        }), this.register(function(t) {
            return new aV(t)
        })
    }
    load(e, t, i, r) {
        const s = this;
        let o;
        this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ns.extractUrlBase(e), this.manager.itemStart(e);
        const a = function(c) {
                r ? r(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e)
            },
            l = new Gi(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
            try {
                s.parse(c, o, function(d) {
                    t(d), s.manager.itemEnd(e)
                }, a)
            } catch (d) {
                a(d)
            }
        }, i, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e, this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e, this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e, this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    parse(e, t, i, r) {
        let s;
        const o = {},
            a = {};
        if (typeof e == "string") s = e;
        else if (ns.decodeText(new Uint8Array(e, 0, 4)) === eR) {
            try {
                o[At.KHR_BINARY_GLTF] = new lV(e)
            } catch (h) {
                r && r(h);
                return
            }
            s = o[At.KHR_BINARY_GLTF].content
        } else s = ns.decodeText(new Uint8Array(e));
        const l = JSON.parse(s);
        if (l.asset === void 0 || l.asset.version[0] < 2) {
            r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new _V(l, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let d = 0; d < this.pluginCallbacks.length; d++) {
            const h = this.pluginCallbacks[d](c);
            a[h.name] = h, o[h.name] = !0
        }
        if (l.extensionsUsed)
            for (let d = 0; d < l.extensionsUsed.length; ++d) {
                const h = l.extensionsUsed[d],
                    p = l.extensionsRequired || [];
                switch (h) {
                    case At.KHR_MATERIALS_UNLIT:
                        o[h] = new Y9;
                        break;
                    case At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                        o[h] = new fV;
                        break;
                    case At.KHR_DRACO_MESH_COMPRESSION:
                        o[h] = new uV(l, this.dracoLoader);
                        break;
                    case At.KHR_TEXTURE_TRANSFORM:
                        o[h] = new cV;
                        break;
                    case At.KHR_MESH_QUANTIZATION:
                        o[h] = new dV;
                        break;
                    default:
                        p.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
                }
            }
        c.setExtensions(o), c.setPlugins(a), c.parse(i, r)
    }
    parseAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.parse(e, t, r, s)
        })
    }
}

function Q9() {
    let n = {};
    return {
        get: function(e) {
            return n[e]
        },
        add: function(e, t) {
            n[e] = t
        },
        remove: function(e) {
            delete n[e]
        },
        removeAll: function() {
            n = {}
        }
    }
}
const At = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class K9 {
    constructor(e) {
        this.parser = e, this.name = At.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser,
            t = this.parser.json.nodes || [];
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser,
            i = "light:" + e;
        let r = t.cache.get(i);
        if (r) return r;
        const s = t.json,
            l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let c;
        const d = new Ie(16777215);
        l.color !== void 0 && d.fromArray(l.color);
        const h = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
            case "directional":
                c = new R_(d), c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            case "point":
                c = new P_(d), c.distance = h;
                break;
            case "spot":
                c = new B_(d), c.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0), c.decay = 2, l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), r = Promise.resolve(c), t.cache.add(i, r), r
    }
    createNodeAttachment(e) {
        const t = this,
            i = this.parser,
            s = i.json.nodes[e],
            a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return i._getNodeRef(t.cache, a, l)
        })
    }
}
class Y9 {
    constructor() {
        this.name = At.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Ni
    }
    extendParams(e, t, i) {
        const r = [];
        e.color = new Ie(1, 1, 1), e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.fromArray(o), e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, Ct))
        }
        return Promise.all(r)
    }
}
class Z9 {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = r.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve()
    }
}
class q9 {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = r.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new me(a, a)
        }
        return Promise.all(s)
    }
}
class $9 {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = r.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s)
    }
}
class eV {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = [];
        t.sheenColor = new Ie(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
        const o = r.extensions[this.name];
        return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Ct)), o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
    }
}
class tV {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = r.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s)
    }
}
class nV {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = r.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Ie(a[0], a[1], a[2]), Promise.all(s)
    }
}
class iV {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const r = this.parser.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = r.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
    }
}
class rV {
    constructor(e) {
        this.parser = e, this.name = At.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const i = this.parser.json.materials[e];
        return !i.extensions || !i.extensions[this.name] ? null : Ks
    }
    extendMaterialParams(e, t) {
        const i = this.parser,
            r = i.json.materials[e];
        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = r.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Ie(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, Ct)), Promise.all(s)
    }
}
class sV {
    constructor(e) {
        this.parser = e, this.name = At.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser,
            i = t.json,
            r = i.textures[e];
        if (!r.extensions || !r.extensions[this.name]) return null;
        const s = r.extensions[this.name],
            o = t.options.ktx2Loader;
        if (!o) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class oV {
    constructor(e) {
        this.parser = e, this.name = At.EXT_TEXTURE_WEBP, this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name,
            i = this.parser,
            r = i.json,
            s = r.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        const o = s.extensions[t],
            a = r.images[o.source];
        let l = i.textureLoader;
        if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c) return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        })), this.isSupported
    }
}
class aV {
    constructor(e) {
        this.name = At.EXT_MESHOPT_COMPRESSION, this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json,
            i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
            const r = i.extensions[this.name],
                s = this.parser.getDependency("buffer", r.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = r.byteOffset || 0,
                    c = r.byteLength || 0,
                    d = r.count,
                    h = r.byteStride,
                    p = new Uint8Array(a, l, c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(d, h, p, r.mode, r.filter).then(function(m) {
                    return m.buffer
                }) : o.ready.then(function() {
                    const m = new ArrayBuffer(d * h);
                    return o.decodeGltfBuffer(new Uint8Array(m), d, h, p, r.mode, r.filter), m
                })
            })
        } else return null
    }
}
const eR = "glTF",
    Jc = 12,
    nb = {
        JSON: 1313821514,
        BIN: 5130562
    };
class lV {
    constructor(e) {
        this.name = At.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const t = new DataView(e, 0, Jc);
        if (this.header = {
                magic: ns.decodeText(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== eR) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - Jc,
            r = new DataView(e, Jc);
        let s = 0;
        for (; s < i;) {
            const o = r.getUint32(s, !0);
            s += 4;
            const a = r.getUint32(s, !0);
            if (s += 4, a === nb.JSON) {
                const l = new Uint8Array(e, Jc + s, o);
                this.content = ns.decodeText(l)
            } else if (a === nb.BIN) {
                const l = Jc + s;
                this.body = e.slice(l, l + o)
            }
            s += o
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class uV {
    constructor(e, t) {
        if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = At.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const i = this.json,
            r = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
        for (const d in o) {
            const h = bx[d] || d.toLowerCase();
            a[h] = o[d]
        }
        for (const d in e.attributes) {
            const h = bx[d] || d.toLowerCase();
            if (o[d] !== void 0) {
                const p = i.accessors[e.attributes[d]],
                    m = id[p.componentType];
                c[h] = m.name, l[h] = p.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(d) {
            return new Promise(function(h) {
                r.decodeDracoFile(d, function(p) {
                    for (const m in p.attributes) {
                        const v = p.attributes[m],
                            y = l[m];
                        y !== void 0 && (v.normalized = y)
                    }
                    h(p)
                }, a, c)
            })
        })
    }
}
class cV {
    constructor() {
        this.name = At.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
    }
}
class Ex extends qu {
    constructor(e) {
        super(), this.isGLTFSpecularGlossinessMaterial = !0;
        const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`),
            i = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`),
            r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`),
            s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`),
            o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`),
            a = {
                specular: {
                    value: new Ie().setHex(16777215)
                },
                glossiness: {
                    value: 1
                },
                specularMap: {
                    value: null
                },
                glossinessMap: {
                    value: null
                }
            };
        this._extraUniforms = a, this.onBeforeCompile = function(l) {
            for (const c in a) l.uniforms[c] = a[c];
            l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
        }, Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a.specular.value
                },
                set: function(l) {
                    a.specular.value = l
                }
            },
            specularMap: {
                get: function() {
                    return a.specularMap.value
                },
                set: function(l) {
                    a.specularMap.value = l, l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                }
            },
            glossiness: {
                get: function() {
                    return a.glossiness.value
                },
                set: function(l) {
                    a.glossiness.value = l
                }
            },
            glossinessMap: {
                get: function() {
                    return a.glossinessMap.value
                },
                set: function(l) {
                    a.glossinessMap.value = l, l ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                }
            }
        }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
    }
}
class fV {
    constructor() {
        this.name = At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
    }
    getMaterialType() {
        return Ex
    }
    extendParams(e, t, i) {
        const r = t.extensions[this.name];
        e.color = new Ie(1, 1, 1), e.opacity = 1;
        const s = [];
        if (Array.isArray(r.diffuseFactor)) {
            const o = r.diffuseFactor;
            e.color.fromArray(o), e.opacity = o[3]
        }
        if (r.diffuseTexture !== void 0 && s.push(i.assignTexture(e, "map", r.diffuseTexture, Ct)), e.emissive = new Ie(0, 0, 0), e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1, e.specular = new Ie(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), r.specularGlossinessTexture !== void 0) {
            const o = r.specularGlossinessTexture;
            s.push(i.assignTexture(e, "glossinessMap", o)), s.push(i.assignTexture(e, "specularMap", o, Ct))
        }
        return Promise.all(s)
    }
    createMaterial(e) {
        const t = new Ex(e);
        return t.fog = !0, t.color = e.color, t.map = e.map === void 0 ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = e.aoMap === void 0 ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity, t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = e.normalMap === void 0 ? null : e.normalMap, t.normalMapType = Xs, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = e.specularMap === void 0 ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = e.envMap === void 0 ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
    }
}
class dV {
    constructor() {
        this.name = At.KHR_MESH_QUANTIZATION
    }
}
class tR extends $u {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r * 3 + r;
        for (let o = 0; o !== r; o++) t[o] = i[s + o];
        return t
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = a * 2,
            c = a * 3,
            d = r - t,
            h = (i - t) / d,
            p = h * h,
            m = p * h,
            v = e * c,
            y = v - c,
            A = -2 * m + 3 * p,
            x = m - p,
            _ = 1 - A,
            S = x - p + h;
        for (let M = 0; M !== a; M++) {
            const b = o[y + M + a],
                B = o[y + M + l] * d,
                R = o[v + M + a],
                E = o[v + M] * d;
            s[M] = _ * b + S * B + A * R + x * E
        }
        return s
    }
}
const hV = new Hn;
class pV extends tR {
    interpolate_(e, t, i, r) {
        const s = super.interpolate_(e, t, i, r);
        return hV.fromArray(s).normalize().toArray(s), s
    }
}
const Ms = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    },
    id = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    ib = {
        9728: fn,
        9729: en,
        9984: jf,
        9985: bg,
        9986: _u,
        9987: ss
    },
    rb = {
        33071: zn,
        33648: Ru,
        10497: Ho
    },
    sb = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    bx = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    co = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    mV = {
        CUBICSPLINE: void 0,
        LINEAR: il,
        STEP: Lu
    },
    yv = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };

function gV(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new qu({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: rs
    })), n.DefaultMaterial
}

function Xc(n, e, t) {
    for (const i in t.extensions) n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i])
}

function ba(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}

function yV(n, e, t) {
    let i = !1,
        r = !1,
        s = !1;
    for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (h.POSITION !== void 0 && (i = !0), h.NORMAL !== void 0 && (r = !0), h.COLOR_0 !== void 0 && (s = !0), i && r && s) break
    }
    if (!i && !r && !s) return Promise.resolve(n);
    const o = [],
        a = [],
        l = [];
    for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (i) {
            const p = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position;
            o.push(p)
        }
        if (r) {
            const p = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal;
            a.push(p)
        }
        if (s) {
            const p = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color;
            l.push(p)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const d = c[0],
            h = c[1],
            p = c[2];
        return i && (n.morphAttributes.position = d), r && (n.morphAttributes.normal = h), s && (n.morphAttributes.color = p), n.morphTargetsRelative = !0, n
    })
}

function vV(n, e) {
    if (n.updateMorphTargets(), e.weights !== void 0)
        for (let t = 0, i = e.weights.length; t < i; t++) n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, r = t.length; i < r; i++) n.morphTargetDictionary[t[i]] = i
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function AV(n) {
    const e = n.extensions && n.extensions[At.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + ob(e.attributes) : t = n.indices + ":" + ob(n.attributes) + ":" + n.mode, t
}

function ob(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
    return e
}

function Tx(n) {
    switch (n) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function xV(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
class _V {
    constructor(e = {}, t = {}) {
        var i, r;
        this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Q9, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        const s = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
            o = typeof navigator < "u" && ((i = navigator.userAgent) === null || i === void 0 ? void 0 : i.indexOf("Firefox")) > -1,
            a = typeof navigator < "u" && o ? (r = navigator.userAgent) === null || r === void 0 ? void 0 : r.match(/Firefox\/([0-9]+)\./)[1] : -1;
        typeof createImageBitmap > "u" || s || o && a < 98 ? this.textureLoader = new Dd(this.options.manager) : this.textureLoader = new b3(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Gi(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const i = this,
            r = this.json,
            s = this.extensions;
        this.cache.removeAll(), this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }), Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][r.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: r.asset,
                parser: i,
                userData: {}
            };
            Xc(s, a, r), ba(a, r), Promise.all(i._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || [],
            t = this.json.skins || [],
            i = this.json.meshes || [];
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
        }
        for (let r = 0, s = e.length; r < s; r++) {
            const o = e[r];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
    }
    _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1) return i;
        const r = i.clone(),
            s = (o, a) => {
                const l = this.associations.get(o);
                l != null && this.associations.set(a, l);
                for (const [c, d] of o.children.entries()) s(d, a.children[c])
            };
        return s(i, r), r.name += "_instance_" + e.uses[t]++, r
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            if (r) return r
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let r = 0; r < t.length; r++) {
            const s = e(t[r]);
            s && i.push(s)
        }
        return i
    }
    getDependency(e, t) {
        const i = e + ":" + t;
        let r = this.cache.get(i);
        if (!r) {
            switch (e) {
                case "scene":
                    r = this.loadScene(t);
                    break;
                case "node":
                    r = this.loadNode(t);
                    break;
                case "mesh":
                    r = this._invokeOne(function(s) {
                        return s.loadMesh && s.loadMesh(t)
                    });
                    break;
                case "accessor":
                    r = this.loadAccessor(t);
                    break;
                case "bufferView":
                    r = this._invokeOne(function(s) {
                        return s.loadBufferView && s.loadBufferView(t)
                    });
                    break;
                case "buffer":
                    r = this.loadBuffer(t);
                    break;
                case "material":
                    r = this._invokeOne(function(s) {
                        return s.loadMaterial && s.loadMaterial(t)
                    });
                    break;
                case "texture":
                    r = this._invokeOne(function(s) {
                        return s.loadTexture && s.loadTexture(t)
                    });
                    break;
                case "skin":
                    r = this.loadSkin(t);
                    break;
                case "animation":
                    r = this._invokeOne(function(s) {
                        return s.loadAnimation && s.loadAnimation(t)
                    });
                    break;
                case "camera":
                    r = this.loadCamera(t);
                    break;
                default:
                    throw new Error("Unknown type: " + e)
            }
            this.cache.add(i, r)
        }
        return r
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const i = this,
                r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(r.map(function(s, o) {
                return i.getDependency(e, o)
            })), this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e],
            i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[At.KHR_BINARY_GLTF].body);
        const r = this.options;
        return new Promise(function(s, o) {
            i.load(ns.resolveURL(t.uri, r.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        })
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(i) {
            const r = t.byteLength || 0,
                s = t.byteOffset || 0;
            return i.slice(s, s + r)
        })
    }
    loadAccessor(e) {
        const t = this,
            i = this.json,
            r = this.json.accessors[e];
        if (r.bufferView === void 0 && r.sparse === void 0) return Promise.resolve(null);
        const s = [];
        return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function(o) {
            const a = o[0],
                l = sb[r.type],
                c = id[r.componentType],
                d = c.BYTES_PER_ELEMENT,
                h = d * l,
                p = r.byteOffset || 0,
                m = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0,
                v = r.normalized === !0;
            let y, A;
            if (m && m !== h) {
                const x = Math.floor(p / m),
                    _ = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + x + ":" + r.count;
                let S = t.cache.get(_);
                S || (y = new c(a, x * m, r.count * m / d), S = new Ad(y, m / d), t.cache.add(_, S)), A = new Vo(S, l, p % m / d, v)
            } else a === null ? y = new c(r.count * l) : y = new c(a, p, r.count * l), A = new Dt(y, l, v);
            if (r.sparse !== void 0) {
                const x = sb.SCALAR,
                    _ = id[r.sparse.indices.componentType],
                    S = r.sparse.indices.byteOffset || 0,
                    M = r.sparse.values.byteOffset || 0,
                    b = new _(o[1], S, r.sparse.count * x),
                    B = new c(o[2], M, r.sparse.count * l);
                a !== null && (A = new Dt(A.array.slice(), A.itemSize, A.normalized));
                for (let R = 0, E = b.length; R < E; R++) {
                    const P = b[R];
                    if (A.setX(P, B[R * l]), l >= 2 && A.setY(P, B[R * l + 1]), l >= 3 && A.setZ(P, B[R * l + 2]), l >= 4 && A.setW(P, B[R * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return A
        })
    }
    loadTexture(e) {
        const t = this.json,
            i = this.options,
            s = t.textures[e].source,
            o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = i.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, i) {
        const r = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const c = this.loadImageSource(t, i).then(function(d) {
            d.flipY = !1, o.name && (d.name = o.name);
            const p = (s.samplers || {})[o.sampler] || {};
            return d.magFilter = ib[p.magFilter] || en, d.minFilter = ib[p.minFilter] || ss, d.wrapS = rb[p.wrapS] || Ho, d.wrapT = rb[p.wrapT] || Ho, r.associations.set(d, {
                textures: e
            }), d
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c, c
    }
    loadImageSource(e, t) {
        const i = this,
            r = this.json,
            s = this.options;
        if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(h => h.clone());
        const o = r.images[e],
            a = self.URL || self.webkitURL;
        let l = o.uri || "",
            c = !1;
        if (o.bufferView !== void 0) l = i.getDependency("bufferView", o.bufferView).then(function(h) {
            c = !0;
            const p = new Blob([h], {
                type: o.mimeType
            });
            return l = a.createObjectURL(p), l
        });
        else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const d = Promise.resolve(l).then(function(h) {
            return new Promise(function(p, m) {
                let v = p;
                t.isImageBitmapLoader === !0 && (v = function(y) {
                    const A = new Yt(y);
                    A.needsUpdate = !0, p(A)
                }), t.load(ns.resolveURL(h, s.path), v, void 0, m)
            })
        }).then(function(h) {
            return c === !0 && a.revokeObjectURL(l), h.userData.mimeType = o.mimeType || xV(o.uri), h
        }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h
        });
        return this.sourceCache[e] = d, d
    }
    assignTexture(e, t, i, r) {
        const s = this;
        return this.getDependency("texture", i.index).then(function(o) {
            if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), s.extensions[At.KHR_TEXTURE_TRANSFORM]) {
                const a = i.extensions !== void 0 ? i.extensions[At.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[At.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l)
                }
            }
            return r !== void 0 && (o.encoding = r), e[t] = o, o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const r = t.attributes.tangent === void 0,
            s = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new _d, wn.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l || (l = new ei, wn.prototype.copy.call(l, i), l.color.copy(i.color), this.cache.add(a, l)), i = l
        }
        if (r || s || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"), r && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = i.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l
        }
        i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = i
    }
    getMaterialType() {
        return qu
    }
    loadMaterial(e) {
        const t = this,
            i = this.json,
            r = this.extensions,
            s = i.materials[e];
        let o;
        const a = {},
            l = s.extensions || {},
            c = [];
        if (l[At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const h = r[At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            o = h.getMaterialType(), c.push(h.extendParams(a, s, t))
        } else if (l[At.KHR_MATERIALS_UNLIT]) {
            const h = r[At.KHR_MATERIALS_UNLIT];
            o = h.getMaterialType(), c.push(h.extendParams(a, s, t))
        } else {
            const h = s.pbrMetallicRoughness || {};
            if (a.color = new Ie(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
                const p = h.baseColorFactor;
                a.color.fromArray(p), a.opacity = p[3]
            }
            h.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", h.baseColorTexture, Ct)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(p) {
                return p.getMaterialType && p.getMaterialType(e)
            }), c.push(Promise.all(this._invokeAll(function(p) {
                return p.extendMaterialParams && p.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = Rr);
        const d = s.alphaMode || yv.OPAQUE;
        if (d === yv.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, d === yv.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== Ni && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new me(1, 1), s.normalTexture.scale !== void 0)) {
            const h = s.normalTexture.scale;
            a.normalScale.set(h, h)
        }
        return s.occlusionTexture !== void 0 && o !== Ni && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== Ni && (a.emissive = new Ie().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== Ni && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Ct)), Promise.all(c).then(function() {
            let h;
            return o === Ex ? h = r[At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : h = new o(a), s.name && (h.name = s.name), ba(h, s), t.associations.set(h, {
                materials: e
            }), s.extensions && Xc(r, h, s), h
        })
    }
    createUniqueName(e) {
        const t = bt.sanitizeNodeName(e || "");
        let i = t;
        for (let r = 1; this.nodeNamesUsed[i]; ++r) i = t + "_" + r;
        return this.nodeNamesUsed[i] = !0, i
    }
    loadGeometries(e) {
        const t = this,
            i = this.extensions,
            r = this.primitiveCache;

        function s(a) {
            return i[At.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return ab(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                d = AV(c),
                h = r[d];
            if (h) o.push(h.promise);
            else {
                let p;
                c.extensions && c.extensions[At.KHR_DRACO_MESH_COMPRESSION] ? p = s(c) : p = ab(new ut, c, t), r[d] = {
                    primitive: c,
                    promise: p
                }, o.push(p)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this,
            i = this.json,
            r = this.extensions,
            s = i.meshes[e],
            o = s.primitives,
            a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const d = o[l].material === void 0 ? gV(this.cache) : this.getDependency("material", o[l].material);
            a.push(d)
        }
        return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1),
                d = l[l.length - 1],
                h = [];
            for (let m = 0, v = d.length; m < v; m++) {
                const y = d[m],
                    A = o[m];
                let x;
                const _ = c[m];
                if (A.mode === Ms.TRIANGLES || A.mode === Ms.TRIANGLE_STRIP || A.mode === Ms.TRIANGLE_FAN || A.mode === void 0) x = s.isSkinnedMesh === !0 ? new h_(y, _) : new bn(y, _), x.isSkinnedMesh === !0 && !x.geometry.attributes.skinWeight.normalized && x.normalizeSkinWeights(), A.mode === Ms.TRIANGLE_STRIP ? x.geometry = lb(x.geometry, PP) : A.mode === Ms.TRIANGLE_FAN && (x.geometry = lb(x.geometry, q1));
                else if (A.mode === Ms.LINES) x = new Or(y, _);
                else if (A.mode === Ms.LINE_STRIP) x = new js(y, _);
                else if (A.mode === Ms.LINE_LOOP) x = new p_(y, _);
                else if (A.mode === Ms.POINTS) x = new m_(y, _);
                else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
                Object.keys(x.geometry.morphAttributes).length > 0 && vV(x, s), x.name = t.createUniqueName(s.name || "mesh_" + e), ba(x, s), A.extensions && Xc(r, x, A), t.assignFinalMaterial(x), h.push(x)
            }
            for (let m = 0, v = h.length; m < v; m++) t.associations.set(h[m], {
                meshes: e,
                primitives: m
            });
            if (h.length === 1) return h[0];
            const p = new Ls;
            t.associations.set(p, {
                meshes: e
            });
            for (let m = 0, v = h.length; m < v; m++) p.add(h[m]);
            return p
        })
    }
    loadCamera(e) {
        let t;
        const i = this.json.cameras[e],
            r = i[i.type];
        if (!r) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return i.type === "perspective" ? t = new Gt(e_.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : i.type === "orthographic" && (t = new Fr(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), ba(t, i), Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e],
            i = {
                joints: t.joints
            };
        return t.inverseBindMatrices === void 0 ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then(function(r) {
            return i.inverseBindMatrices = r, i
        })
    }
    loadAnimation(e) {
        const i = this.json.animations[e],
            r = [],
            s = [],
            o = [],
            a = [],
            l = [];
        for (let c = 0, d = i.channels.length; c < d; c++) {
            const h = i.channels[c],
                p = i.samplers[h.sampler],
                m = h.target,
                v = m.node,
                y = i.parameters !== void 0 ? i.parameters[p.input] : p.input,
                A = i.parameters !== void 0 ? i.parameters[p.output] : p.output;
            r.push(this.getDependency("node", v)), s.push(this.getDependency("accessor", y)), o.push(this.getDependency("accessor", A)), a.push(p), l.push(m)
        }
        return Promise.all([Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
            const d = c[0],
                h = c[1],
                p = c[2],
                m = c[3],
                v = c[4],
                y = [];
            for (let x = 0, _ = d.length; x < _; x++) {
                const S = d[x],
                    M = h[x],
                    b = p[x],
                    B = m[x],
                    R = v[x];
                if (S === void 0) continue;
                S.updateMatrix();
                let E;
                switch (co[R.path]) {
                    case co.weights:
                        E = Nu;
                        break;
                    case co.rotation:
                        E = Wo;
                        break;
                    case co.position:
                    case co.scale:
                    default:
                        E = Ou;
                        break
                }
                const P = S.name ? S.name : S.uuid,
                    I = B.interpolation !== void 0 ? mV[B.interpolation] : il,
                    z = [];
                co[R.path] === co.weights ? S.traverse(function(W) {
                    W.morphTargetInfluences && z.push(W.name ? W.name : W.uuid)
                }) : z.push(P);
                let Z = b.array;
                if (b.normalized) {
                    const W = Tx(Z.constructor),
                        G = new Float32Array(Z.length);
                    for (let K = 0, te = Z.length; K < te; K++) G[K] = Z[K] * W;
                    Z = G
                }
                for (let W = 0, G = z.length; W < G; W++) {
                    const K = new E(z[W] + "." + co[R.path], M.array, Z, I);
                    B.interpolation === "CUBICSPLINE" && (K.createInterpolant = function(se) {
                        const k = this instanceof Wo ? pV : tR;
                        return new k(this.times, this.values, this.getValueSize() / 3, se)
                    }, K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(K)
                }
            }
            const A = i.name ? i.name : "animation_" + e;
            return new Uu(A, void 0, y)
        })
    }
    createNodeMesh(e) {
        const t = this.json,
            i = this,
            r = t.nodes[e];
        return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function(s) {
            const o = i._getNodeRef(i.meshCache, r.mesh, s);
            return r.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = r.weights.length; l < c; l++) a.morphTargetInfluences[l] = r.weights[l]
            }), o
        })
    }
    loadNode(e) {
        const t = this.json,
            i = this.extensions,
            r = this,
            s = t.nodes[e],
            o = s.name ? r.createUniqueName(s.name) : "";
        return function() {
            const a = [],
                l = r._invokeOne(function(c) {
                    return c.createNodeMesh && c.createNodeMesh(e)
                });
            return l && a.push(l), s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function(c) {
                return r._getNodeRef(r.cameraCache, s.camera, c)
            })), r._invokeAll(function(c) {
                return c.createNodeAttachment && c.createNodeAttachment(e)
            }).forEach(function(c) {
                a.push(c)
            }), Promise.all(a)
        }().then(function(a) {
            let l;
            if (s.isBone === !0 ? l = new Dg : a.length > 1 ? l = new Ls : a.length === 1 ? l = a[0] : l = new Tt, l !== a[0])
                for (let c = 0, d = a.length; c < d; c++) l.add(a[c]);
            if (s.name && (l.userData.name = s.name, l.name = o), ba(l, s), s.extensions && Xc(i, l, s), s.matrix !== void 0) {
                const c = new rt;
                c.fromArray(s.matrix), l.applyMatrix4(c)
            } else s.translation !== void 0 && l.position.fromArray(s.translation), s.rotation !== void 0 && l.quaternion.fromArray(s.rotation), s.scale !== void 0 && l.scale.fromArray(s.scale);
            return r.associations.has(l) || r.associations.set(l, {}), r.associations.get(l).nodes = e, l
        })
    }
    loadScene(e) {
        const t = this.json,
            i = this.extensions,
            r = this.json.scenes[e],
            s = this,
            o = new Ls;
        r.name && (o.name = s.createUniqueName(r.name)), ba(o, r), r.extensions && Xc(i, o, r);
        const a = r.nodes || [],
            l = [];
        for (let c = 0, d = a.length; c < d; c++) l.push(nR(a[c], o, t, s));
        return Promise.all(l).then(function() {
            const c = d => {
                const h = new Map;
                for (const [p, m] of s.associations)(p instanceof wn || p instanceof Yt) && h.set(p, m);
                return d.traverse(p => {
                    const m = s.associations.get(p);
                    m != null && h.set(p, m)
                }), h
            };
            return s.associations = c(o), o
        })
    }
}

function nR(n, e, t, i) {
    const r = t.nodes[n];
    return i.getDependency("node", n).then(function(s) {
        if (r.skin === void 0) return s;
        let o;
        return i.getDependency("skin", r.skin).then(function(a) {
            o = a;
            const l = [];
            for (let c = 0, d = o.joints.length; c < d; c++) l.push(i.getDependency("node", o.joints[c]));
            return Promise.all(l)
        }).then(function(a) {
            return s.traverse(function(l) {
                if (!l.isMesh) return;
                const c = [],
                    d = [];
                for (let h = 0, p = a.length; h < p; h++) {
                    const m = a[h];
                    if (m) {
                        c.push(m);
                        const v = new rt;
                        o.inverseBindMatrices !== void 0 && v.fromArray(o.inverseBindMatrices.array, h * 16), d.push(v)
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[h])
                }
                l.bind(new xd(c, d), l.matrixWorld)
            }), s
        })
    }).then(function(s) {
        e.add(s);
        const o = [];
        if (r.children) {
            const a = r.children;
            for (let l = 0, c = a.length; l < c; l++) {
                const d = a[l];
                o.push(nR(d, s, t, i))
            }
        }
        return Promise.all(o)
    })
}

function wV(n, e, t) {
    const i = e.attributes,
        r = new Yo;
    if (i.POSITION !== void 0) {
        const a = t.json.accessors[i.POSITION],
            l = a.min,
            c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (r.set(new D(l[0], l[1], l[2]), new D(c[0], c[1], c[2])), a.normalized) {
                const d = Tx(id[a.componentType]);
                r.min.multiplyScalar(d), r.max.multiplyScalar(d)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new D,
            l = new D;
        for (let c = 0, d = s.length; c < d; c++) {
            const h = s[c];
            if (h.POSITION !== void 0) {
                const p = t.json.accessors[h.POSITION],
                    m = p.min,
                    v = p.max;
                if (m !== void 0 && v !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))), p.normalized) {
                        const y = Tx(id[p.componentType]);
                        l.multiplyScalar(y)
                    }
                    a.max(l)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        r.expandByVector(a)
    }
    n.boundingBox = r;
    const o = new Zo;
    r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, n.boundingSphere = o
}

function ab(n, e, t) {
    const i = e.attributes,
        r = [];

    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in i) {
        const a = bx[o] || o.toLowerCase();
        a in n.attributes || r.push(s(i[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            n.setIndex(a)
        });
        r.push(o)
    }
    return ba(n, e), wV(n, e, t), Promise.all(r).then(function() {
        return e.targets !== void 0 ? yV(n, e.targets, t) : n
    })
}

function lb(n, e) {
    let t = n.getIndex();
    if (t === null) {
        const o = [],
            a = n.getAttribute("position");
        if (a !== void 0) {
            for (let l = 0; l < a.count; l++) o.push(l);
            n.setIndex(o), t = n.getIndex()
        } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n
    }
    const i = t.count - 2,
        r = [];
    if (e === q1)
        for (let o = 1; o <= i; o++) r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
    else
        for (let o = 0; o < i; o++) o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
    r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = n.clone();
    return s.setIndex(r), s
}
class SV extends ut {
    constructor(e, t, i, r) {
        super();
        const s = [],
            o = [],
            a = [],
            l = new D,
            c = new rt;
        c.makeRotationFromEuler(i), c.setPosition(t);
        const d = new rt;
        d.copy(c).invert(), h(), this.setAttribute("position", new We(s, 3)), this.setAttribute("normal", new We(o, 3)), this.setAttribute("uv", new We(a, 2));

        function h() {
            let y, A = [];
            const x = new D,
                _ = new D;
            if (e.geometry.isGeometry === !0) {
                console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.");
                return
            }
            const S = e.geometry,
                M = S.attributes.position,
                b = S.attributes.normal;
            if (S.index !== null) {
                const B = S.index;
                for (y = 0; y < B.count; y++) x.fromBufferAttribute(M, B.getX(y)), _.fromBufferAttribute(b, B.getX(y)), p(A, x, _)
            } else
                for (y = 0; y < M.count; y++) x.fromBufferAttribute(M, y), _.fromBufferAttribute(b, y), p(A, x, _);
            for (A = m(A, l.set(1, 0, 0)), A = m(A, l.set(-1, 0, 0)), A = m(A, l.set(0, 1, 0)), A = m(A, l.set(0, -1, 0)), A = m(A, l.set(0, 0, 1)), A = m(A, l.set(0, 0, -1)), y = 0; y < A.length; y++) {
                const B = A[y];
                a.push(.5 + B.position.x / r.x, .5 + B.position.y / r.y), B.position.applyMatrix4(c), s.push(B.position.x, B.position.y, B.position.z), o.push(B.normal.x, B.normal.y, B.normal.z)
            }
        }

        function p(y, A, x) {
            A.applyMatrix4(e.matrixWorld), A.applyMatrix4(d), x.transformDirection(e.matrixWorld), y.push(new ub(A.clone(), x.clone()))
        }

        function m(y, A) {
            const x = [],
                _ = .5 * Math.abs(r.dot(A));
            for (let S = 0; S < y.length; S += 3) {
                let M, b, B, R = 0,
                    E, P, I, z;
                const Z = y[S + 0].position.dot(A) - _,
                    W = y[S + 1].position.dot(A) - _,
                    G = y[S + 2].position.dot(A) - _;
                switch (M = Z > 0, b = W > 0, B = G > 0, R = (M ? 1 : 0) + (b ? 1 : 0) + (B ? 1 : 0), R) {
                    case 0: {
                        x.push(y[S]), x.push(y[S + 1]), x.push(y[S + 2]);
                        break
                    }
                    case 1: {
                        if (M && (E = y[S + 1], P = y[S + 2], I = v(y[S], E, A, _), z = v(y[S], P, A, _)), b) {
                            E = y[S], P = y[S + 2], I = v(y[S + 1], E, A, _), z = v(y[S + 1], P, A, _), x.push(I), x.push(P.clone()), x.push(E.clone()), x.push(P.clone()), x.push(I.clone()), x.push(z);
                            break
                        }
                        B && (E = y[S], P = y[S + 1], I = v(y[S + 2], E, A, _), z = v(y[S + 2], P, A, _)), x.push(E.clone()), x.push(P.clone()), x.push(I), x.push(z), x.push(I.clone()), x.push(P.clone());
                        break
                    }
                    case 2: {
                        M || (E = y[S].clone(), P = v(E, y[S + 1], A, _), I = v(E, y[S + 2], A, _), x.push(E), x.push(P), x.push(I)), b || (E = y[S + 1].clone(), P = v(E, y[S + 2], A, _), I = v(E, y[S], A, _), x.push(E), x.push(P), x.push(I)), B || (E = y[S + 2].clone(), P = v(E, y[S], A, _), I = v(E, y[S + 1], A, _), x.push(E), x.push(P), x.push(I));
                        break
                    }
                }
            }
            return x
        }

        function v(y, A, x, _) {
            const S = y.position.dot(x) - _,
                M = A.position.dot(x) - _,
                b = S / (S - M);
            return new ub(new D(y.position.x + b * (A.position.x - y.position.x), y.position.y + b * (A.position.y - y.position.y), y.position.z + b * (A.position.z - y.position.z)), new D(y.normal.x + b * (A.normal.x - y.normal.x), y.normal.y + b * (A.normal.y - y.normal.y), y.normal.z + b * (A.normal.z - y.normal.z)))
        }
    }
}
class ub {
    constructor(e, t) {
        this.position = e, this.normal = t
    }
    clone() {
        return new this.constructor(this.position.clone(), this.normal.clone())
    }
}
const vv = new WeakMap;
class MV extends hi {
    constructor(e) {
        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e, this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e, this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e, this
    }
    load(e, t, i, r) {
        const s = new Gi(this.manager);
        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => {
            const a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(t).catch(r)
        }, i, r)
    }
    decodeDracoFile(e, t, i, r) {
        const s = {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: r || this.defaultAttributeTypes,
            useUniqueIDs: !!i
        };
        this.decodeGeometry(e, s).then(t)
    }
    decodeGeometry(e, t) {
        for (const l in t.attributeTypes) {
            const c = t.attributeTypes[l];
            c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name)
        }
        const i = JSON.stringify(t);
        if (vv.has(e)) {
            const l = vv.get(e);
            if (l.key === i) return l.promise;
            if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let r;
        const s = this.workerNextTaskID++,
            o = e.byteLength,
            a = this._getWorker(s, o).then(l => (r = l, new Promise((c, d) => {
                r._callbacks[s] = {
                    resolve: c,
                    reject: d
                }, r.postMessage({
                    type: "decode",
                    id: s,
                    taskConfig: t,
                    buffer: e
                }, [e])
            }))).then(l => this._createGeometry(l.geometry));
        return a.catch(() => !0).then(() => {
            r && s && this._releaseTask(r, s)
        }), vv.set(e, {
            key: i,
            promise: a
        }), a
    }
    _createGeometry(e) {
        const t = new ut;
        e.index && t.setIndex(new Dt(e.index.array, 1));
        for (let i = 0; i < e.attributes.length; i++) {
            const r = e.attributes[i],
                s = r.name,
                o = r.array,
                a = r.itemSize;
            t.setAttribute(s, new Dt(o, a))
        }
        return t
    }
    _loadLibrary(e, t) {
        const i = new Gi(this.manager);
        return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((r, s) => {
            i.load(e, r, void 0, s)
        })
    }
    preload() {
        return this._initDecoder(), this
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
            t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(i => {
            const r = i[0];
            e || (this.decoderConfig.wasmBinary = i[1]);
            const s = CV.toString(),
                o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }), this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
                const r = new Worker(this.workerSourceURL);
                r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), r.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                        case "decode":
                            r._callbacks[o.id].resolve(o);
                            break;
                        case "error":
                            r._callbacks[o.id].reject(o);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }, this.workerPool.push(r)
            } else this.workerPool.sort(function(r, s) {
                return r._taskLoad > s._taskLoad ? -1 : 1
            });
            const i = this.workerPool[this.workerPool.length - 1];
            return i._taskCosts[e] = t, i._taskLoad += t, i
        })
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
        return this.workerPool.length = 0, this
    }
}

function CV() {
    let n, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
            case "init":
                n = a.decoderConfig, e = new Promise(function(d) {
                    n.onModuleLoaded = function(h) {
                        d({
                            draco: h
                        })
                    }, DracoDecoderModule(n)
                });
                break;
            case "decode":
                const l = a.buffer,
                    c = a.taskConfig;
                e.then(d => {
                    const h = d.draco,
                        p = new h.Decoder,
                        m = new h.DecoderBuffer;
                    m.Init(new Int8Array(l), l.byteLength);
                    try {
                        const v = t(h, p, m, c),
                            y = v.attributes.map(A => A.array.buffer);
                        v.index && y.push(v.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: a.id,
                            geometry: v
                        }, y)
                    } catch (v) {
                        console.error(v), self.postMessage({
                            type: "error",
                            id: a.id,
                            error: v.message
                        })
                    } finally {
                        h.destroy(m), h.destroy(p)
                    }
                });
                break
        }
    };

    function t(o, a, l, c) {
        const d = c.attributeIDs,
            h = c.attributeTypes;
        let p, m;
        const v = a.GetEncodedGeometryType(l);
        if (v === o.TRIANGULAR_MESH) p = new o.Mesh, m = a.DecodeBufferToMesh(l, p);
        else if (v === o.POINT_CLOUD) p = new o.PointCloud, m = a.DecodeBufferToPointCloud(l, p);
        else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!m.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
        const y = {
            index: null,
            attributes: []
        };
        for (const A in d) {
            const x = self[h[A]];
            let _, S;
            if (c.useUniqueIDs) S = d[A], _ = a.GetAttributeByUniqueId(p, S);
            else {
                if (S = a.GetAttributeId(p, o[d[A]]), S === -1) continue;
                _ = a.GetAttribute(p, S)
            }
            y.attributes.push(r(o, a, p, A, x, _))
        }
        return v === o.TRIANGULAR_MESH && (y.index = i(o, a, p)), o.destroy(p), y
    }

    function i(o, a, l) {
        const d = l.num_faces() * 3,
            h = d * 4,
            p = o._malloc(h);
        a.GetTrianglesUInt32Array(l, h, p);
        const m = new Uint32Array(o.HEAPF32.buffer, p, d).slice();
        return o._free(p), {
            array: m,
            itemSize: 1
        }
    }

    function r(o, a, l, c, d, h) {
        const p = h.num_components(),
            v = l.num_points() * p,
            y = v * d.BYTES_PER_ELEMENT,
            A = s(o, d),
            x = o._malloc(y);
        a.GetAttributeDataArrayForAllPoints(l, h, A, y, x);
        const _ = new d(o.HEAPF32.buffer, x, v).slice();
        return o._free(x), {
            name: c,
            array: _,
            itemSize: p
        }
    }

    function s(o, a) {
        switch (a) {
            case Float32Array:
                return o.DT_FLOAT32;
            case Int8Array:
                return o.DT_INT8;
            case Int16Array:
                return o.DT_INT16;
            case Int32Array:
                return o.DT_INT32;
            case Uint8Array:
                return o.DT_UINT8;
            case Uint16Array:
                return o.DT_UINT16;
            case Uint32Array:
                return o.DT_UINT32
        }
    }
}
let zp;
const Av = () => {
        if (zp) return zp;
        const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
            e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
            t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
            i = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
        if (typeof WebAssembly != "object") return {
            supported: !1
        };
        let r = n;
        WebAssembly.validate(t) && (r = e);
        let s;
        const o = WebAssembly.instantiate(a(r), {}).then(h => {
            s = h.instance, s.exports.__wasm_call_ctors()
        });

        function a(h) {
            const p = new Uint8Array(h.length);
            for (let v = 0; v < h.length; ++v) {
                const y = h.charCodeAt(v);
                p[v] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62
            }
            let m = 0;
            for (let v = 0; v < h.length; ++v) p[m++] = p[v] < 60 ? i[p[v]] : (p[v] - 60) * 64 + p[++v];
            return p.buffer.slice(0, m)
        }

        function l(h, p, m, v, y, A) {
            const x = s.exports.sbrk,
                _ = m + 3 & -4,
                S = x(_ * v),
                M = x(y.length),
                b = new Uint8Array(s.exports.memory.buffer);
            b.set(y, M);
            const B = h(S, m, v, M, y.length);
            if (B === 0 && A && A(S, _, v), p.set(b.subarray(S, S + m * v)), x(S - x(0)), B !== 0) throw new Error(`Malformed buffer data: ${B}`)
        }
        const c = {
                0: "",
                1: "meshopt_decodeFilterOct",
                2: "meshopt_decodeFilterQuat",
                3: "meshopt_decodeFilterExp",
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            },
            d = {
                0: "meshopt_decodeVertexBuffer",
                1: "meshopt_decodeIndexBuffer",
                2: "meshopt_decodeIndexSequence",
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            };
        return zp = {
            ready: o,
            supported: !0,
            decodeVertexBuffer(h, p, m, v, y) {
                l(s.exports.meshopt_decodeVertexBuffer, h, p, m, v, s.exports[c[y]])
            },
            decodeIndexBuffer(h, p, m, v) {
                l(s.exports.meshopt_decodeIndexBuffer, h, p, m, v)
            },
            decodeIndexSequence(h, p, m, v) {
                l(s.exports.meshopt_decodeIndexSequence, h, p, m, v)
            },
            decodeGltfBuffer(h, p, m, v, y, A) {
                l(s.exports[d[y]], h, p, m, v, s.exports[c[A]])
            }
        }, zp
    },
    cb = n => n === Object(n) && !Array.isArray(n) && typeof n != "function";

function H_(n, e) {
    const t = Fi(r => r.gl),
        i = ea(Dd, cb(n) ? Object.values(n) : n);
    if (U.useLayoutEffect(() => {
            e == null || e(i)
        }, [e]), U.useEffect(() => {
            (Array.isArray(i) ? i : [i]).forEach(t.initTexture)
        }, [t, i]), cb(n)) {
        const r = Object.keys(n),
            s = {};
        return r.forEach(o => Object.assign(s, {
            [o]: i[r.indexOf(o)]
        })), s
    } else return i
}
H_.preload = n => ea.preload(Dd, n);
H_.clear = n => ea.clear(Dd, n);

function EV(n) {
    return Array.isArray(n)
}

function xv(n = [0, 0, 0]) {
    return EV(n) ? n : n instanceof D || n instanceof ll ? [n.x, n.y, n.z] : [n, n, n]
}

function bV({
    debug: n,
    mesh: e,
    children: t,
    position: i,
    rotation: r,
    scale: s,
    ...o
}) {
    const a = U.useRef(null),
        l = U.useRef(null);
    return U.useLayoutEffect(() => {
        const c = (e == null ? void 0 : e.current) || a.current.parent,
            d = a.current;
        if (!(c instanceof bn)) throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');
        const h = {
            position: new D,
            rotation: new ll,
            scale: new D(1, 1, 1)
        };
        if (c) {
            Eo(h, {
                position: i,
                scale: s
            });
            const p = c.matrixWorld.clone();
            if (c.matrixWorld.identity(), !r || typeof r == "number") {
                const m = new Tt;
                m.position.copy(h.position), m.lookAt(c.position), typeof r == "number" && m.rotateZ(r), Eo(h, {
                    rotation: m.rotation
                })
            } else Eo(h, {
                rotation: r
            });
            return d.geometry = new SV(c, h.position, h.rotation, h.scale), l.current && Eo(l.current, h), c.matrixWorld = p, () => {
                d.geometry.dispose()
            }
        }
    }, [e, ...xv(i), ...xv(s), ...xv(r)]), U.createElement("mesh", {
        ref: a
    }, t || U.createElement("meshStandardMaterial", yr({
        transparent: !0,
        polygonOffset: !0,
        polygonOffsetFactor: -10
    }, o)), n && U.createElement("mesh", {
        ref: l
    }, U.createElement("boxGeometry", null), U.createElement("meshNormalMaterial", {
        wireframe: !0
    }), U.createElement("axesHelper", null)))
}
let Gp = null;

function iR(n, e, t) {
    return i => {
        t && t(i), n && (Gp || (Gp = new MV), Gp.setDecoderPath(typeof n == "string" ? n : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"), i.setDRACOLoader(Gp)), e && i.setMeshoptDecoder(typeof Av == "function" ? Av() : Av)
    }
}

function V_(n, e = !0, t = !0, i) {
    return ea(G_, n, iR(e, t, i))
}
V_.preload = (n, e = !0, t = !0, i) => ea.preload(G_, n, iR(e, t, i));
V_.clear = n => ea.clear(G_, n);
const rR = U.forwardRef(({
    makeDefault: n,
    camera: e,
    regress: t,
    domElement: i,
    enableDamping: r = !0,
    onChange: s,
    onStart: o,
    onEnd: a,
    ...l
}, c) => {
    const d = Fi(b => b.invalidate),
        h = Fi(b => b.camera),
        p = Fi(b => b.gl),
        m = Fi(b => b.events),
        v = Fi(b => b.setEvents),
        y = Fi(b => b.set),
        A = Fi(b => b.get),
        x = Fi(b => b.performance),
        _ = e || h,
        S = i || m.connected || p.domElement,
        M = U.useMemo(() => new X9(_), [_]);
    return ec(() => {
        M.enabled && M.update()
    }, -1), U.useEffect(() => (M.connect(S), () => void M.dispose()), [S, t, M, d]), U.useEffect(() => {
        const b = E => {
                d(), t && x.regress(), s && s(E)
            },
            B = E => {
                o && o(E)
            },
            R = E => {
                a && a(E)
            };
        return M.addEventListener("change", b), M.addEventListener("start", B), M.addEventListener("end", R), () => {
            M.removeEventListener("start", B), M.removeEventListener("end", R), M.removeEventListener("change", b)
        }
    }, [s, o, a, M, d, v]), U.useEffect(() => {
        if (n) {
            const b = A().controls;
            return y({
                controls: M
            }), () => y({
                controls: b
            })
        }
    }, [n, M]), U.createElement("primitive", yr({
        ref: c,
        object: M,
        enableDamping: r
    }, l))
});
class TV extends _d {
    constructor(e) {
        super(e), this.onBeforeCompile = (t, i) => {
            const {
                isWebGL2: r
            } = i.capabilities;
            t.fragmentShader = t.fragmentShader.replace("#include <output_fragment>", `
        ${r?"#include <output_fragment>":`#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `)
        }
    }
}
const BV = U.forwardRef((n, e) => {
        const [t] = U.useState(() => new TV(null));
        return U.createElement("primitive", yr({}, n, {
            object: t,
            ref: e,
            attach: "material"
        }))
    }),
    PV = U.forwardRef(({
        children: n,
        speed: e = 1,
        rotationIntensity: t = 1,
        floatIntensity: i = 1,
        floatingRange: r = [-.1, .1],
        ...s
    }, o) => {
        const a = U.useRef(null),
            l = U.useRef(Math.random() * 1e4);
        return ec(c => {
            var d, h;
            const p = l.current + c.clock.getElapsedTime();
            a.current.rotation.x = Math.cos(p / 4 * e) / 8 * t, a.current.rotation.y = Math.sin(p / 4 * e) / 8 * t, a.current.rotation.z = Math.sin(p / 4 * e) / 20 * t;
            let m = Math.sin(p / 4 * e) / 10;
            m = e_.mapLinear(m, -.1, .1, (d = r == null ? void 0 : r[0]) !== null && d !== void 0 ? d : -.1, (h = r == null ? void 0 : r[1]) !== null && h !== void 0 ? h : .1), a.current.position.y = m * i
        }), U.createElement("group", s, U.createElement("group", {
            ref: z_([a, o])
        }, n))
    });
let xa, Qc;
const RV = U.createContext(null),
    fb = new rt,
    db = new D,
    IV = U.forwardRef(({
        children: n,
        range: e,
        limit: t = 1e3,
        ...i
    }, r) => {
        const s = U.useRef(null),
            [o, a] = U.useState([]),
            [
                [l, c, d]
            ] = U.useState(() => [new Float32Array(t * 3), Float32Array.from({
                length: t * 3
            }, () => 1), Float32Array.from({
                length: t
            }, () => 1)]);
        U.useEffect(() => {
            s.current.geometry.attributes.position.needsUpdate = !0
        }), ec(() => {
            for (s.current.updateMatrix(), s.current.updateMatrixWorld(), fb.copy(s.current.matrixWorld).invert(), s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, o.length), xa = 0; xa < o.length; xa++) Qc = o[xa].current, Qc.getWorldPosition(db).applyMatrix4(fb), db.toArray(l, xa * 3), s.current.geometry.attributes.position.needsUpdate = !0, Qc.matrixWorldNeedsUpdate = !0, Qc.color.toArray(c, xa * 3), s.current.geometry.attributes.color.needsUpdate = !0, d.set([Qc.size], xa), s.current.geometry.attributes.size.needsUpdate = !0
        });
        const h = U.useMemo(() => ({
            getParent: () => s,
            subscribe: p => (a(m => [...m, p]), () => a(m => m.filter(v => v.current !== p.current)))
        }), []);
        return U.createElement("points", yr({
            userData: {
                instances: o
            },
            matrixAutoUpdate: !1,
            ref: z_([r, s]),
            raycast: () => null
        }, i), U.createElement("bufferGeometry", null, U.createElement("bufferAttribute", {
            attach: "attributes-position",
            count: l.length / 3,
            array: l,
            itemSize: 3,
            usage: Ja
        }), U.createElement("bufferAttribute", {
            attach: "attributes-color",
            count: c.length / 3,
            array: c,
            itemSize: 3,
            usage: Ja
        }), U.createElement("bufferAttribute", {
            attach: "attributes-size",
            count: d.length,
            array: d,
            itemSize: 1,
            usage: Ja
        })), U.createElement(RV.Provider, {
            value: h
        }, n))
    }),
    LV = U.forwardRef(({
        children: n,
        positions: e,
        colors: t,
        sizes: i,
        stride: r = 3,
        ...s
    }, o) => {
        const a = U.useRef(null);
        return ec(() => {
            const l = a.current.geometry.attributes;
            l.position.needsUpdate = !0, t && (l.color.needsUpdate = !0), i && (l.size.needsUpdate = !0)
        }), U.createElement("points", yr({
            ref: z_([o, a])
        }, s), U.createElement("bufferGeometry", null, U.createElement("bufferAttribute", {
            attach: "attributes-position",
            count: e.length / r,
            array: e,
            itemSize: r,
            usage: Ja
        }), t && U.createElement("bufferAttribute", {
            attach: "attributes-color",
            count: t.length / r,
            array: t,
            itemSize: 3,
            usage: Ja
        }), i && U.createElement("bufferAttribute", {
            attach: "attributes-size",
            count: i.length / r,
            array: i,
            itemSize: 1,
            usage: Ja
        })), n)
    }),
    DV = U.forwardRef((n, e) => n.positions instanceof Float32Array ? U.createElement(LV, yr({}, n, {
        ref: e
    })) : U.createElement(IV, yr({}, n, {
        ref: e
    })));
var Qm = {},
    FV = {
        get exports() {
            return Qm
        },
        set exports(n) {
            Qm = n
        }
    },
    kV = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
    NV = kV,
    OV = NV;

function sR() {}

function oR() {}
oR.resetWarningCache = sR;
var UV = function() {
    function n(i, r, s, o, a, l) {
        if (l !== OV) {
            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw c.name = "Invariant Violation", c
        }
    }
    n.isRequired = n;

    function e() {
        return n
    }
    var t = {
        array: n,
        bigint: n,
        bool: n,
        func: n,
        number: n,
        object: n,
        string: n,
        symbol: n,
        any: n,
        arrayOf: e,
        element: n,
        elementType: n,
        instanceOf: e,
        node: n,
        objectOf: e,
        oneOf: e,
        oneOfType: e,
        shape: e,
        exact: e,
        checkPropTypes: oR,
        resetWarningCache: sR
    };
    return t.PropTypes = t, t
};
FV.exports = UV();

function W_({
    all: n,
    scene: e,
    camera: t
}) {
    const i = Fi(({
            gl: o
        }) => o),
        r = Fi(({
            camera: o
        }) => o),
        s = Fi(({
            scene: o
        }) => o);
    return U.useLayoutEffect(() => {
        const o = [];
        n && (e || s).traverse(c => {
            c.visible === !1 && (o.push(c), c.visible = !0)
        }), i.compile(e || s, t || r);
        const a = new o_(128);
        new s_(.01, 1e5, a).update(i, e || s), a.dispose(), o.forEach(c => c.visible = !1)
    }, []), null
}
const aR = () => {
        const {
            progress: n
        } = N9();
        return it(k9, {
            as: "div",
            center: !0,
            style: {
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                flexDirection: "column"
            },
            children: [le("span", {
                className: "canvas-loader"
            }), it("p", {
                style: {
                    fontSize: 14,
                    color: "#F1F1F1",
                    fontWeight: 800,
                    marginTop: 40
                },
                children: [n.toFixed(2), "%"]
            })]
        })
    },
    zV = () => {
        const n = V_("./planet/scene.gltf");
        return le("primitive", {
            object: n.scene,
            scale: 2.5,
            "position-y": 0,
            "rotation-y": 0
        })
    },
    GV = () => le(O_, {
        shadows: !0,
        frameloop: "demand",
        dpr: [1, 2],
        gl: {
            preserveDrawingBuffer: !0
        },
        camera: {
            fov: 45,
            near: .1,
            far: 200,
            position: [-4, 3, 6]
        },
        children: it(U.Suspense, {
            fallback: le(aR, {}),
            children: [le(rR, {
                autoRotate: !0,
                enableZoom: !1,
                maxPolarAngle: Math.PI / 2,
                minPolarAngle: Math.PI / 2
            }), le(zV, {}), le(W_, {
                all: !0
            })]
        })
    }),
    HV = n => {
        const [e] = H_([n.imgUrl]);
        return it(PV, {
            speed: 1.75,
            rotationIntensity: 1,
            floatIntensity: 2,
            children: [le("ambientLight", {
                intensity: .25
            }), le("directionalLight", {
                position: [0, 0, .05]
            }), it("mesh", {
                castShadow: !0,
                receiveShadow: !0,
                scale: 2.75,
                children: [le("icosahedronGeometry", {
                    args: [1, 1]
                }), le("meshStandardMaterial", {
                    color: "#fff8eb",
                    polygonOffset: !0,
                    polygonOffsetFactor: -5,
                    flatShading: !0
                }), le(bV, {
                    position: [0, 0, 1],
                    rotation: [2 * Math.PI, 0, 6.25],
                    scale: 1,
                    map: e,
                    flatShading: !0
                })]
            })]
        })
    },
    VV = ({
        icon: n
    }) => it(O_, {
        frameloop: "demand",
        dpr: [1, 2],
        gl: {
            preserveDrawingBuffer: !0
        },
        children: [it(U.Suspense, {
            fallback: le(aR, {}),
            children: [le(rR, {
                enableZoom: !1
            }), le(HV, {
                imgUrl: n
            })]
        }), le(W_, {
            all: !0
        })]
    }),
    WV = n => {
        const e = U.useRef(),
            [t] = U.useState(() => W9(new Float32Array(5e3), {
                radius: 1.2
            }));
        return ec((i, r) => {
            e.current.rotation.x -= r / 10, e.current.rotation.y -= r / 15
        }), le("group", {
            rotation: [0, 0, Math.PI / 4],
            children: le(DV, {
                ref: e,
                positions: t,
                stride: 3,
                frustumCulled: !0,
                ...n,
                children: le(BV, {
                    transparent: !0,
                    color: "#f272c8",
                    size: .002,
                    sizeAttenuation: !0,
                    depthWrite: !1
                })
            })
        })
    },
    jV = () => le("div", {
        className: "w-full h-auto absolute inset-0 z-[-1]",
        children: it(O_, {
            camera: {
                position: [0, 0, 1]
            },
            children: [le(U.Suspense, {
                fallback: null,
                children: le(WV, {})
            }), le(W_, {
                all: !0
            })]
        })
    }),
    lR = U.createContext({
        transformPagePoint: n => n,
        isStatic: !1,
        reducedMotion: "never"
    }),
    zg = U.createContext({});

function JV() {
    return U.useContext(zg).visualElement
}
const j_ = U.createContext(null),
    Gg = typeof document < "u",
    hb = Gg ? U.useLayoutEffect : U.useEffect,
    uR = U.createContext({
        strict: !1
    });

function XV(n, e, t, i) {
    const r = JV(),
        s = U.useContext(uR),
        o = U.useContext(j_),
        a = U.useContext(lR).reducedMotion,
        l = U.useRef();
    i = i || s.renderer, !l.current && i && (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a
    }));
    const c = l.current;
    return U.useInsertionEffect(() => {
        c && c.update(t, o)
    }), hb(() => {
        c && c.render()
    }), U.useEffect(() => {
        c && c.updateFeatures()
    }), (window.HandoffAppearAnimations ? hb : U.useEffect)(() => {
        c && c.animationState && c.animationState.animateChanges()
    }), c
}

function du(n) {
    return typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
}

function QV(n, e, t) {
    return U.useCallback(i => {
        i && n.mount && n.mount(i), e && (i ? e.mount(i) : e.unmount()), t && (typeof t == "function" ? t(i) : du(t) && (t.current = i))
    }, [e])
}

function rd(n) {
    return typeof n == "string" || Array.isArray(n)
}

function Hg(n) {
    return typeof n == "object" && typeof n.start == "function"
}
const J_ = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
    X_ = ["initial", ...J_];

function Vg(n) {
    return Hg(n.animate) || X_.some(e => rd(n[e]))
}

function cR(n) {
    return Boolean(Vg(n) || n.variants)
}

function KV(n, e) {
    if (Vg(n)) {
        const {
            initial: t,
            animate: i
        } = n;
        return {
            initial: t === !1 || rd(t) ? t : void 0,
            animate: rd(i) ? i : void 0
        }
    }
    return n.inherit !== !1 ? e : {}
}

function YV(n) {
    const {
        initial: e,
        animate: t
    } = KV(n, U.useContext(zg));
    return U.useMemo(() => ({
        initial: e,
        animate: t
    }), [pb(e), pb(t)])
}

function pb(n) {
    return Array.isArray(n) ? n.join(" ") : n
}
const mb = {
        animation: ["animate", "exit", "variants", "whileHover", "whileTap", "whileFocus", "whileDrag", "whileInView"],
        exit: ["exit"],
        drag: ["drag", "dragControls"],
        focus: ["whileFocus"],
        hover: ["whileHover", "onHoverStart", "onHoverEnd"],
        tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
        pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
        inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
        layout: ["layout", "layoutId"]
    },
    sd = {};
for (const n in mb) sd[n] = {
    isEnabled: e => mb[n].some(t => !!e[t])
};

function ZV(n) {
    for (const e in n) sd[e] = {
        ...sd[e],
        ...n[e]
    }
}

function fR(n) {
    const e = U.useRef(null);
    return e.current === null && (e.current = n()), e.current
}
const vf = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
let qV = 1;

function $V() {
    return fR(() => {
        if (vf.hasEverUpdated) return qV++
    })
}
const dR = U.createContext({}),
    hR = U.createContext({}),
    e8 = Symbol.for("motionComponentSymbol");

function t8({
    preloadedFeatures: n,
    createVisualElement: e,
    useRender: t,
    useVisualState: i,
    Component: r
}) {
    n && ZV(n);

    function s(a, l) {
        let c;
        const d = {
                ...U.useContext(lR),
                ...a,
                layoutId: n8(a)
            },
            {
                isStatic: h
            } = d,
            p = YV(a),
            m = h ? void 0 : $V(),
            v = i(a, h);
        if (!h && Gg) {
            p.visualElement = XV(r, v, d, e);
            const y = U.useContext(hR),
                A = U.useContext(uR).strict;
            p.visualElement && (c = p.visualElement.loadFeatures(d, A, n, m, y))
        }
        return U.createElement(zg.Provider, {
            value: p
        }, c && p.visualElement ? U.createElement(c, {
            visualElement: p.visualElement,
            ...d
        }) : null, t(r, a, m, QV(v, p.visualElement, l), v, h, p.visualElement))
    }
    const o = U.forwardRef(s);
    return o[e8] = r, o
}

function n8({
    layoutId: n
}) {
    const e = U.useContext(dR).id;
    return e && n !== void 0 ? e + "-" + n : n
}

function i8(n) {
    function e(i, r = {}) {
        return t8(n(i, r))
    }
    if (typeof Proxy > "u") return e;
    const t = new Map;
    return new Proxy(e, {
        get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r))
    })
}
const r8 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function Q_(n) {
    return typeof n != "string" || n.includes("-") ? !1 : !!(r8.indexOf(n) > -1 || /[A-Z]/.test(n))
}
const Km = {};

function s8(n) {
    Object.assign(Km, n)
}
const Wg = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    hl = new Set(Wg);

function pR(n, {
    layout: e,
    layoutId: t
}) {
    return hl.has(n) || n.startsWith("origin") || (e || t !== void 0) && (!!Km[n] || n === "opacity")
}
const Ei = n => Boolean(n && n.getVelocity),
    o8 = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    },
    a8 = Wg.length;

function l8(n, {
    enableHardwareAcceleration: e = !0,
    allowTransformNone: t = !0
}, i, r) {
    let s = "";
    for (let o = 0; o < a8; o++) {
        const a = Wg[o];
        if (n[a] !== void 0) {
            const l = o8[a] || a;
            s += `${l}(${n[a]}) `
        }
    }
    return e && !n.z && (s += "translateZ(0)"), s = s.trim(), r ? s = r(n, i ? "" : s) : t && i && (s = "none"), s
}
const mR = n => e => typeof e == "string" && e.startsWith(n),
    gR = mR("--"),
    Bx = mR("var(--"),
    u8 = (n, e) => e && typeof n == "number" ? e.transform(n) : n,
    Gu = (n, e, t) => Math.min(Math.max(t, n), e),
    pl = {
        test: n => typeof n == "number",
        parse: parseFloat,
        transform: n => n
    },
    Af = {
        ...pl,
        transform: n => Gu(0, 1, n)
    },
    Hp = {
        ...pl,
        default: 1
    },
    xf = n => Math.round(n * 1e5) / 1e5,
    od = /(-)?([\d]*\.?[\d])+/g,
    Px = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
    c8 = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;

function Nd(n) {
    return typeof n == "string"
}
const Od = n => ({
        test: e => Nd(e) && e.endsWith(n) && e.split(" ").length === 1,
        parse: parseFloat,
        transform: e => `${e}${n}`
    }),
    po = Od("deg"),
    is = Od("%"),
    nt = Od("px"),
    f8 = Od("vh"),
    d8 = Od("vw"),
    gb = {
        ...is,
        parse: n => is.parse(n) / 100,
        transform: n => is.transform(n * 100)
    },
    yb = {
        ...pl,
        transform: Math.round
    },
    yR = {
        borderWidth: nt,
        borderTopWidth: nt,
        borderRightWidth: nt,
        borderBottomWidth: nt,
        borderLeftWidth: nt,
        borderRadius: nt,
        radius: nt,
        borderTopLeftRadius: nt,
        borderTopRightRadius: nt,
        borderBottomRightRadius: nt,
        borderBottomLeftRadius: nt,
        width: nt,
        maxWidth: nt,
        height: nt,
        maxHeight: nt,
        size: nt,
        top: nt,
        right: nt,
        bottom: nt,
        left: nt,
        padding: nt,
        paddingTop: nt,
        paddingRight: nt,
        paddingBottom: nt,
        paddingLeft: nt,
        margin: nt,
        marginTop: nt,
        marginRight: nt,
        marginBottom: nt,
        marginLeft: nt,
        rotate: po,
        rotateX: po,
        rotateY: po,
        rotateZ: po,
        scale: Hp,
        scaleX: Hp,
        scaleY: Hp,
        scaleZ: Hp,
        skew: po,
        skewX: po,
        skewY: po,
        distance: nt,
        translateX: nt,
        translateY: nt,
        translateZ: nt,
        x: nt,
        y: nt,
        z: nt,
        perspective: nt,
        transformPerspective: nt,
        opacity: Af,
        originX: gb,
        originY: gb,
        originZ: nt,
        zIndex: yb,
        fillOpacity: Af,
        strokeOpacity: Af,
        numOctaves: yb
    };

function K_(n, e, t, i) {
    const {
        style: r,
        vars: s,
        transform: o,
        transformOrigin: a
    } = n;
    let l = !1,
        c = !1,
        d = !0;
    for (const h in e) {
        const p = e[h];
        if (gR(h)) {
            s[h] = p;
            continue
        }
        const m = yR[h],
            v = u8(p, m);
        if (hl.has(h)) {
            if (l = !0, o[h] = v, !d) continue;
            p !== (m.default || 0) && (d = !1)
        } else h.startsWith("origin") ? (c = !0, a[h] = v) : r[h] = v
    }
    if (e.transform || (l || i ? r.transform = l8(n.transform, t, d, i) : r.transform && (r.transform = "none")), c) {
        const {
            originX: h = "50%",
            originY: p = "50%",
            originZ: m = 0
        } = a;
        r.transformOrigin = `${h} ${p} ${m}`
    }
}
const Y_ = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});

function vR(n, e, t) {
    for (const i in e) !Ei(e[i]) && !pR(i, t) && (n[i] = e[i])
}

function h8({
    transformTemplate: n
}, e, t) {
    return U.useMemo(() => {
        const i = Y_();
        return K_(i, e, {
            enableHardwareAcceleration: !t
        }, n), Object.assign({}, i.vars, i.style)
    }, [e])
}

function p8(n, e, t) {
    const i = n.style || {},
        r = {};
    return vR(r, i, n), Object.assign(r, h8(n, e, t)), n.transformValues ? n.transformValues(r) : r
}

function m8(n, e, t) {
    const i = {},
        r = p8(n, e, t);
    return n.drag && n.dragListener !== !1 && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = n.drag === !0 ? "none" : `pan-${n.drag==="x"?"y":"x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (i.tabIndex = 0), i.style = r, i
}
const g8 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);

function Ym(n) {
    return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || g8.has(n)
}
let AR = n => !Ym(n);

function y8(n) {
    n && (AR = e => e.startsWith("on") ? !Ym(e) : n(e))
}
try {
    y8(require("@emotion/is-prop-valid").default)
} catch {}

function v8(n, e, t) {
    const i = {};
    for (const r in n) r === "values" && typeof n.values == "object" || (AR(r) || t === !0 && Ym(r) || !e && !Ym(r) || n.draggable && r.startsWith("onDrag")) && (i[r] = n[r]);
    return i
}

function vb(n, e, t) {
    return typeof n == "string" ? n : nt.transform(e + t * n)
}

function A8(n, e, t) {
    const i = vb(e, n.x, n.width),
        r = vb(t, n.y, n.height);
    return `${i} ${r}`
}
const x8 = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
    },
    _8 = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };

function w8(n, e, t = 1, i = 0, r = !0) {
    n.pathLength = 1;
    const s = r ? x8 : _8;
    n[s.offset] = nt.transform(-i);
    const o = nt.transform(e),
        a = nt.transform(t);
    n[s.array] = `${o} ${a}`
}

function Z_(n, {
    attrX: e,
    attrY: t,
    originX: i,
    originY: r,
    pathLength: s,
    pathSpacing: o = 1,
    pathOffset: a = 0,
    ...l
}, c, d, h) {
    if (K_(n, l, c, h), d) {
        n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
        return
    }
    n.attrs = n.style, n.style = {};
    const {
        attrs: p,
        style: m,
        dimensions: v
    } = n;
    p.transform && (v && (m.transform = p.transform), delete p.transform), v && (i !== void 0 || r !== void 0 || m.transform) && (m.transformOrigin = A8(v, i !== void 0 ? i : .5, r !== void 0 ? r : .5)), e !== void 0 && (p.x = e), t !== void 0 && (p.y = t), s !== void 0 && w8(p, s, o, a, !1)
}
const xR = () => ({
        ...Y_(),
        attrs: {}
    }),
    q_ = n => typeof n == "string" && n.toLowerCase() === "svg";

function S8(n, e, t, i) {
    const r = U.useMemo(() => {
        const s = xR();
        return Z_(s, e, {
            enableHardwareAcceleration: !1
        }, q_(i), n.transformTemplate), {
            ...s.attrs,
            style: {
                ...s.style
            }
        }
    }, [e]);
    if (n.style) {
        const s = {};
        vR(s, n.style, n), r.style = {
            ...s,
            ...r.style
        }
    }
    return r
}

function M8(n = !1) {
    return (t, i, r, s, {
        latestValues: o
    }, a) => {
        const c = (Q_(t) ? S8 : m8)(i, o, a, t),
            h = {
                ...v8(i, typeof t == "string", n),
                ...c,
                ref: s
            },
            {
                children: p
            } = i,
            m = U.useMemo(() => Ei(p) ? p.get() : p, [p]);
        return r && (h["data-projection-id"] = r), U.createElement(t, {
            ...h,
            children: m
        })
    }
}
const $_ = n => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

function _R(n, {
    style: e,
    vars: t
}, i, r) {
    Object.assign(n.style, e, r && r.getProjectionStyles(i));
    for (const s in t) n.style.setProperty(s, t[s])
}
const wR = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function SR(n, e, t, i) {
    _R(n, e, void 0, i);
    for (const r in e.attrs) n.setAttribute(wR.has(r) ? r : $_(r), e.attrs[r])
}

function ew(n, e) {
    const {
        style: t
    } = n, i = {};
    for (const r in t)(Ei(t[r]) || e.style && Ei(e.style[r]) || pR(r, n)) && (i[r] = t[r]);
    return i
}

function MR(n, e) {
    const t = ew(n, e);
    for (const i in n)
        if (Ei(n[i]) || Ei(e[i])) {
            const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i;
            t[r] = n[i]
        } return t
}

function tw(n, e, t, i = {}, r = {}) {
    return typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)), typeof e == "string" && (e = n.variants && n.variants[e]), typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)), e
}
const Zm = n => Array.isArray(n),
    C8 = n => Boolean(n && typeof n == "object" && n.mix && n.toValue),
    E8 = n => Zm(n) ? n[n.length - 1] || 0 : n;

function pm(n) {
    const e = Ei(n) ? n.get() : n;
    return C8(e) ? e.toValue() : e
}

function b8({
    scrapeMotionValuesFromProps: n,
    createRenderState: e,
    onMount: t
}, i, r, s) {
    const o = {
        latestValues: T8(i, r, s, n),
        renderState: e()
    };
    return t && (o.mount = a => t(i, a, o)), o
}
const CR = n => (e, t) => {
    const i = U.useContext(zg),
        r = U.useContext(j_),
        s = () => b8(n, e, i, r);
    return t ? s() : fR(s)
};

function T8(n, e, t, i) {
    const r = {},
        s = i(n, {});
    for (const p in s) r[p] = pm(s[p]);
    let {
        initial: o,
        animate: a
    } = n;
    const l = Vg(n),
        c = cR(n);
    e && c && !l && n.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
    let d = t ? t.initial === !1 : !1;
    d = d || o === !1;
    const h = d ? a : o;
    return h && typeof h != "boolean" && !Hg(h) && (Array.isArray(h) ? h : [h]).forEach(m => {
        const v = tw(n, m);
        if (!v) return;
        const {
            transitionEnd: y,
            transition: A,
            ...x
        } = v;
        for (const _ in x) {
            let S = x[_];
            if (Array.isArray(S)) {
                const M = d ? S.length - 1 : 0;
                S = S[M]
            }
            S !== null && (r[_] = S)
        }
        for (const _ in y) r[_] = y[_]
    }), r
}
const B8 = {
        useVisualState: CR({
            scrapeMotionValuesFromProps: MR,
            createRenderState: xR,
            onMount: (n, e, {
                renderState: t,
                latestValues: i
            }) => {
                try {
                    t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
                } catch {
                    t.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
                Z_(t, i, {
                    enableHardwareAcceleration: !1
                }, q_(e.tagName), n.transformTemplate), SR(e, t)
            }
        })
    },
    P8 = {
        useVisualState: CR({
            scrapeMotionValuesFromProps: ew,
            createRenderState: Y_
        })
    };

function R8(n, {
    forwardMotionProps: e = !1
}, t, i) {
    return {
        ...Q_(n) ? B8 : P8,
        preloadedFeatures: t,
        useRender: M8(e),
        createVisualElement: i,
        Component: n
    }
}

function Ds(n, e, t, i = {
    passive: !0
}) {
    return n.addEventListener(e, t, i), () => n.removeEventListener(e, t)
}
const ER = n => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1;

function jg(n, e = "page") {
    return {
        point: {
            x: n[e + "X"],
            y: n[e + "Y"]
        }
    }
}
const I8 = n => e => ER(e) && n(e, jg(e));

function Ns(n, e, t, i) {
    return Ds(n, e, I8(t), i)
}
const L8 = (n, e) => t => e(n(t)),
    No = (...n) => n.reduce(L8);

function bR(n) {
    let e = null;
    return () => {
        const t = () => {
            e = null
        };
        return e === null ? (e = n, t) : !1
    }
}
const Ab = bR("dragHorizontal"),
    xb = bR("dragVertical");

function TR(n) {
    let e = !1;
    if (n === "y") e = xb();
    else if (n === "x") e = Ab();
    else {
        const t = Ab(),
            i = xb();
        t && i ? e = () => {
            t(), i()
        } : (t && t(), i && i())
    }
    return e
}

function BR() {
    const n = TR(!0);
    return n ? (n(), !1) : !0
}
class ta {
    constructor(e) {
        this.isMounted = !1, this.node = e
    }
    update() {}
}

function _b(n, e) {
    const t = "pointer" + (e ? "enter" : "leave"),
        i = "onHover" + (e ? "Start" : "End"),
        r = (s, o) => {
            if (s.type === "touch" || BR()) return;
            const a = n.getProps();
            n.animationState && a.whileHover && n.animationState.setActive("whileHover", e), a[i] && a[i](s, o)
        };
    return Ns(n.current, t, r, {
        passive: !n.getProps()[i]
    })
}
class D8 extends ta {
    mount() {
        this.unmount = No(_b(this.node, !0), _b(this.node, !1))
    }
    unmount() {}
}
class F8 extends ta {
    constructor() {
        super(...arguments), this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }!e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
    }
    mount() {
        this.unmount = No(Ds(this.node.current, "focus", () => this.onFocus()), Ds(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
const PR = (n, e) => e ? n === e ? !0 : PR(n, e.parentElement) : !1,
    hr = n => n;

function _v(n, e) {
    if (!e) return;
    const t = new PointerEvent("pointer" + n);
    e(t, jg(t))
}
class k8 extends ta {
    constructor() {
        super(...arguments), this.removeStartListeners = hr, this.removeEndListeners = hr, this.removeAccessibleListeners = hr, this.startPointerPress = (e, t) => {
            if (this.removeEndListeners(), this.isPressing) return;
            const i = this.node.getProps(),
                s = Ns(window, "pointerup", (a, l) => {
                    if (!this.checkPressEnd()) return;
                    const {
                        onTap: c,
                        onTapCancel: d
                    } = this.node.getProps();
                    PR(this.node.current, a.target) ? c && c(a, l) : d && d(a, l)
                }, {
                    passive: !(i.onTap || i.onPointerUp)
                }),
                o = Ns(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
                    passive: !(i.onTapCancel || i.onPointerCancel)
                });
            this.removeEndListeners = No(s, o), this.startPress(e, t)
        }, this.startAccessiblePress = () => {
            const e = s => {
                    if (s.key !== "Enter" || this.isPressing) return;
                    const o = a => {
                        a.key !== "Enter" || !this.checkPressEnd() || _v("up", this.node.getProps().onTap)
                    };
                    this.removeEndListeners(), this.removeEndListeners = Ds(this.node.current, "keyup", o), _v("down", (a, l) => {
                        this.startPress(a, l)
                    })
                },
                t = Ds(this.node.current, "keydown", e),
                i = () => {
                    this.isPressing && _v("cancel", (s, o) => this.cancelPress(s, o))
                },
                r = Ds(this.node.current, "blur", i);
            this.removeAccessibleListeners = No(t, r)
        }
    }
    startPress(e, t) {
        this.isPressing = !0;
        const {
            onTapStart: i,
            whileTap: r
        } = this.node.getProps();
        r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), i && i(e, t)
    }
    checkPressEnd() {
        return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !BR()
    }
    cancelPress(e, t) {
        if (!this.checkPressEnd()) return;
        const {
            onTapCancel: i
        } = this.node.getProps();
        i && i(e, t)
    }
    mount() {
        const e = this.node.getProps(),
            t = Ns(this.node.current, "pointerdown", this.startPointerPress, {
                passive: !(e.onTapStart || e.onPointerStart)
            }),
            i = Ds(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = No(t, i)
    }
    unmount() {
        this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners()
    }
}
const Rx = new WeakMap,
    wv = new WeakMap,
    N8 = n => {
        const e = Rx.get(n.target);
        e && e(n)
    },
    O8 = n => {
        n.forEach(N8)
    };

function U8({
    root: n,
    ...e
}) {
    const t = n || document;
    wv.has(t) || wv.set(t, {});
    const i = wv.get(t),
        r = JSON.stringify(e);
    return i[r] || (i[r] = new IntersectionObserver(O8, {
        root: n,
        ...e
    })), i[r]
}

function z8(n, e, t) {
    const i = U8(e);
    return Rx.set(n, t), i.observe(n), () => {
        Rx.delete(n), i.unobserve(n)
    }
}
const G8 = {
    some: 0,
    all: 1
};
class H8 extends ta {
    constructor() {
        super(...arguments), this.hasEnteredView = !1, this.isInView = !1
    }
    viewportFallback() {
        requestAnimationFrame(() => {
            this.hasEnteredView = !0;
            const {
                onViewportEnter: e
            } = this.node.getProps();
            e && e(null), this.node.animationState && this.node.animationState.setActive("whileInView", !0)
        })
    }
    startObserver() {
        this.unmount();
        const {
            viewport: e = {}
        } = this.node.getProps(), {
            root: t,
            margin: i,
            amount: r = "some",
            once: s,
            fallback: o = !0
        } = e;
        if (typeof IntersectionObserver > "u") {
            o && this.viewportFallback();
            return
        }
        const a = {
                root: t ? t.current : void 0,
                rootMargin: i,
                threshold: typeof r == "number" ? r : G8[r]
            },
            l = c => {
                const {
                    isIntersecting: d
                } = c;
                if (this.isInView === d || (this.isInView = d, s && !d && this.hasEnteredView)) return;
                d && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", d);
                const {
                    onViewportEnter: h,
                    onViewportLeave: p
                } = this.node.getProps(), m = d ? h : p;
                m && m(c)
            };
        return z8(this.node.current, a, l)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u") return;
        const {
            props: e,
            prevProps: t
        } = this.node;
        ["amount", "margin", "root"].some(V8(e, t)) && this.startObserver()
    }
    unmount() {}
}

function V8({
    viewport: n = {}
}, {
    viewport: e = {}
} = {}) {
    return t => n[t] !== e[t]
}
const W8 = {
    inView: {
        Feature: H8
    },
    tap: {
        Feature: k8
    },
    focus: {
        Feature: F8
    },
    hover: {
        Feature: D8
    }
};

function RR(n, e) {
    if (!Array.isArray(e)) return !1;
    const t = e.length;
    if (t !== n.length) return !1;
    for (let i = 0; i < t; i++)
        if (e[i] !== n[i]) return !1;
    return !0
}
const j8 = n => /^\-?\d*\.?\d+$/.test(n),
    J8 = n => /^0[^.\s]+$/.test(n),
    Os = {
        delta: 0,
        timestamp: 0
    },
    IR = 1 / 60 * 1e3,
    X8 = typeof performance < "u" ? () => performance.now() : () => Date.now(),
    LR = typeof window < "u" ? n => window.requestAnimationFrame(n) : n => setTimeout(() => n(X8()), IR);

function Q8(n) {
    let e = [],
        t = [],
        i = 0,
        r = !1,
        s = !1;
    const o = new WeakSet,
        a = {
            schedule: (l, c = !1, d = !1) => {
                const h = d && r,
                    p = h ? e : t;
                return c && o.add(l), p.indexOf(l) === -1 && (p.push(l), h && r && (i = e.length)), l
            },
            cancel: l => {
                const c = t.indexOf(l);
                c !== -1 && t.splice(c, 1), o.delete(l)
            },
            process: l => {
                if (r) {
                    s = !0;
                    return
                }
                if (r = !0, [e, t] = [t, e], t.length = 0, i = e.length, i)
                    for (let c = 0; c < i; c++) {
                        const d = e[c];
                        d(l), o.has(d) && (a.schedule(d), n())
                    }
                r = !1, s && (s = !1, a.process(l))
            }
        };
    return a
}
const K8 = 40;
let Ix = !0,
    ad = !1,
    Lx = !1;
const Ud = ["read", "update", "preRender", "render", "postRender"],
    Jg = Ud.reduce((n, e) => (n[e] = Q8(() => ad = !0), n), {}),
    ci = Ud.reduce((n, e) => {
        const t = Jg[e];
        return n[e] = (i, r = !1, s = !1) => (ad || Z8(), t.schedule(i, r, s)), n
    }, {}),
    jo = Ud.reduce((n, e) => (n[e] = Jg[e].cancel, n), {}),
    Sv = Ud.reduce((n, e) => (n[e] = () => Jg[e].process(Os), n), {}),
    Y8 = n => Jg[n].process(Os),
    DR = n => {
        ad = !1, Os.delta = Ix ? IR : Math.max(Math.min(n - Os.timestamp, K8), 1), Os.timestamp = n, Lx = !0, Ud.forEach(Y8), Lx = !1, ad && (Ix = !1, LR(DR))
    },
    Z8 = () => {
        ad = !0, Ix = !0, Lx || LR(DR)
    };

function nw(n, e) {
    n.indexOf(e) === -1 && n.push(e)
}

function iw(n, e) {
    const t = n.indexOf(e);
    t > -1 && n.splice(t, 1)
}
class rw {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return nw(this.subscriptions, e), () => iw(this.subscriptions, e)
    }
    notify(e, t, i) {
        const r = this.subscriptions.length;
        if (r)
            if (r === 1) this.subscriptions[0](e, t, i);
            else
                for (let s = 0; s < r; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, t, i)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}

function sw(n, e) {
    return e ? n * (1e3 / e) : 0
}
const q8 = n => !isNaN(parseFloat(n));
class $8 {
    constructor(e, t = {}) {
        this.version = "9.1.7", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (i, r = !0) => {
            this.prev = this.current, this.current = i;
            const {
                delta: s,
                timestamp: o
            } = Os;
            this.lastUpdated !== o && (this.timeDelta = s, this.lastUpdated = o, ci.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), r && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }, this.scheduleVelocityCheck = () => ci.postRender(this.velocityCheck), this.velocityCheck = ({
            timestamp: i
        }) => {
            i !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
        }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = q8(this.current), this.owner = t.owner
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new rw);
        const i = this.events[e].add(t);
        return e === "change" ? () => {
            i(), ci.read(() => {
                this.events.change.getSize() || this.stop()
            })
        } : i
    }
    clearListeners() {
        for (const e in this.events) this.events[e].clear()
    }
    attach(e, t) {
        this.passiveEffect = e, this.stopPassiveEffect = t
    }
    set(e, t = !0) {
        !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, t, i) {
        this.set(t), this.prev = e, this.timeDelta = i
    }
    jump(e) {
        this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        return this.canTrackVelocity ? sw(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
    }
    start(e) {
        return this.stop(), new Promise(t => {
            this.hasAnimated = !0, this.animation = e(t) || null, this.events.animationStart && this.events.animationStart.notify()
        }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
        })
    }
    stop() {
        this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        this.animation = null
    }
    destroy() {
        this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
}

function Hu(n, e) {
    return new $8(n, e)
}
const ow = (n, e) => t => Boolean(Nd(t) && c8.test(t) && t.startsWith(n) || e && Object.prototype.hasOwnProperty.call(t, e)),
    FR = (n, e, t) => i => {
        if (!Nd(i)) return i;
        const [r, s, o, a] = i.match(od);
        return {
            [n]: parseFloat(r),
            [e]: parseFloat(s),
            [t]: parseFloat(o),
            alpha: a !== void 0 ? parseFloat(a) : 1
        }
    },
    e6 = n => Gu(0, 255, n),
    Mv = {
        ...pl,
        transform: n => Math.round(e6(n))
    },
    Ga = {
        test: ow("rgb", "red"),
        parse: FR("red", "green", "blue"),
        transform: ({
            red: n,
            green: e,
            blue: t,
            alpha: i = 1
        }) => "rgba(" + Mv.transform(n) + ", " + Mv.transform(e) + ", " + Mv.transform(t) + ", " + xf(Af.transform(i)) + ")"
    };

function t6(n) {
    let e = "",
        t = "",
        i = "",
        r = "";
    return n.length > 5 ? (e = n.substring(1, 3), t = n.substring(3, 5), i = n.substring(5, 7), r = n.substring(7, 9)) : (e = n.substring(1, 2), t = n.substring(2, 3), i = n.substring(3, 4), r = n.substring(4, 5), e += e, t += t, i += i, r += r), {
        red: parseInt(e, 16),
        green: parseInt(t, 16),
        blue: parseInt(i, 16),
        alpha: r ? parseInt(r, 16) / 255 : 1
    }
}
const Dx = {
        test: ow("#"),
        parse: t6,
        transform: Ga.transform
    },
    hu = {
        test: ow("hsl", "hue"),
        parse: FR("hue", "saturation", "lightness"),
        transform: ({
            hue: n,
            saturation: e,
            lightness: t,
            alpha: i = 1
        }) => "hsla(" + Math.round(n) + ", " + is.transform(xf(e)) + ", " + is.transform(xf(t)) + ", " + xf(Af.transform(i)) + ")"
    },
    oi = {
        test: n => Ga.test(n) || Dx.test(n) || hu.test(n),
        parse: n => Ga.test(n) ? Ga.parse(n) : hu.test(n) ? hu.parse(n) : Dx.parse(n),
        transform: n => Nd(n) ? n : n.hasOwnProperty("red") ? Ga.transform(n) : hu.transform(n)
    },
    kR = "${c}",
    NR = "${n}";

function n6(n) {
    var e, t;
    return isNaN(n) && Nd(n) && (((e = n.match(od)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = n.match(Px)) === null || t === void 0 ? void 0 : t.length) || 0) > 0
}

function qm(n) {
    typeof n == "number" && (n = `${n}`);
    const e = [];
    let t = 0,
        i = 0;
    const r = n.match(Px);
    r && (t = r.length, n = n.replace(Px, kR), e.push(...r.map(oi.parse)));
    const s = n.match(od);
    return s && (i = s.length, n = n.replace(od, NR), e.push(...s.map(pl.parse))), {
        values: e,
        numColors: t,
        numNumbers: i,
        tokenised: n
    }
}

function OR(n) {
    return qm(n).values
}

function UR(n) {
    const {
        values: e,
        numColors: t,
        tokenised: i
    } = qm(n), r = e.length;
    return s => {
        let o = i;
        for (let a = 0; a < r; a++) o = o.replace(a < t ? kR : NR, a < t ? oi.transform(s[a]) : xf(s[a]));
        return o
    }
}
const i6 = n => typeof n == "number" ? 0 : n;

function r6(n) {
    const e = OR(n);
    return UR(n)(e.map(i6))
}
const Jo = {
        test: n6,
        parse: OR,
        createTransformer: UR,
        getAnimatableNone: r6
    },
    s6 = new Set(["brightness", "contrast", "saturate", "opacity"]);

function o6(n) {
    const [e, t] = n.slice(0, -1).split("(");
    if (e === "drop-shadow") return n;
    const [i] = t.match(od) || [];
    if (!i) return n;
    const r = t.replace(i, "");
    let s = s6.has(e) ? 1 : 0;
    return i !== t && (s *= 100), e + "(" + s + r + ")"
}
const a6 = /([a-z-]*)\(.*?\)/g,
    Fx = {
        ...Jo,
        getAnimatableNone: n => {
            const e = n.match(a6);
            return e ? e.map(o6).join(" ") : n
        }
    },
    l6 = {
        ...yR,
        color: oi,
        backgroundColor: oi,
        outlineColor: oi,
        fill: oi,
        stroke: oi,
        borderColor: oi,
        borderTopColor: oi,
        borderRightColor: oi,
        borderBottomColor: oi,
        borderLeftColor: oi,
        filter: Fx,
        WebkitFilter: Fx
    },
    aw = n => l6[n];

function lw(n, e) {
    let t = aw(n);
    return t !== Fx && (t = Jo), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
}
const zR = n => e => e.test(n),
    u6 = {
        test: n => n === "auto",
        parse: n => n
    },
    GR = [pl, nt, is, po, d8, f8, u6],
    Kc = n => GR.find(zR(n)),
    c6 = [...GR, oi, Jo],
    f6 = n => c6.find(zR(n));

function d6(n) {
    const e = {};
    return n.values.forEach((t, i) => e[i] = t.get()), e
}

function h6(n) {
    const e = {};
    return n.values.forEach((t, i) => e[i] = t.getVelocity()), e
}

function Xg(n, e, t) {
    const i = n.getProps();
    return tw(i, e, t !== void 0 ? t : i.custom, d6(n), h6(n))
}

function p6(n, e, t) {
    n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Hu(t))
}

function m6(n, e) {
    const t = Xg(n, e);
    let {
        transitionEnd: i = {},
        transition: r = {},
        ...s
    } = t ? n.makeTargetAnimatable(t, !1) : {};
    s = {
        ...s,
        ...i
    };
    for (const o in s) {
        const a = E8(s[o]);
        p6(n, o, a)
    }
}

function g6(n, e, t) {
    var i, r;
    const s = Object.keys(e).filter(a => !n.hasValue(a)),
        o = s.length;
    if (o)
        for (let a = 0; a < o; a++) {
            const l = s[a],
                c = e[l];
            let d = null;
            Array.isArray(c) && (d = c[0]), d === null && (d = (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !== null && r !== void 0 ? r : e[l]), d != null && (typeof d == "string" && (j8(d) || J8(d)) ? d = parseFloat(d) : !f6(d) && Jo.test(c) && (d = lw(l, c)), n.addValue(l, Hu(d, {
                owner: n
            })), t[l] === void 0 && (t[l] = d), d !== null && n.setBaseTarget(l, d))
        }
}

function y6(n, e) {
    return e ? (e[n] || e.default || e).from : void 0
}

function v6(n, e, t) {
    const i = {};
    for (const r in n) {
        const s = y6(r, e);
        if (s !== void 0) i[r] = s;
        else {
            const o = t.getValue(r);
            o && (i[r] = o.get())
        }
    }
    return i
}

function $m(n) {
    return Boolean(Ei(n) && n.add)
}
const A6 = "framerAppearId",
    x6 = "data-" + $_(A6);
let _6 = hr,
    eg = hr;
const mm = n => n * 1e3,
    w6 = {
        current: !1
    },
    uw = n => e => e <= .5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
    cw = n => e => 1 - n(1 - e),
    fw = n => n * n,
    S6 = cw(fw),
    dw = uw(fw),
    nn = (n, e, t) => -t * n + t * e + n;

function Cv(n, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
}

function M6({
    hue: n,
    saturation: e,
    lightness: t,
    alpha: i
}) {
    n /= 360, e /= 100, t /= 100;
    let r = 0,
        s = 0,
        o = 0;
    if (!e) r = s = o = t;
    else {
        const a = t < .5 ? t * (1 + e) : t + e - t * e,
            l = 2 * t - a;
        r = Cv(l, a, n + 1 / 3), s = Cv(l, a, n), o = Cv(l, a, n - 1 / 3)
    }
    return {
        red: Math.round(r * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: i
    }
}
const Ev = (n, e, t) => {
        const i = n * n;
        return Math.sqrt(Math.max(0, t * (e * e - i) + i))
    },
    C6 = [Dx, Ga, hu],
    E6 = n => C6.find(e => e.test(n));

function wb(n) {
    const e = E6(n);
    let t = e.parse(n);
    return e === hu && (t = M6(t)), t
}
const HR = (n, e) => {
    const t = wb(n),
        i = wb(e),
        r = {
            ...t
        };
    return s => (r.red = Ev(t.red, i.red, s), r.green = Ev(t.green, i.green, s), r.blue = Ev(t.blue, i.blue, s), r.alpha = nn(t.alpha, i.alpha, s), Ga.transform(r))
};

function VR(n, e) {
    return typeof n == "number" ? t => nn(n, e, t) : oi.test(n) ? HR(n, e) : jR(n, e)
}
const WR = (n, e) => {
        const t = [...n],
            i = t.length,
            r = n.map((s, o) => VR(s, e[o]));
        return s => {
            for (let o = 0; o < i; o++) t[o] = r[o](s);
            return t
        }
    },
    b6 = (n, e) => {
        const t = {
                ...n,
                ...e
            },
            i = {};
        for (const r in t) n[r] !== void 0 && e[r] !== void 0 && (i[r] = VR(n[r], e[r]));
        return r => {
            for (const s in i) t[s] = i[s](r);
            return t
        }
    },
    jR = (n, e) => {
        const t = Jo.createTransformer(e),
            i = qm(n),
            r = qm(e);
        return i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? No(WR(i.values, r.values), t) : o => `${o>0?e:n}`
    },
    ld = (n, e, t) => {
        const i = e - n;
        return i === 0 ? 1 : (t - n) / i
    },
    Sb = (n, e) => t => nn(n, e, t);

function T6(n) {
    return typeof n == "number" ? Sb : typeof n == "string" ? oi.test(n) ? HR : jR : Array.isArray(n) ? WR : typeof n == "object" ? b6 : Sb
}

function B6(n, e, t) {
    const i = [],
        r = t || T6(n[0]),
        s = n.length - 1;
    for (let o = 0; o < s; o++) {
        let a = r(n[o], n[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] : e;
            a = No(l, a)
        }
        i.push(a)
    }
    return i
}

function JR(n, e, {
    clamp: t = !0,
    ease: i,
    mixer: r
} = {}) {
    const s = n.length;
    eg(s === e.length), eg(!i || !Array.isArray(i) || i.length === s - 1), n[0] > n[s - 1] && (n = [...n].reverse(), e = [...e].reverse());
    const o = B6(e, i, r),
        a = o.length,
        l = c => {
            let d = 0;
            if (a > 1)
                for (; d < n.length - 2 && !(c < n[d + 1]); d++);
            const h = ld(n[d], n[d + 1], c);
            return o[d](h)
        };
    return t ? c => l(Gu(n[0], n[s - 1], c)) : l
}

function P6(n, e) {
    const t = n[n.length - 1];
    for (let i = 1; i <= e; i++) {
        const r = ld(0, e, i);
        n.push(nn(t, 1, r))
    }
}

function R6(n) {
    const e = [0];
    return P6(e, n.length - 1), e
}

function I6(n, e) {
    return n.map(t => t * e)
}
const XR = (n, e, t) => (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
    L6 = 1e-7,
    D6 = 12;

function F6(n, e, t, i, r) {
    let s, o, a = 0;
    do o = e + (t - e) / 2, s = XR(o, i, r) - n, s > 0 ? t = o : e = o; while (Math.abs(s) > L6 && ++a < D6);
    return o
}

function QR(n, e, t, i) {
    if (n === e && t === i) return hr;
    const r = s => F6(s, 0, 1, n, t);
    return s => s === 0 || s === 1 ? s : XR(r(s), e, i)
}
const KR = n => 1 - Math.sin(Math.acos(n)),
    hw = cw(KR),
    k6 = uw(hw),
    YR = QR(.33, 1.53, .69, .99),
    pw = cw(YR),
    N6 = uw(pw),
    O6 = n => (n *= 2) < 1 ? .5 * pw(n) : .5 * (2 - Math.pow(2, -10 * (n - 1))),
    U6 = {
        linear: hr,
        easeIn: fw,
        easeInOut: dw,
        easeOut: S6,
        circIn: KR,
        circInOut: k6,
        circOut: hw,
        backIn: pw,
        backInOut: N6,
        backOut: YR,
        anticipate: O6
    },
    Mb = n => {
        if (Array.isArray(n)) {
            eg(n.length === 4);
            const [e, t, i, r] = n;
            return QR(e, t, i, r)
        } else if (typeof n == "string") return U6[n];
        return n
    },
    z6 = n => Array.isArray(n) && typeof n[0] != "number";

function G6(n, e) {
    return n.map(() => e || dw).splice(0, n.length - 1)
}

function kx({
    keyframes: n,
    ease: e = dw,
    times: t,
    duration: i = 300
}) {
    n = [...n];
    const r = z6(e) ? e.map(Mb) : Mb(e),
        s = {
            done: !1,
            value: n[0]
        },
        o = I6(t && t.length === n.length ? t : R6(n), i);

    function a() {
        return JR(o, n, {
            ease: Array.isArray(r) ? r : G6(n, r)
        })
    }
    let l = a();
    return {
        next: c => (s.value = l(c), s.done = c >= i, s),
        flipTarget: () => {
            n.reverse(), l = a()
        }
    }
}
const bv = .001,
    H6 = .01,
    Cb = 10,
    V6 = .05,
    W6 = 1;

function j6({
    duration: n = 800,
    bounce: e = .25,
    velocity: t = 0,
    mass: i = 1
}) {
    let r, s;
    _6(n <= Cb * 1e3);
    let o = 1 - e;
    o = Gu(V6, W6, o), n = Gu(H6, Cb, n / 1e3), o < 1 ? (r = c => {
        const d = c * o,
            h = d * n,
            p = d - t,
            m = Nx(c, o),
            v = Math.exp(-h);
        return bv - p / m * v
    }, s = c => {
        const h = c * o * n,
            p = h * t + t,
            m = Math.pow(o, 2) * Math.pow(c, 2) * n,
            v = Math.exp(-h),
            y = Nx(Math.pow(c, 2), o);
        return (-r(c) + bv > 0 ? -1 : 1) * ((p - m) * v) / y
    }) : (r = c => {
        const d = Math.exp(-c * n),
            h = (c - t) * n + 1;
        return -bv + d * h
    }, s = c => {
        const d = Math.exp(-c * n),
            h = (t - c) * (n * n);
        return d * h
    });
    const a = 5 / n,
        l = X6(r, s, a);
    if (n = n * 1e3, isNaN(l)) return {
        stiffness: 100,
        damping: 10,
        duration: n
    }; {
        const c = Math.pow(l, 2) * i;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(i * c),
            duration: n
        }
    }
}
const J6 = 12;

function X6(n, e, t) {
    let i = t;
    for (let r = 1; r < J6; r++) i = i - n(i) / e(i);
    return i
}

function Nx(n, e) {
    return n * Math.sqrt(1 - e * e)
}
const Q6 = ["duration", "bounce"],
    K6 = ["stiffness", "damping", "mass"];

function Eb(n, e) {
    return e.some(t => n[t] !== void 0)
}

function Y6(n) {
    let e = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...n
    };
    if (!Eb(n, K6) && Eb(n, Q6)) {
        const t = j6(n);
        e = {
            ...e,
            ...t,
            velocity: 0,
            mass: 1
        }, e.isResolvedFromDuration = !0
    }
    return e
}
const Z6 = 5;

function ZR({
    keyframes: n,
    restDelta: e,
    restSpeed: t,
    ...i
}) {
    let r = n[0],
        s = n[n.length - 1];
    const o = {
            done: !1,
            value: r
        },
        {
            stiffness: a,
            damping: l,
            mass: c,
            velocity: d,
            duration: h,
            isResolvedFromDuration: p
        } = Y6(i);
    let m = q6,
        v = d ? -(d / 1e3) : 0;
    const y = l / (2 * Math.sqrt(a * c));

    function A() {
        const x = s - r,
            _ = Math.sqrt(a / c) / 1e3,
            S = Math.abs(x) < 5;
        if (t || (t = S ? .01 : 2), e || (e = S ? .005 : .5), y < 1) {
            const M = Nx(_, y);
            m = b => {
                const B = Math.exp(-y * _ * b);
                return s - B * ((v + y * _ * x) / M * Math.sin(M * b) + x * Math.cos(M * b))
            }
        } else if (y === 1) m = M => s - Math.exp(-_ * M) * (x + (v + _ * x) * M);
        else {
            const M = _ * Math.sqrt(y * y - 1);
            m = b => {
                const B = Math.exp(-y * _ * b),
                    R = Math.min(M * b, 300);
                return s - B * ((v + y * _ * x) * Math.sinh(R) + M * x * Math.cosh(R)) / M
            }
        }
    }
    return A(), {
        next: x => {
            const _ = m(x);
            if (p) o.done = x >= h;
            else {
                let S = v;
                if (x !== 0)
                    if (y < 1) {
                        const B = Math.max(0, x - Z6);
                        S = sw(_ - m(B), x - B)
                    } else S = 0;
                const M = Math.abs(S) <= t,
                    b = Math.abs(s - _) <= e;
                o.done = M && b
            }
            return o.value = o.done ? s : _, o
        },
        flipTarget: () => {
            v = -v, [r, s] = [s, r], A()
        }
    }
}
ZR.needsInterpolation = (n, e) => typeof n == "string" || typeof e == "string";
const q6 = n => 0;

function $6({
    keyframes: n = [0],
    velocity: e = 0,
    power: t = .8,
    timeConstant: i = 350,
    restDelta: r = .5,
    modifyTarget: s
}) {
    const o = n[0],
        a = {
            done: !1,
            value: o
        };
    let l = t * e;
    const c = o + l,
        d = s === void 0 ? c : s(c);
    return d !== c && (l = d - o), {
        next: h => {
            const p = -l * Math.exp(-h / i);
            return a.done = !(p > r || p < -r), a.value = a.done ? d : d + p, a
        },
        flipTarget: () => {}
    }
}
const eW = {
    decay: $6,
    keyframes: kx,
    tween: kx,
    spring: ZR
};

function qR(n, e, t = 0) {
    return n - e - t
}

function tW(n, e = 0, t = 0, i = !0) {
    return i ? qR(e + -n, e, t) : e - (n - e) + t
}

function nW(n, e, t, i) {
    return i ? n >= e + t : n <= -t
}
const iW = n => {
    const e = ({
        delta: t
    }) => n(t);
    return {
        start: () => ci.update(e, !0),
        stop: () => jo.update(e)
    }
};

function tg({
    duration: n,
    driver: e = iW,
    elapsed: t = 0,
    repeat: i = 0,
    repeatType: r = "loop",
    repeatDelay: s = 0,
    keyframes: o,
    autoplay: a = !0,
    onPlay: l,
    onStop: c,
    onComplete: d,
    onRepeat: h,
    onUpdate: p,
    type: m = "keyframes",
    ...v
}) {
    const y = t;
    let A, x = 0,
        _ = n,
        S = !1,
        M = !0,
        b;
    const B = eW[o.length > 2 ? "keyframes" : m] || kx,
        R = o[0],
        E = o[o.length - 1];
    let P = {
        done: !1,
        value: R
    };
    const {
        needsInterpolation: I
    } = B;
    I && I(R, E) && (b = JR([0, 100], [R, E], {
        clamp: !1
    }), o = [0, 100]);
    const z = B({
        ...v,
        duration: n,
        keyframes: o
    });

    function Z() {
        x++, r === "reverse" ? (M = x % 2 === 0, t = tW(t, _, s, M)) : (t = qR(t, _, s), r === "mirror" && z.flipTarget()), S = !1, h && h()
    }

    function W() {
        A && A.stop(), d && d()
    }

    function G(te) {
        M || (te = -te), t += te, S || (P = z.next(Math.max(0, t)), b && (P.value = b(P.value)), S = M ? P.done : t <= 0), p && p(P.value), S && (x === 0 && (_ = _ !== void 0 ? _ : t), x < i ? nW(t, _, s, M) && Z() : W())
    }

    function K() {
        l && l(), A = e(G), A.start()
    }
    return a && K(), {
        stop: () => {
            c && c(), A && A.stop()
        },
        set currentTime(te) {
            t = y, G(te)
        },
        sample: te => {
            t = y;
            const se = n && typeof n == "number" ? Math.max(n * .5, 50) : 50;
            let k = 0;
            for (G(0); k <= te;) {
                const V = te - k;
                G(Math.min(V, se)), k += se
            }
            return P
        }
    }
}

function rW(n) {
    return !n || Array.isArray(n) || typeof n == "string" && $R[n]
}
const rf = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
    $R = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: rf([0, .65, .55, 1]),
        circOut: rf([.55, 0, 1, .45]),
        backIn: rf([.31, .01, .66, -.59]),
        backOut: rf([.33, 1.53, .69, .99])
    };

function sW(n) {
    if (n) return Array.isArray(n) ? rf(n) : $R[n]
}

function oW(n, e, t, {
    delay: i = 0,
    duration: r,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a,
    times: l
} = {}) {
    return n.animate({
        [e]: t,
        offset: l
    }, {
        delay: i,
        duration: r,
        easing: sW(a),
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}
const bb = {
        waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
    },
    Tv = {},
    eI = {};
for (const n in bb) eI[n] = () => (Tv[n] === void 0 && (Tv[n] = bb[n]()), Tv[n]);

function aW(n, {
    repeat: e,
    repeatType: t = "loop"
}) {
    const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
    return n[i]
}
const lW = new Set(["opacity", "clipPath", "filter", "transform"]),
    Vp = 10;

function uW(n, e, {
    onUpdate: t,
    onComplete: i,
    ...r
}) {
    if (!(eI.waapi() && lW.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0)) return !1;
    let {
        keyframes: o,
        duration: a = 300,
        elapsed: l = 0,
        ease: c
    } = r;
    if (r.type === "spring" || !rW(r.ease)) {
        if (r.repeat === 1 / 0) return;
        const h = tg({
            ...r,
            elapsed: 0
        });
        let p = {
            done: !1,
            value: o[0]
        };
        const m = [];
        let v = 0;
        for (; !p.done && v < 2e4;) p = h.sample(v), m.push(p.value), v += Vp;
        o = m, a = v - Vp, c = "linear"
    }
    const d = oW(n.owner.current, e, o, {
        ...r,
        delay: -l,
        duration: a,
        ease: c
    });
    return d.onfinish = () => {
        n.set(aW(o, r)), ci.update(() => d.cancel()), i && i()
    }, {
        get currentTime() {
            return d.currentTime || 0
        },
        set currentTime(h) {
            d.currentTime = h
        },
        stop: () => {
            const {
                currentTime: h
            } = d;
            if (h) {
                const p = tg({
                    ...r,
                    autoplay: !1
                });
                n.setWithVelocity(p.sample(h - Vp).value, p.sample(h).value, Vp)
            }
            ci.update(() => d.cancel())
        }
    }
}

function tI(n, e) {
    const t = performance.now(),
        i = ({
            timestamp: r
        }) => {
            const s = r - t;
            s >= e && (jo.read(i), n(s - e))
        };
    return ci.read(i, !0), () => jo.read(i)
}

function cW({
    keyframes: n,
    elapsed: e,
    onUpdate: t,
    onComplete: i
}) {
    const r = () => {
        t && t(n[n.length - 1]), i && i()
    };
    return e ? {
        stop: tI(r, -e)
    } : r()
}

function fW({
    keyframes: n,
    velocity: e = 0,
    min: t,
    max: i,
    power: r = .8,
    timeConstant: s = 750,
    bounceStiffness: o = 500,
    bounceDamping: a = 10,
    restDelta: l = 1,
    modifyTarget: c,
    driver: d,
    onUpdate: h,
    onComplete: p,
    onStop: m
}) {
    const v = n[0];
    let y;

    function A(M) {
        return t !== void 0 && M < t || i !== void 0 && M > i
    }

    function x(M) {
        return t === void 0 ? i : i === void 0 || Math.abs(t - M) < Math.abs(i - M) ? t : i
    }

    function _(M) {
        y && y.stop(), y = tg({
            keyframes: [0, 1],
            velocity: 0,
            ...M,
            driver: d,
            onUpdate: b => {
                h && h(b), M.onUpdate && M.onUpdate(b)
            },
            onComplete: p,
            onStop: m
        })
    }

    function S(M) {
        _({
            type: "spring",
            stiffness: o,
            damping: a,
            restDelta: l,
            ...M
        })
    }
    if (A(v)) S({
        velocity: e,
        keyframes: [v, x(v)]
    });
    else {
        let M = r * e + v;
        typeof c < "u" && (M = c(M));
        const b = x(M),
            B = b === t ? -1 : 1;
        let R, E;
        const P = I => {
            R = E, E = I, e = sw(I - R, Os.delta), (B === 1 && I > b || B === -1 && I < b) && S({
                keyframes: [I, b],
                velocity: e
            })
        };
        _({
            type: "decay",
            keyframes: [v, 0],
            velocity: e,
            timeConstant: s,
            power: r,
            restDelta: l,
            modifyTarget: c,
            onUpdate: A(M) ? P : void 0
        })
    }
    return {
        stop: () => y && y.stop()
    }
}
const dW = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
    },
    hW = n => ({
        type: "spring",
        stiffness: 550,
        damping: n === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    }),
    pW = {
        type: "keyframes",
        duration: .8
    },
    mW = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    },
    gW = (n, {
        keyframes: e
    }) => e.length > 2 ? pW : hl.has(n) ? n.startsWith("scale") ? hW(e[1]) : dW : mW,
    Ox = (n, e) => n === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && Jo.test(e) && !e.startsWith("url("));

function yW({
    when: n,
    delay: e,
    delayChildren: t,
    staggerChildren: i,
    staggerDirection: r,
    repeat: s,
    repeatType: o,
    repeatDelay: a,
    from: l,
    elapsed: c,
    ...d
}) {
    return !!Object.keys(d).length
}

function Tb(n) {
    return n === 0 || typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1
}

function Bb(n) {
    return typeof n == "number" ? 0 : lw("", n)
}

function nI(n, e) {
    return n[e] || n.default || n
}

function vW(n, e, t, i) {
    const r = Ox(e, t);
    let s = i.from !== void 0 ? i.from : n.get();
    return s === "none" && r && typeof t == "string" ? s = lw(e, t) : Tb(s) && typeof t == "string" ? s = Bb(t) : !Array.isArray(t) && Tb(t) && typeof s == "string" && (t = Bb(s)), Array.isArray(t) ? (t[0] === null && (t[0] = s), t) : [s, t]
}
const mw = (n, e, t, i = {}) => r => {
    const s = nI(i, n) || {},
        o = s.delay || i.delay || 0;
    let {
        elapsed: a = 0
    } = i;
    a = a - mm(o);
    const l = vW(e, n, t, s),
        c = l[0],
        d = l[l.length - 1],
        h = Ox(n, c),
        p = Ox(n, d);
    let m = {
        keyframes: l,
        velocity: e.getVelocity(),
        ...s,
        elapsed: a,
        onUpdate: v => {
            e.set(v), s.onUpdate && s.onUpdate(v)
        },
        onComplete: () => {
            r(), s.onComplete && s.onComplete()
        }
    };
    if (!h || !p || w6.current || s.type === !1) return cW(m);
    if (s.type === "inertia") return fW(m);
    if (yW(s) || (m = {
            ...m,
            ...gW(n, m)
        }), m.duration && (m.duration = mm(m.duration)), m.repeatDelay && (m.repeatDelay = mm(m.repeatDelay)), e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
        const v = uW(e, n, m);
        if (v) return v
    }
    return tg(m)
};

function AW(n, e, t = {}) {
    n.notify("AnimationStart", e);
    let i;
    if (Array.isArray(e)) {
        const r = e.map(s => Ux(n, s, t));
        i = Promise.all(r)
    } else if (typeof e == "string") i = Ux(n, e, t);
    else {
        const r = typeof e == "function" ? Xg(n, e, t.custom) : e;
        i = iI(n, r, t)
    }
    return i.then(() => n.notify("AnimationComplete", e))
}

function Ux(n, e, t = {}) {
    const i = Xg(n, e, t.custom);
    let {
        transition: r = n.getDefaultTransition() || {}
    } = i || {};
    t.transitionOverride && (r = t.transitionOverride);
    const s = i ? () => iI(n, i, t) : () => Promise.resolve(),
        o = n.variantChildren && n.variantChildren.size ? (l = 0) => {
            const {
                delayChildren: c = 0,
                staggerChildren: d,
                staggerDirection: h
            } = r;
            return xW(n, e, c + l, d, h, t)
        } : () => Promise.resolve(),
        {
            when: a
        } = r;
    if (a) {
        const [l, c] = a === "beforeChildren" ? [s, o] : [o, s];
        return l().then(c)
    } else return Promise.all([s(), o(t.delay)])
}

function iI(n, e, {
    delay: t = 0,
    transitionOverride: i,
    type: r
} = {}) {
    let {
        transition: s = n.getDefaultTransition(),
        transitionEnd: o,
        ...a
    } = n.makeTargetAnimatable(e);
    const l = n.getValue("willChange");
    i && (s = i);
    const c = [],
        d = r && n.animationState && n.animationState.getState()[r];
    for (const h in a) {
        const p = n.getValue(h),
            m = a[h];
        if (!p || m === void 0 || d && wW(d, h)) continue;
        const v = {
            delay: t,
            elapsed: 0,
            ...s
        };
        if (window.HandoffAppearAnimations && !p.hasAnimated) {
            const A = n.getProps()[x6];
            A && (v.elapsed = window.HandoffAppearAnimations(A, h, p, ci))
        }
        let y = p.start(mw(h, p, m, n.shouldReduceMotion && hl.has(h) ? {
            type: !1
        } : v));
        $m(l) && (l.add(h), y = y.then(() => l.remove(h))), c.push(y)
    }
    return Promise.all(c).then(() => {
        o && m6(n, o)
    })
}

function xW(n, e, t = 0, i = 0, r = 1, s) {
    const o = [],
        a = (n.variantChildren.size - 1) * i,
        l = r === 1 ? (c = 0) => c * i : (c = 0) => a - c * i;
    return Array.from(n.variantChildren).sort(_W).forEach((c, d) => {
        c.notify("AnimationStart", e), o.push(Ux(c, e, {
            ...s,
            delay: t + l(d)
        }).then(() => c.notify("AnimationComplete", e)))
    }), Promise.all(o)
}

function _W(n, e) {
    return n.sortNodePosition(e)
}

function wW({
    protectedKeys: n,
    needsAnimating: e
}, t) {
    const i = n.hasOwnProperty(t) && e[t] !== !0;
    return e[t] = !1, i
}
const SW = [...J_].reverse(),
    MW = J_.length;

function CW(n) {
    return e => Promise.all(e.map(({
        animation: t,
        options: i
    }) => AW(n, t, i)))
}

function EW(n) {
    let e = CW(n);
    const t = TW();
    let i = !0;
    const r = (l, c) => {
        const d = Xg(n, c);
        if (d) {
            const {
                transition: h,
                transitionEnd: p,
                ...m
            } = d;
            l = {
                ...l,
                ...m,
                ...p
            }
        }
        return l
    };

    function s(l) {
        e = l(n)
    }

    function o(l, c) {
        const d = n.getProps(),
            h = n.getVariantContext(!0) || {},
            p = [],
            m = new Set;
        let v = {},
            y = 1 / 0;
        for (let x = 0; x < MW; x++) {
            const _ = SW[x],
                S = t[_],
                M = d[_] !== void 0 ? d[_] : h[_],
                b = rd(M),
                B = _ === c ? S.isActive : null;
            B === !1 && (y = x);
            let R = M === h[_] && M !== d[_] && b;
            if (R && i && n.manuallyAnimateOnMount && (R = !1), S.protectedKeys = {
                    ...v
                }, !S.isActive && B === null || !M && !S.prevProp || Hg(M) || typeof M == "boolean") continue;
            const E = bW(S.prevProp, M);
            let P = E || _ === c && S.isActive && !R && b || x > y && b;
            const I = Array.isArray(M) ? M : [M];
            let z = I.reduce(r, {});
            B === !1 && (z = {});
            const {
                prevResolvedValues: Z = {}
            } = S, W = {
                ...Z,
                ...z
            }, G = K => {
                P = !0, m.delete(K), S.needsAnimating[K] = !0
            };
            for (const K in W) {
                const te = z[K],
                    se = Z[K];
                v.hasOwnProperty(K) || (te !== se ? Zm(te) && Zm(se) ? !RR(te, se) || E ? G(K) : S.protectedKeys[K] = !0 : te !== void 0 ? G(K) : m.add(K) : te !== void 0 && m.has(K) ? G(K) : S.protectedKeys[K] = !0)
            }
            S.prevProp = M, S.prevResolvedValues = z, S.isActive && (v = {
                ...v,
                ...z
            }), i && n.blockInitialAnimation && (P = !1), P && !R && p.push(...I.map(K => ({
                animation: K,
                options: {
                    type: _,
                    ...l
                }
            })))
        }
        if (m.size) {
            const x = {};
            m.forEach(_ => {
                const S = n.getBaseTarget(_);
                S !== void 0 && (x[_] = S)
            }), p.push({
                animation: x
            })
        }
        let A = Boolean(p.length);
        return i && d.initial === !1 && !n.manuallyAnimateOnMount && (A = !1), i = !1, A ? e(p) : Promise.resolve()
    }

    function a(l, c, d) {
        var h;
        if (t[l].isActive === c) return Promise.resolve();
        (h = n.variantChildren) === null || h === void 0 || h.forEach(m => {
            var v;
            return (v = m.animationState) === null || v === void 0 ? void 0 : v.setActive(l, c)
        }), t[l].isActive = c;
        const p = o(d, l);
        for (const m in t) t[m].protectedKeys = {};
        return p
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: () => t
    }
}

function bW(n, e) {
    return typeof e == "string" ? e !== n : Array.isArray(e) ? !RR(e, n) : !1
}

function _a(n = !1) {
    return {
        isActive: n,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}

function TW() {
    return {
        animate: _a(!0),
        whileInView: _a(),
        whileHover: _a(),
        whileTap: _a(),
        whileDrag: _a(),
        whileFocus: _a(),
        exit: _a()
    }
}
class BW extends ta {
    constructor(e) {
        super(e), e.animationState || (e.animationState = EW(e))
    }
    updateAnimationControlsSubscription() {
        const {
            animate: e
        } = this.node.getProps();
        this.unmount(), Hg(e) && (this.unmount = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {
            animate: e
        } = this.node.getProps(), {
            animate: t
        } = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let PW = 0;
class RW extends ta {
    constructor() {
        super(...arguments), this.id = PW++
    }
    update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: e,
            onExitComplete: t,
            custom: i
        } = this.node.presenceContext, {
            isPresent: r
        } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === r) return;
        const s = this.node.animationState.setActive("exit", !e, {
            custom: i ?? this.node.getProps().custom
        });
        t && !e && s.then(() => t(this.id))
    }
    mount() {
        const {
            register: e
        } = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const IW = {
        animation: {
            Feature: BW
        },
        exit: {
            Feature: RW
        }
    },
    Pb = (n, e) => Math.abs(n - e);

function LW(n, e) {
    const t = Pb(n.x, e.x),
        i = Pb(n.y, e.y);
    return Math.sqrt(t ** 2 + i ** 2)
}
class rI {
    constructor(e, t, {
        transformPagePoint: i
    } = {}) {
        if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const c = Pv(this.lastMoveEventInfo, this.history),
                    d = this.startEvent !== null,
                    h = LW(c.offset, {
                        x: 0,
                        y: 0
                    }) >= 3;
                if (!d && !h) return;
                const {
                    point: p
                } = c, {
                    timestamp: m
                } = Os;
                this.history.push({
                    ...p,
                    timestamp: m
                });
                const {
                    onStart: v,
                    onMove: y
                } = this.handlers;
                d || (v && v(this.lastMoveEvent, c), this.startEvent = this.lastMoveEvent), y && y(this.lastMoveEvent, c)
            }, this.handlePointerMove = (c, d) => {
                this.lastMoveEvent = c, this.lastMoveEventInfo = Bv(d, this.transformPagePoint), ci.update(this.updatePoint, !0)
            }, this.handlePointerUp = (c, d) => {
                if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const {
                    onEnd: h,
                    onSessionEnd: p
                } = this.handlers, m = Pv(c.type === "pointercancel" ? this.lastMoveEventInfo : Bv(d, this.transformPagePoint), this.history);
                this.startEvent && h && h(c, m), p && p(c, m)
            }, !ER(e)) return;
        this.handlers = t, this.transformPagePoint = i;
        const r = jg(e),
            s = Bv(r, this.transformPagePoint),
            {
                point: o
            } = s,
            {
                timestamp: a
            } = Os;
        this.history = [{
            ...o,
            timestamp: a
        }];
        const {
            onSessionStart: l
        } = t;
        l && l(e, Pv(s, this.history)), this.removeListeners = No(Ns(window, "pointermove", this.handlePointerMove), Ns(window, "pointerup", this.handlePointerUp), Ns(window, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(), jo.update(this.updatePoint)
    }
}

function Bv(n, e) {
    return e ? {
        point: e(n.point)
    } : n
}

function Rb(n, e) {
    return {
        x: n.x - e.x,
        y: n.y - e.y
    }
}

function Pv({
    point: n
}, e) {
    return {
        point: n,
        delta: Rb(n, sI(e)),
        offset: Rb(n, DW(e)),
        velocity: FW(e, .1)
    }
}

function DW(n) {
    return n[0]
}

function sI(n) {
    return n[n.length - 1]
}

function FW(n, e) {
    if (n.length < 2) return {
        x: 0,
        y: 0
    };
    let t = n.length - 1,
        i = null;
    const r = sI(n);
    for (; t >= 0 && (i = n[t], !(r.timestamp - i.timestamp > mm(e)));) t--;
    if (!i) return {
        x: 0,
        y: 0
    };
    const s = (r.timestamp - i.timestamp) / 1e3;
    if (s === 0) return {
        x: 0,
        y: 0
    };
    const o = {
        x: (r.x - i.x) / s,
        y: (r.y - i.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}

function Hi(n) {
    return n.max - n.min
}

function zx(n, e = 0, t = .01) {
    return Math.abs(n - e) <= t
}

function Ib(n, e, t, i = .5) {
    n.origin = i, n.originPoint = nn(e.min, e.max, n.origin), n.scale = Hi(t) / Hi(e), (zx(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1), n.translate = nn(t.min, t.max, n.origin) - n.originPoint, (zx(n.translate) || isNaN(n.translate)) && (n.translate = 0)
}

function _f(n, e, t, i) {
    Ib(n.x, e.x, t.x, i ? i.originX : void 0), Ib(n.y, e.y, t.y, i ? i.originY : void 0)
}

function Lb(n, e, t) {
    n.min = t.min + e.min, n.max = n.min + Hi(e)
}

function kW(n, e, t) {
    Lb(n.x, e.x, t.x), Lb(n.y, e.y, t.y)
}

function Db(n, e, t) {
    n.min = e.min - t.min, n.max = n.min + Hi(e)
}

function wf(n, e, t) {
    Db(n.x, e.x, t.x), Db(n.y, e.y, t.y)
}

function NW(n, {
    min: e,
    max: t
}, i) {
    return e !== void 0 && n < e ? n = i ? nn(e, n, i.min) : Math.max(n, e) : t !== void 0 && n > t && (n = i ? nn(t, n, i.max) : Math.min(n, t)), n
}

function Fb(n, e, t) {
    return {
        min: e !== void 0 ? n.min + e : void 0,
        max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0
    }
}

function OW(n, {
    top: e,
    left: t,
    bottom: i,
    right: r
}) {
    return {
        x: Fb(n.x, t, r),
        y: Fb(n.y, e, i)
    }
}

function kb(n, e) {
    let t = e.min - n.min,
        i = e.max - n.max;
    return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), {
        min: t,
        max: i
    }
}

function UW(n, e) {
    return {
        x: kb(n.x, e.x),
        y: kb(n.y, e.y)
    }
}

function zW(n, e) {
    let t = .5;
    const i = Hi(n),
        r = Hi(e);
    return r > i ? t = ld(e.min, e.max - i, n.min) : i > r && (t = ld(n.min, n.max - r, e.min)), Gu(0, 1, t)
}

function GW(n, e) {
    const t = {};
    return e.min !== void 0 && (t.min = e.min - n.min), e.max !== void 0 && (t.max = e.max - n.min), t
}
const Gx = .35;

function HW(n = Gx) {
    return n === !1 ? n = 0 : n === !0 && (n = Gx), {
        x: Nb(n, "left", "right"),
        y: Nb(n, "top", "bottom")
    }
}

function Nb(n, e, t) {
    return {
        min: Ob(n, e),
        max: Ob(n, t)
    }
}

function Ob(n, e) {
    return typeof n == "number" ? n : n[e] || 0
}
const Ub = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }),
    Sf = () => ({
        x: Ub(),
        y: Ub()
    }),
    zb = () => ({
        min: 0,
        max: 0
    }),
    xn = () => ({
        x: zb(),
        y: zb()
    });

function Zr(n) {
    return [n("x"), n("y")]
}

function oI({
    top: n,
    left: e,
    right: t,
    bottom: i
}) {
    return {
        x: {
            min: e,
            max: t
        },
        y: {
            min: n,
            max: i
        }
    }
}

function VW({
    x: n,
    y: e
}) {
    return {
        top: e.min,
        right: n.max,
        bottom: e.max,
        left: n.min
    }
}

function WW(n, e) {
    if (!e) return n;
    const t = e({
            x: n.left,
            y: n.top
        }),
        i = e({
            x: n.right,
            y: n.bottom
        });
    return {
        top: t.y,
        left: t.x,
        bottom: i.y,
        right: i.x
    }
}

function Rv(n) {
    return n === void 0 || n === 1
}

function Hx({
    scale: n,
    scaleX: e,
    scaleY: t
}) {
    return !Rv(n) || !Rv(e) || !Rv(t)
}

function Ta(n) {
    return Hx(n) || aI(n) || n.z || n.rotate || n.rotateX || n.rotateY
}

function aI(n) {
    return Gb(n.x) || Gb(n.y)
}

function Gb(n) {
    return n && n !== "0%"
}

function ng(n, e, t) {
    const i = n - t,
        r = e * i;
    return t + r
}

function Hb(n, e, t, i, r) {
    return r !== void 0 && (n = ng(n, r, i)), ng(n, t, i) + e
}

function Vx(n, e = 0, t = 1, i, r) {
    n.min = Hb(n.min, e, t, i, r), n.max = Hb(n.max, e, t, i, r)
}

function lI(n, {
    x: e,
    y: t
}) {
    Vx(n.x, e.translate, e.scale, e.originPoint), Vx(n.y, t.translate, t.scale, t.originPoint)
}

function jW(n, e, t, i = !1) {
    const r = t.length;
    if (!r) return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < r; a++) {
        s = t[a], o = s.projectionDelta;
        const l = s.instance;
        l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && pu(n, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }), o && (e.x *= o.x.scale, e.y *= o.y.scale, lI(n, o)), i && Ta(s.latestValues) && pu(n, s.latestValues))
    }
    e.x = Vb(e.x), e.y = Vb(e.y)
}

function Vb(n) {
    return Number.isInteger(n) || n > 1.0000000000001 || n < .999999999999 ? n : 1
}

function Ao(n, e) {
    n.min = n.min + e, n.max = n.max + e
}

function Wb(n, e, [t, i, r]) {
    const s = e[r] !== void 0 ? e[r] : .5,
        o = nn(n.min, n.max, s);
    Vx(n, e[t], e[i], o, e.scale)
}
const JW = ["x", "scaleX", "originX"],
    XW = ["y", "scaleY", "originY"];

function pu(n, e) {
    Wb(n.x, e, JW), Wb(n.y, e, XW)
}

function uI(n, e) {
    return oI(WW(n.getBoundingClientRect(), e))
}

function QW(n, e, t) {
    const i = uI(n, t),
        {
            scroll: r
        } = e;
    return r && (Ao(i.x, r.offset.x), Ao(i.y, r.offset.y)), i
}
const KW = new WeakMap;
class YW {
    constructor(e) {
        this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
        }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = xn(), this.visualElement = e
    }
    start(e, {
        snapToCursor: t = !1
    } = {}) {
        const {
            presenceContext: i
        } = this.visualElement;
        if (i && i.isPresent === !1) return;
        const r = l => {
                this.stopAnimation(), t && this.snapToCursor(jg(l, "page").point)
            },
            s = (l, c) => {
                const {
                    drag: d,
                    dragPropagation: h,
                    onDragStart: p
                } = this.getProps();
                if (d && !h && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = TR(d), !this.openGlobalLock)) return;
                this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Zr(v => {
                    let y = this.getAxisMotionValue(v).get() || 0;
                    if (is.test(y)) {
                        const {
                            projection: A
                        } = this.visualElement;
                        if (A && A.layout) {
                            const x = A.layout.layoutBox[v];
                            x && (y = Hi(x) * (parseFloat(y) / 100))
                        }
                    }
                    this.originPoint[v] = y
                }), p && p(l, c);
                const {
                    animationState: m
                } = this.visualElement;
                m && m.setActive("whileDrag", !0)
            },
            o = (l, c) => {
                const {
                    dragPropagation: d,
                    dragDirectionLock: h,
                    onDirectionLock: p,
                    onDrag: m
                } = this.getProps();
                if (!d && !this.openGlobalLock) return;
                const {
                    offset: v
                } = c;
                if (h && this.currentDirection === null) {
                    this.currentDirection = ZW(v), this.currentDirection !== null && p && p(this.currentDirection);
                    return
                }
                this.updateAxis("x", c.point, v), this.updateAxis("y", c.point, v), this.visualElement.render(), m && m(l, c)
            },
            a = (l, c) => this.stop(l, c);
        this.panSession = new rI(e, {
            onSessionStart: r,
            onStart: s,
            onMove: o,
            onSessionEnd: a
        }, {
            transformPagePoint: this.visualElement.getTransformPagePoint()
        })
    }
    stop(e, t) {
        const i = this.isDragging;
        if (this.cancel(), !i) return;
        const {
            velocity: r
        } = t;
        this.startAnimation(r);
        const {
            onDragEnd: s
        } = this.getProps();
        s && s(e, t)
    }
    cancel() {
        this.isDragging = !1;
        const {
            projection: e,
            animationState: t
        } = this.visualElement;
        e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
        const {
            dragPropagation: i
        } = this.getProps();
        !i && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1)
    }
    updateAxis(e, t, i) {
        const {
            drag: r
        } = this.getProps();
        if (!i || !Wp(e, r, this.currentDirection)) return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + i[e];
        this.constraints && this.constraints[e] && (o = NW(o, this.constraints[e], this.elastic[e])), s.set(o)
    }
    resolveConstraints() {
        const {
            dragConstraints: e,
            dragElastic: t
        } = this.getProps(), {
            layout: i
        } = this.visualElement.projection || {}, r = this.constraints;
        e && du(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = OW(i.layoutBox, e) : this.constraints = !1, this.elastic = HW(t), r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Zr(s => {
            this.getAxisMotionValue(s) && (this.constraints[s] = GW(i.layoutBox[s], this.constraints[s]))
        })
    }
    resolveRefConstraints() {
        const {
            dragConstraints: e,
            onMeasureDragConstraints: t
        } = this.getProps();
        if (!e || !du(e)) return !1;
        const i = e.current,
            {
                projection: r
            } = this.visualElement;
        if (!r || !r.layout) return !1;
        const s = QW(i, r.root, this.visualElement.getTransformPagePoint());
        let o = UW(r.layout.layoutBox, s);
        if (t) {
            const a = t(VW(o));
            this.hasMutatedConstraints = !!a, a && (o = oI(a))
        }
        return o
    }
    startAnimation(e) {
        const {
            drag: t,
            dragMomentum: i,
            dragElastic: r,
            dragTransition: s,
            dragSnapToOrigin: o,
            onDragTransitionEnd: a
        } = this.getProps(), l = this.constraints || {}, c = Zr(d => {
            if (!Wp(d, t, this.currentDirection)) return;
            let h = l && l[d] || {};
            o && (h = {
                min: 0,
                max: 0
            });
            const p = r ? 200 : 1e6,
                m = r ? 40 : 1e7,
                v = {
                    type: "inertia",
                    velocity: i ? e[d] : 0,
                    bounceStiffness: p,
                    bounceDamping: m,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10,
                    ...s,
                    ...h
                };
            return this.startAxisValueAnimation(d, v)
        });
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, t) {
        const i = this.getAxisMotionValue(e);
        return i.start(mw(e, i, 0, t))
    }
    stopAnimation() {
        Zr(e => this.getAxisMotionValue(e).stop())
    }
    getAxisMotionValue(e) {
        const t = "_drag" + e.toUpperCase(),
            i = this.visualElement.getProps(),
            r = i[t];
        return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        Zr(t => {
            const {
                drag: i
            } = this.getProps();
            if (!Wp(t, i, this.currentDirection)) return;
            const {
                projection: r
            } = this.visualElement, s = this.getAxisMotionValue(t);
            if (r && r.layout) {
                const {
                    min: o,
                    max: a
                } = r.layout.layoutBox[t];
                s.set(e[t] - nn(o, a, .5))
            }
        })
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const {
            drag: e,
            dragConstraints: t
        } = this.getProps(), {
            projection: i
        } = this.visualElement;
        if (!du(t) || !i || !this.constraints) return;
        this.stopAnimation();
        const r = {
            x: 0,
            y: 0
        };
        Zr(o => {
            const a = this.getAxisMotionValue(o);
            if (a) {
                const l = a.get();
                r[o] = zW({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        });
        const {
            transformTemplate: s
        } = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), Zr(o => {
            if (!Wp(o, e, null)) return;
            const a = this.getAxisMotionValue(o),
                {
                    min: l,
                    max: c
                } = this.constraints[o];
            a.set(nn(l, c, r[o]))
        })
    }
    addListeners() {
        if (!this.visualElement.current) return;
        KW.set(this.visualElement, this);
        const e = this.visualElement.current,
            t = Ns(e, "pointerdown", l => {
                const {
                    drag: c,
                    dragListener: d = !0
                } = this.getProps();
                c && d && this.start(l)
            }),
            i = () => {
                const {
                    dragConstraints: l
                } = this.getProps();
                du(l) && (this.constraints = this.resolveRefConstraints())
            },
            {
                projection: r
            } = this.visualElement,
            s = r.addEventListener("measure", i);
        r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i();
        const o = Ds(window, "resize", () => this.scalePositionWithinConstraints()),
            a = r.addEventListener("didUpdate", ({
                delta: l,
                hasLayoutChanged: c
            }) => {
                this.isDragging && c && (Zr(d => {
                    const h = this.getAxisMotionValue(d);
                    h && (this.originPoint[d] += l[d].translate, h.set(h.get() + l[d].translate))
                }), this.visualElement.render())
            });
        return () => {
            o(), t(), s(), a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps(),
            {
                drag: t = !1,
                dragDirectionLock: i = !1,
                dragPropagation: r = !1,
                dragConstraints: s = !1,
                dragElastic: o = Gx,
                dragMomentum: a = !0
            } = e;
        return {
            ...e,
            drag: t,
            dragDirectionLock: i,
            dragPropagation: r,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}

function Wp(n, e, t) {
    return (e === !0 || e === n) && (t === null || t === n)
}

function ZW(n, e = 10) {
    let t = null;
    return Math.abs(n.y) > e ? t = "y" : Math.abs(n.x) > e && (t = "x"), t
}
class qW extends ta {
    constructor(e) {
        super(e), this.removeGroupControls = hr, this.removeListeners = hr, this.controls = new YW(e)
    }
    mount() {
        const {
            dragControls: e
        } = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || hr
    }
    unmount() {
        this.removeGroupControls(), this.removeListeners()
    }
}
class $W extends ta {
    constructor() {
        super(...arguments), this.removePointerDownListener = hr
    }
    onPointerDown(e) {
        this.session = new rI(e, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint()
        })
    }
    createPanHandlers() {
        const {
            onPanSessionStart: e,
            onPanStart: t,
            onPan: i,
            onPanEnd: r
        } = this.node.getProps();
        return {
            onSessionStart: e,
            onStart: t,
            onMove: i,
            onEnd: (s, o) => {
                delete this.session, r && r(s, o)
            }
        }
    }
    mount() {
        this.removePointerDownListener = Ns(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(), this.session && this.session.end()
    }
}

function e7() {
    const n = U.useContext(j_);
    if (n === null) return [!0, null];
    const {
        isPresent: e,
        onExitComplete: t,
        register: i
    } = n, r = U.useId();
    return U.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0]
}

function jb(n, e) {
    return e.max === e.min ? 0 : n / (e.max - e.min) * 100
}
const Yc = {
        correct: (n, e) => {
            if (!e.target) return n;
            if (typeof n == "string")
                if (nt.test(n)) n = parseFloat(n);
                else return n;
            const t = jb(n, e.target.x),
                i = jb(n, e.target.y);
            return `${t}% ${i}%`
        }
    },
    cI = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;

function t7(n) {
    const e = cI.exec(n);
    if (!e) return [, ];
    const [, t, i] = e;
    return [t, i]
}

function Wx(n, e, t = 1) {
    const [i, r] = t7(n);
    if (!i) return;
    const s = window.getComputedStyle(e).getPropertyValue(i);
    return s ? s.trim() : Bx(r) ? Wx(r, e, t + 1) : r
}

function n7(n, {
    ...e
}, t) {
    const i = n.current;
    if (!(i instanceof Element)) return {
        target: e,
        transitionEnd: t
    };
    t && (t = {
        ...t
    }), n.values.forEach(r => {
        const s = r.get();
        if (!Bx(s)) return;
        const o = Wx(s, i);
        o && r.set(o)
    });
    for (const r in e) {
        const s = e[r];
        if (!Bx(s)) continue;
        const o = Wx(s, i);
        o && (e[r] = o, t && t[r] === void 0 && (t[r] = s))
    }
    return {
        target: e,
        transitionEnd: t
    }
}
const Jb = "_$css",
    i7 = {
        correct: (n, {
            treeScale: e,
            projectionDelta: t
        }) => {
            const i = n,
                r = n.includes("var("),
                s = [];
            r && (n = n.replace(cI, m => (s.push(m), Jb)));
            const o = Jo.parse(n);
            if (o.length > 5) return i;
            const a = Jo.createTransformer(n),
                l = typeof o[0] != "number" ? 1 : 0,
                c = t.x.scale * e.x,
                d = t.y.scale * e.y;
            o[0 + l] /= c, o[1 + l] /= d;
            const h = nn(c, d, .5);
            typeof o[2 + l] == "number" && (o[2 + l] /= h), typeof o[3 + l] == "number" && (o[3 + l] /= h);
            let p = a(o);
            if (r) {
                let m = 0;
                p = p.replace(Jb, () => {
                    const v = s[m];
                    return m++, v
                })
            }
            return p
        }
    };
class r7 extends ar.Component {
    componentDidMount() {
        const {
            visualElement: e,
            layoutGroup: t,
            switchLayoutGroup: i,
            layoutId: r
        } = this.props, {
            projection: s
        } = e;
        s8(s7), s && (t.group && t.group.add(s), i && i.register && r && i.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }), s.setOptions({
            ...s.options,
            onExitComplete: () => this.safeToRemove()
        })), vf.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {
            layoutDependency: t,
            visualElement: i,
            drag: r,
            isPresent: s
        } = this.props, o = i.projection;
        return o && (o.isPresent = s, r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || ci.postRender(() => {
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }))), null
    }
    componentDidUpdate() {
        const {
            projection: e
        } = this.props.visualElement;
        e && (e.root.didUpdate(), !e.currentAnimation && e.isLead() && this.safeToRemove())
    }
    componentWillUnmount() {
        const {
            visualElement: e,
            layoutGroup: t,
            switchLayoutGroup: i
        } = this.props, {
            projection: r
        } = e;
        r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), i && i.deregister && i.deregister(r))
    }
    safeToRemove() {
        const {
            safeToRemove: e
        } = this.props;
        e && e()
    }
    render() {
        return null
    }
}

function fI(n) {
    const [e, t] = e7(), i = U.useContext(dR);
    return ar.createElement(r7, {
        ...n,
        layoutGroup: i,
        switchLayoutGroup: U.useContext(hR),
        isPresent: e,
        safeToRemove: t
    })
}
const s7 = {
    borderRadius: {
        ...Yc,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: Yc,
    borderTopRightRadius: Yc,
    borderBottomLeftRadius: Yc,
    borderBottomRightRadius: Yc,
    boxShadow: i7
};

function o7(n, e, t = {}) {
    const i = Ei(n) ? n : Hu(n);
    return i.start(mw("", i, e, t)), {
        stop: () => i.stop(),
        isAnimating: () => i.isAnimating()
    }
}
const dI = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    a7 = dI.length,
    Xb = n => typeof n == "string" ? parseFloat(n) : n,
    Qb = n => typeof n == "number" || nt.test(n);

function l7(n, e, t, i, r, s) {
    r ? (n.opacity = nn(0, t.opacity !== void 0 ? t.opacity : 1, u7(i)), n.opacityExit = nn(e.opacity !== void 0 ? e.opacity : 1, 0, c7(i))) : s && (n.opacity = nn(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, i));
    for (let o = 0; o < a7; o++) {
        const a = `border${dI[o]}Radius`;
        let l = Kb(e, a),
            c = Kb(t, a);
        if (l === void 0 && c === void 0) continue;
        l || (l = 0), c || (c = 0), l === 0 || c === 0 || Qb(l) === Qb(c) ? (n[a] = Math.max(nn(Xb(l), Xb(c), i), 0), (is.test(c) || is.test(l)) && (n[a] += "%")) : n[a] = c
    }(e.rotate || t.rotate) && (n.rotate = nn(e.rotate || 0, t.rotate || 0, i))
}

function Kb(n, e) {
    return n[e] !== void 0 ? n[e] : n.borderRadius
}
const u7 = hI(0, .5, hw),
    c7 = hI(.5, .95, hr);

function hI(n, e, t) {
    return i => i < n ? 0 : i > e ? 1 : t(ld(n, e, i))
}

function Yb(n, e) {
    n.min = e.min, n.max = e.max
}

function sr(n, e) {
    Yb(n.x, e.x), Yb(n.y, e.y)
}

function Zb(n, e, t, i, r) {
    return n -= e, n = ng(n, 1 / t, i), r !== void 0 && (n = ng(n, 1 / r, i)), n
}

function f7(n, e = 0, t = 1, i = .5, r, s = n, o = n) {
    if (is.test(e) && (e = parseFloat(e), e = nn(o.min, o.max, e / 100) - o.min), typeof e != "number") return;
    let a = nn(s.min, s.max, i);
    n === s && (a -= e), n.min = Zb(n.min, e, t, a, r), n.max = Zb(n.max, e, t, a, r)
}

function qb(n, e, [t, i, r], s, o) {
    f7(n, e[t], e[i], e[r], e.scale, s, o)
}
const d7 = ["x", "scaleX", "originX"],
    h7 = ["y", "scaleY", "originY"];

function $b(n, e, t, i) {
    qb(n.x, e, d7, t ? t.x : void 0, i ? i.x : void 0), qb(n.y, e, h7, t ? t.y : void 0, i ? i.y : void 0)
}

function eT(n) {
    return n.translate === 0 && n.scale === 1
}

function pI(n) {
    return eT(n.x) && eT(n.y)
}

function jx(n, e) {
    return n.x.min === e.x.min && n.x.max === e.x.max && n.y.min === e.y.min && n.y.max === e.y.max
}

function tT(n) {
    return Hi(n.x) / Hi(n.y)
}
class p7 {
    constructor() {
        this.members = []
    }
    add(e) {
        nw(this.members, e), e.scheduleRender()
    }
    remove(e) {
        if (iw(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            const t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        const t = this.members.findIndex(r => e === r);
        if (t === 0) return !1;
        let i;
        for (let r = t; r >= 0; r--) {
            const s = this.members[r];
            if (s.isPresent !== !1) {
                i = s;
                break
            }
        }
        return i ? (this.promote(i), !0) : !1
    }
    promote(e, t) {
        const i = this.lead;
        if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
            i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, t && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {
                crossfade: r
            } = e.options;
            r === !1 && i.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {
                options: t,
                resumingFrom: i
            } = e;
            t.onExitComplete && t.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete()
        })
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        })
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}

function nT(n, e, t) {
    let i = "";
    const r = n.x.translate / e.x,
        s = n.y.translate / e.y;
    if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `), (e.x !== 1 || e.y !== 1) && (i += `scale(${1/e.x}, ${1/e.y}) `), t) {
        const {
            rotate: l,
            rotateX: c,
            rotateY: d
        } = t;
        l && (i += `rotate(${l}deg) `), c && (i += `rotateX(${c}deg) `), d && (i += `rotateY(${d}deg) `)
    }
    const o = n.x.scale * e.x,
        a = n.y.scale * e.y;
    return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none"
}
const m7 = (n, e) => n.depth - e.depth;
class g7 {
    constructor() {
        this.children = [], this.isDirty = !1
    }
    add(e) {
        nw(this.children, e), this.isDirty = !0
    }
    remove(e) {
        iw(this.children, e), this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(m7), this.isDirty = !1, this.children.forEach(e)
    }
}

function y7(n) {
    window.MotionDebug && window.MotionDebug.record(n)
}
const iT = ["", "X", "Y", "Z"],
    rT = 1e3;
let v7 = 0;
const Ba = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};

function mI({
    attachResizeListener: n,
    defaultParent: e,
    measureScroll: t,
    checkIsScrollRoot: i,
    resetTransform: r
}) {
    return class {
        constructor(o, a = {}, l = e == null ? void 0 : e()) {
            this.id = v7++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {
                x: 1,
                y: 1
            }, this.eventHandlers = new Map, this.potentialNodes = new Map, this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
                Ba.totalNodes = Ba.resolvedTargetDeltas = Ba.recalculatedProjection = 0, this.nodes.forEach(_7), this.nodes.forEach(C7), this.nodes.forEach(E7), this.nodes.forEach(w7), y7(Ba)
            }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.elementId = o, this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0, o && this.root.registerPotentialNode(o, this);
            for (let c = 0; c < this.path.length; c++) this.path[c].shouldResetTransform = !0;
            this.root === this && (this.nodes = new g7)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new rw), this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        registerPotentialNode(o, a) {
            this.potentialNodes.set(o, a)
        }
        mount(o, a = !1) {
            if (this.instance) return;
            this.isSVG = o instanceof SVGElement && o.tagName !== "svg", this.instance = o;
            const {
                layoutId: l,
                layout: c,
                visualElement: d
            } = this.options;
            if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a && (c || l) && (this.isLayoutDirty = !0), n) {
                let h;
                const p = () => this.root.updateBlockedByResize = !1;
                n(o, () => {
                    this.root.updateBlockedByResize = !0, h && h(), h = tI(p, 250), vf.hasAnimatedSinceResize && (vf.hasAnimatedSinceResize = !1, this.nodes.forEach(oT))
                })
            }
            l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && d && (l || c) && this.addEventListener("didUpdate", ({
                delta: h,
                hasLayoutChanged: p,
                hasRelativeTargetChanged: m,
                layout: v
            }) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0, this.relativeTarget = void 0;
                    return
                }
                const y = this.options.transition || d.getDefaultTransition() || R7,
                    {
                        onLayoutAnimationStart: A,
                        onLayoutAnimationComplete: x
                    } = d.getProps(),
                    _ = !this.targetLayout || !jx(this.targetLayout, v) || m,
                    S = !p && m;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || S || p && (_ || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(h, S);
                    const M = {
                        ...nI(y, "layout"),
                        onPlay: A,
                        onComplete: x
                    };
                    (d.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M)
                } else !p && this.animationProgress === 0 && oT(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = v
            })
        }
        unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, jo.preRender(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(b7), this.animationId++)
        }
        getTransformTemplate() {
            const {
                visualElement: o
            } = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o = !0) {
            if (this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let d = 0; d < this.path.length; d++) {
                const h = this.path[d];
                h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1)
            }
            const {
                layoutId: a,
                layout: l
            } = this.options;
            if (a === void 0 && !l) return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
        }
        didUpdate() {
            if (this.isUpdateBlocked()) {
                this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(sT);
                return
            }
            this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(I7), this.potentialNodes.clear()), this.nodes.forEach(M7), this.nodes.forEach(A7), this.nodes.forEach(x7), this.clearAllSnapshots(), Sv.update(), Sv.preRender(), Sv.render())
        }
        clearAllSnapshots() {
            this.nodes.forEach(S7), this.sharedNodes.forEach(T7)
        }
        scheduleUpdateProjection() {
            ci.preRender(this.updateProjection, !1, !0)
        }
        scheduleCheckAfterUnmount() {
            ci.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = xn(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {
                visualElement: a
            } = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o = "measure") {
            let a = Boolean(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && (this.scroll = {
                animationId: this.root.animationId,
                phase: o,
                isRoot: i(this.instance),
                offset: t(this.instance)
            })
        }
        resetTransform() {
            if (!r) return;
            const o = this.isLayoutDirty || this.shouldResetTransform,
                a = this.projectionDelta && !pI(this.projectionDelta),
                l = this.getTransformTemplate(),
                c = l ? l(this.latestValues, "") : void 0,
                d = c !== this.prevTransformTemplateValue;
            o && (a || Ta(this.latestValues) || d) && (r(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender())
        }
        measure(o = !0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)), L7(l), {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {
                visualElement: o
            } = this.options;
            if (!o) return xn();
            const a = o.measureViewportBox(),
                {
                    scroll: l
                } = this.root;
            return l && (Ao(a.x, l.offset.x), Ao(a.y, l.offset.y)), a
        }
        removeElementScroll(o) {
            const a = xn();
            sr(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l],
                    {
                        scroll: d,
                        options: h
                    } = c;
                if (c !== this.root && d && h.layoutScroll) {
                    if (d.isRoot) {
                        sr(a, o);
                        const {
                            scroll: p
                        } = this.root;
                        p && (Ao(a.x, -p.offset.x), Ao(a.y, -p.offset.y))
                    }
                    Ao(a.x, d.offset.x), Ao(a.y, d.offset.y)
                }
            }
            return a
        }
        applyTransform(o, a = !1) {
            const l = xn();
            sr(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const d = this.path[c];
                !a && d.options.layoutScroll && d.scroll && d !== d.root && pu(l, {
                    x: -d.scroll.offset.x,
                    y: -d.scroll.offset.y
                }), Ta(d.latestValues) && pu(l, d.latestValues)
            }
            return Ta(this.latestValues) && pu(l, this.latestValues), l
        }
        removeTransform(o) {
            const a = xn();
            sr(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !Ta(c.latestValues)) continue;
                Hx(c.latestValues) && c.updateSnapshot();
                const d = xn(),
                    h = c.measurePageBox();
                sr(d, h), $b(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, d)
            }
            return Ta(this.latestValues) && $b(a, this.latestValues), a
        }
        setTargetDelta(o) {
            this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = {
                ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
        }
        resolveTargetDelta() {
            var o;
            const a = this.getLead();
            if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty), !((Boolean(this.resumingFrom) || this !== a) && this.isSharedProjectionDirty || this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty || this.attemptToResolveRelativeTarget)) return;
            const {
                layout: d,
                layoutId: h
            } = this.options;
            if (!(!this.layout || !(d || h))) {
                if (!this.targetDelta && !this.relativeTarget) {
                    const p = this.getClosestProjectingParent();
                    p && p.layout ? (this.relativeParent = p, this.relativeTarget = xn(), this.relativeTargetOrigin = xn(), wf(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = xn(), this.targetWithTransforms = xn()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? kW(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : sr(this.target, this.layout.layoutBox), lI(this.target, this.targetDelta)) : sr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const p = this.getClosestProjectingParent();
                        p && Boolean(p.resumingFrom) === Boolean(this.resumingFrom) && !p.options.layoutScroll && p.target ? (this.relativeParent = p, this.relativeTarget = xn(), this.relativeTargetOrigin = xn(), wf(this.relativeTargetOrigin, this.target, p.target), sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    Ba.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || Hx(this.parent.latestValues) || aI(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead(),
                l = Boolean(this.resumingFrom) || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), c) return;
            const {
                layout: d,
                layoutId: h
            } = this.options;
            if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || h)) return;
            sr(this.layoutCorrected, this.layout.layoutBox), jW(this.layoutCorrected, this.treeScale, this.path, l);
            const {
                target: p
            } = a;
            if (!p) return;
            this.projectionDelta || (this.projectionDelta = Sf(), this.projectionDeltaWithTransform = Sf());
            const m = this.treeScale.x,
                v = this.treeScale.y,
                y = this.projectionTransform;
            _f(this.projectionDelta, this.layoutCorrected, p, this.latestValues), this.projectionTransform = nT(this.projectionDelta, this.treeScale), (this.projectionTransform !== y || this.treeScale.x !== m || this.treeScale.y !== v) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), Ba.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o = !0) {
            if (this.options.scheduleRender && this.options.scheduleRender(), o) {
                const a = this.getStack();
                a && a.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(o, a = !1) {
            const l = this.snapshot,
                c = l ? l.latestValues : {},
                d = {
                    ...this.latestValues
                },
                h = Sf();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
            const p = xn(),
                m = l ? l.source : void 0,
                v = this.layout ? this.layout.source : void 0,
                y = m !== v,
                A = this.getStack(),
                x = !A || A.members.length <= 1,
                _ = Boolean(y && !x && this.options.crossfade === !0 && !this.path.some(P7));
            this.animationProgress = 0;
            let S;
            this.mixTargetDelta = M => {
                const b = M / 1e3;
                aT(h.x, o.x, b), aT(h.y, o.y, b), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (wf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox), B7(this.relativeTarget, this.relativeTargetOrigin, p, b), S && jx(this.relativeTarget, S) && (this.isProjectionDirty = !1), S || (S = xn()), sr(S, this.relativeTarget)), y && (this.animationValues = d, l7(d, c, this.latestValues, b, _, x)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = b
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (jo.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ci.update(() => {
                vf.hasAnimatedSinceResize = !0, this.currentAnimation = o7(0, rT, {
                    ...o,
                    onUpdate: a => {
                        this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a)
                    },
                    onComplete: () => {
                        o.onComplete && o.onComplete(), this.completeAnimation()
                    }
                }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(rT), this.currentAnimation.stop()), this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {
                targetWithTransforms: a,
                target: l,
                layout: c,
                latestValues: d
            } = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && gI(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || xn();
                    const h = Hi(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min, l.x.max = l.x.min + h;
                    const p = Hi(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min, l.y.max = l.y.min + p
                }
                sr(a, l), pu(a, d), _f(this.projectionDeltaWithTransform, this.layoutCorrected, a, d)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new p7), this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {
                layoutId: a
            } = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {
                layoutId: a
            } = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {
                layoutId: o
            } = this.options;
            if (o) return this.root.sharedNodes.get(o)
        }
        promote({
            needsReset: o,
            transition: a,
            preserveFollowOpacity: l
        } = {}) {
            const c = this.getStack();
            c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetRotation() {
            const {
                visualElement: o
            } = this.options;
            if (!o) return;
            let a = !1;
            const {
                latestValues: l
            } = o;
            if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a) return;
            const c = {};
            for (let d = 0; d < iT.length; d++) {
                const h = "rotate" + iT[d];
                l[h] && (c[h] = l[h], o.setStaticValue(h, 0))
            }
            o.render();
            for (const d in c) o.setStaticValue(d, c[d]);
            o.scheduleRender()
        }
        getProjectionStyles(o = {}) {
            var a, l;
            const c = {};
            if (!this.instance || this.isSVG) return c;
            if (this.isVisible) c.visibility = "";
            else return {
                visibility: "hidden"
            };
            const d = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = pm(o.pointerEvents) || "", c.transform = d ? d(this.latestValues, "") : "none", c;
            const h = this.getLead();
            if (!this.projectionDelta || !this.layout || !h.target) {
                const y = {};
                return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = pm(o.pointerEvents) || ""), this.hasProjected && !Ta(this.latestValues) && (y.transform = d ? d({}, "") : "none", this.hasProjected = !1), y
            }
            const p = h.animationValues || h.latestValues;
            this.applyTransformsToTarget(), c.transform = nT(this.projectionDeltaWithTransform, this.treeScale, p), d && (c.transform = d(p, c.transform));
            const {
                x: m,
                y: v
            } = this.projectionDelta;
            c.transformOrigin = `${m.origin*100}% ${v.origin*100}% 0`, h.animationValues ? c.opacity = h === this ? (l = (a = p.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : c.opacity = h === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0;
            for (const y in Km) {
                if (p[y] === void 0) continue;
                const {
                    correct: A,
                    applyTo: x
                } = Km[y], _ = c.transform === "none" ? p[y] : A(p[y], h);
                if (x) {
                    const S = x.length;
                    for (let M = 0; M < S; M++) c[x[M]] = _
                } else c[y] = _
            }
            return this.options.layoutId && (c.pointerEvents = h === this ? pm(o.pointerEvents) || "" : "none"), c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o => {
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }), this.root.nodes.forEach(sT), this.root.sharedNodes.clear()
        }
    }
}

function A7(n) {
    n.updateLayout()
}

function x7(n) {
    var e;
    const t = ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || n.snapshot;
    if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
        const {
            layoutBox: i,
            measuredBox: r
        } = n.layout, {
            animationType: s
        } = n.options, o = t.source !== n.layout.source;
        s === "size" ? Zr(h => {
            const p = o ? t.measuredBox[h] : t.layoutBox[h],
                m = Hi(p);
            p.min = i[h].min, p.max = p.min + m
        }) : gI(s, t.layoutBox, i) && Zr(h => {
            const p = o ? t.measuredBox[h] : t.layoutBox[h],
                m = Hi(i[h]);
            p.max = p.min + m
        });
        const a = Sf();
        _f(a, i, t.layoutBox);
        const l = Sf();
        o ? _f(l, n.applyTransform(r, !0), t.measuredBox) : _f(l, i, t.layoutBox);
        const c = !pI(a);
        let d = !1;
        if (!n.resumeFrom) {
            const h = n.getClosestProjectingParent();
            if (h && !h.resumeFrom) {
                const {
                    snapshot: p,
                    layout: m
                } = h;
                if (p && m) {
                    const v = xn();
                    wf(v, t.layoutBox, p.layoutBox);
                    const y = xn();
                    wf(y, i, m.layoutBox), jx(v, y) || (d = !0), h.options.layoutRoot && (n.relativeTarget = y, n.relativeTargetOrigin = v, n.relativeParent = h)
                }
            }
        }
        n.notifyListeners("didUpdate", {
            layout: i,
            snapshot: t,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: d
        })
    } else if (n.isLead()) {
        const {
            onExitComplete: i
        } = n.options;
        i && i()
    }
    n.options.transition = void 0
}

function _7(n) {
    Ba.totalNodes++, n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = Boolean(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty))
}

function w7(n) {
    n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1
}

function S7(n) {
    n.clearSnapshot()
}

function sT(n) {
    n.clearMeasurements()
}

function M7(n) {
    const {
        visualElement: e
    } = n.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), n.resetTransform()
}

function oT(n) {
    n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0
}

function C7(n) {
    n.resolveTargetDelta()
}

function E7(n) {
    n.calcProjection()
}

function b7(n) {
    n.resetRotation()
}

function T7(n) {
    n.removeLeadSnapshot()
}

function aT(n, e, t) {
    n.translate = nn(e.translate, 0, t), n.scale = nn(e.scale, 1, t), n.origin = e.origin, n.originPoint = e.originPoint
}

function lT(n, e, t, i) {
    n.min = nn(e.min, t.min, i), n.max = nn(e.max, t.max, i)
}

function B7(n, e, t, i) {
    lT(n.x, e.x, t.x, i), lT(n.y, e.y, t.y, i)
}

function P7(n) {
    return n.animationValues && n.animationValues.opacityExit !== void 0
}
const R7 = {
    duration: .45,
    ease: [.4, 0, .1, 1]
};

function I7(n, e) {
    let t = n.root;
    for (let s = n.path.length - 1; s >= 0; s--)
        if (Boolean(n.path[s].instance)) {
            t = n.path[s];
            break
        } const r = (t && t !== n.root ? t.instance : document).querySelector(`[data-projection-id="${e}"]`);
    r && n.mount(r, !0)
}

function uT(n) {
    n.min = Math.round(n.min), n.max = Math.round(n.max)
}

function L7(n) {
    uT(n.x), uT(n.y)
}

function gI(n, e, t) {
    return n === "position" || n === "preserve-aspect" && !zx(tT(e), tT(t), .2)
}
const D7 = mI({
        attachResizeListener: (n, e) => Ds(n, "resize", e),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }),
    Iv = {
        current: void 0
    },
    yI = mI({
        measureScroll: n => ({
            x: n.scrollLeft,
            y: n.scrollTop
        }),
        defaultParent: () => {
            if (!Iv.current) {
                const n = new D7(0, {});
                n.mount(window), n.setOptions({
                    layoutScroll: !0
                }), Iv.current = n
            }
            return Iv.current
        },
        resetTransform: (n, e) => {
            n.style.transform = e !== void 0 ? e : "none"
        },
        checkIsScrollRoot: n => Boolean(window.getComputedStyle(n).position === "fixed")
    }),
    F7 = {
        pan: {
            Feature: $W
        },
        drag: {
            Feature: qW,
            ProjectionNode: yI,
            MeasureLayout: fI
        }
    },
    k7 = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]),
    vI = n => k7.has(n),
    N7 = n => Object.keys(n).some(vI),
    cT = n => n === pl || n === nt,
    fT = (n, e) => parseFloat(n.split(", ")[e]),
    dT = (n, e) => (t, {
        transform: i
    }) => {
        if (i === "none" || !i) return 0;
        const r = i.match(/^matrix3d\((.+)\)$/);
        if (r) return fT(r[1], e); {
            const s = i.match(/^matrix\((.+)\)$/);
            return s ? fT(s[1], n) : 0
        }
    },
    O7 = new Set(["x", "y", "z"]),
    U7 = Wg.filter(n => !O7.has(n));

function z7(n) {
    const e = [];
    return U7.forEach(t => {
        const i = n.getValue(t);
        i !== void 0 && (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0))
    }), e.length && n.render(), e
}
const hT = {
        width: ({
            x: n
        }, {
            paddingLeft: e = "0",
            paddingRight: t = "0"
        }) => n.max - n.min - parseFloat(e) - parseFloat(t),
        height: ({
            y: n
        }, {
            paddingTop: e = "0",
            paddingBottom: t = "0"
        }) => n.max - n.min - parseFloat(e) - parseFloat(t),
        top: (n, {
            top: e
        }) => parseFloat(e),
        left: (n, {
            left: e
        }) => parseFloat(e),
        bottom: ({
            y: n
        }, {
            top: e
        }) => parseFloat(e) + (n.max - n.min),
        right: ({
            x: n
        }, {
            left: e
        }) => parseFloat(e) + (n.max - n.min),
        x: dT(4, 13),
        y: dT(5, 14)
    },
    G7 = (n, e, t) => {
        const i = e.measureViewportBox(),
            r = e.current,
            s = getComputedStyle(r),
            {
                display: o
            } = s,
            a = {};
        o === "none" && e.setStaticValue("display", n.display || "block"), t.forEach(c => {
            a[c] = hT[c](i, s)
        }), e.render();
        const l = e.measureViewportBox();
        return t.forEach(c => {
            const d = e.getValue(c);
            d && d.jump(a[c]), n[c] = hT[c](l, s)
        }), n
    },
    H7 = (n, e, t = {}, i = {}) => {
        e = {
            ...e
        }, i = {
            ...i
        };
        const r = Object.keys(e).filter(vI);
        let s = [],
            o = !1;
        const a = [];
        if (r.forEach(l => {
                const c = n.getValue(l);
                if (!n.hasValue(l)) return;
                let d = t[l],
                    h = Kc(d);
                const p = e[l];
                let m;
                if (Zm(p)) {
                    const v = p.length,
                        y = p[0] === null ? 1 : 0;
                    d = p[y], h = Kc(d);
                    for (let A = y; A < v; A++) m ? eg(Kc(p[A]) === m) : m = Kc(p[A])
                } else m = Kc(p);
                if (h !== m)
                    if (cT(h) && cT(m)) {
                        const v = c.get();
                        typeof v == "string" && c.set(parseFloat(v)), typeof p == "string" ? e[l] = parseFloat(p) : Array.isArray(p) && m === nt && (e[l] = p.map(parseFloat))
                    } else h != null && h.transform && (m != null && m.transform) && (d === 0 || p === 0) ? d === 0 ? c.set(m.transform(d)) : e[l] = h.transform(p) : (o || (s = z7(n), o = !0), a.push(l), i[l] = i[l] !== void 0 ? i[l] : e[l], c.jump(p))
            }), a.length) {
            const l = a.indexOf("height") >= 0 ? window.pageYOffset : null,
                c = G7(e, n, a);
            return s.length && s.forEach(([d, h]) => {
                n.getValue(d).set(h)
            }), n.render(), Gg && l !== null && window.scrollTo({
                top: l
            }), {
                target: c,
                transitionEnd: i
            }
        } else return {
            target: e,
            transitionEnd: i
        }
    };

function V7(n, e, t, i) {
    return N7(e) ? H7(n, e, t, i) : {
        target: e,
        transitionEnd: i
    }
}
const W7 = (n, e, t, i) => {
        const r = n7(n, e, i);
        return e = r.target, i = r.transitionEnd, V7(n, e, t, i)
    },
    Jx = {
        current: null
    },
    AI = {
        current: !1
    };

function j7() {
    if (AI.current = !0, !!Gg)
        if (window.matchMedia) {
            const n = window.matchMedia("(prefers-reduced-motion)"),
                e = () => Jx.current = n.matches;
            n.addListener(e), e()
        } else Jx.current = !1
}

function J7(n, e, t) {
    const {
        willChange: i
    } = e;
    for (const r in e) {
        const s = e[r],
            o = t[r];
        if (Ei(s)) n.addValue(r, s), $m(i) && i.add(r);
        else if (Ei(o)) n.addValue(r, Hu(s, {
            owner: n
        })), $m(i) && i.remove(r);
        else if (o !== s)
            if (n.hasValue(r)) {
                const a = n.getValue(r);
                !a.hasAnimated && a.set(s)
            } else {
                const a = n.getStaticValue(r);
                n.addValue(r, Hu(a !== void 0 ? a : s, {
                    owner: n
                }))
            }
    }
    for (const r in t) e[r] === void 0 && n.removeValue(r);
    return e
}
const xI = Object.keys(sd),
    X7 = xI.length,
    pT = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
    Q7 = X_.length;
class K7 {
    constructor({
        parent: e,
        props: t,
        presenceContext: i,
        reducedMotionConfig: r,
        visualState: s
    }, o = {}) {
        this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }, this.scheduleRender = () => ci.render(this.render, !1, !0);
        const {
            latestValues: a,
            renderState: l
        } = s;
        this.latestValues = a, this.baseTarget = {
            ...a
        }, this.initialValues = t.initial ? {
            ...a
        } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = o, this.isControllingVariants = Vg(t), this.isVariantNode = cR(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(e && e.current);
        const {
            willChange: c,
            ...d
        } = this.scrapeMotionValuesFromProps(t, {});
        for (const h in d) {
            const p = d[h];
            a[h] !== void 0 && Ei(p) && (p.set(a[h], !1), $m(c) && c.add(h))
        }
    }
    scrapeMotionValuesFromProps(e, t) {
        return {}
    }
    mount(e) {
        this.current = e, this.projection && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, i) => this.bindToMotionValue(i, t)), AI.current || j7(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Jx.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }
    unmount() {
        this.projection && this.projection.unmount(), jo.update(this.notifyUpdate), jo.render(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
        for (const e in this.events) this.events[e].clear();
        for (const e in this.features) this.features[e].unmount();
        this.current = null
    }
    bindToMotionValue(e, t) {
        const i = hl.has(e),
            r = t.on("change", o => {
                this.latestValues[e] = o, this.props.onUpdate && ci.update(this.notifyUpdate, !1, !0), i && this.projection && (this.projection.isTransformDirty = !0)
            }),
            s = t.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(e, () => {
            r(), s()
        })
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    loadFeatures({
        children: e,
        ...t
    }, i, r, s, o) {
        let a, l;
        for (let c = 0; c < X7; c++) {
            const d = xI[c],
                {
                    isEnabled: h,
                    Feature: p,
                    ProjectionNode: m,
                    MeasureLayout: v
                } = sd[d];
            m && (a = m), h(t) && (!this.features[d] && p && (this.features[d] = new p(this)), v && (l = v))
        }
        if (!this.projection && a) {
            this.projection = new a(s, this.latestValues, this.parent && this.parent.projection);
            const {
                layoutId: c,
                layout: d,
                drag: h,
                dragConstraints: p,
                layoutScroll: m,
                layoutRoot: v
            } = t;
            this.projection.setOptions({
                layoutId: c,
                layout: d,
                alwaysMeasureLayout: Boolean(h) || p && du(p),
                visualElement: this,
                scheduleRender: () => this.scheduleRender(),
                animationType: typeof d == "string" ? d : "both",
                initialPromotionConfig: o,
                layoutScroll: m,
                layoutRoot: v
            })
        }
        return l
    }
    updateFeatures() {
        for (const e in this.features) {
            const t = this.features[e];
            t.isMounted ? t.update(this.props, this.prevProps) : (t.mount(), t.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xn()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t
    }
    makeTargetAnimatable(e, t = !0) {
        return this.makeTargetAnimatableFromInstance(e, this.props, t)
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t;
        for (let i = 0; i < pT.length; i++) {
            const r = pT[i];
            this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]);
            const s = e["on" + r];
            s && (this.propEventSubscriptions[r] = this.on(r, s))
        }
        this.prevMotionValues = J7(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(e = !1) {
        if (e) return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const i = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (i.initial = this.props.initial), i
        }
        const t = {};
        for (let i = 0; i < Q7; i++) {
            const r = X_[i],
                s = this.props[r];
            (rd(s) || s === !1) && (t[r] = s)
        }
        return t
    }
    addVariantChild(e) {
        const t = this.getClosestVariantNode();
        if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e)
    }
    addValue(e, t) {
        t !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, t)), this.values.set(e, t), this.latestValues[e] = t.get()
    }
    removeValue(e) {
        this.values.delete(e);
        const t = this.valueSubscriptions.get(e);
        t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e]) return this.props.values[e];
        let i = this.values.get(e);
        return i === void 0 && t !== void 0 && (i = Hu(t, {
            owner: this
        }), this.addValue(e, i)), i
    }
    readValue(e) {
        return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options)
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t
    }
    getBaseTarget(e) {
        var t;
        const {
            initial: i
        } = this.props, r = typeof i == "string" || typeof i == "object" ? (t = tw(this.props, i)) === null || t === void 0 ? void 0 : t[e] : void 0;
        if (i && r !== void 0) return r;
        const s = this.getBaseTargetFromProps(this.props, e);
        return s !== void 0 && !Ei(s) ? s : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = new rw), this.events[e].add(t)
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t)
    }
}
class _I extends K7 {
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, {
        vars: t,
        style: i
    }) {
        delete t[e], delete i[e]
    }
    makeTargetAnimatableFromInstance({
        transition: e,
        transitionEnd: t,
        ...i
    }, {
        transformValues: r
    }, s) {
        let o = v6(i, e || {}, this);
        if (r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s) {
            g6(this, i, o);
            const a = W7(this, i, o, t);
            t = a.transitionEnd, i = a.target
        }
        return {
            transition: e,
            transitionEnd: t,
            ...i
        }
    }
}

function Y7(n) {
    return window.getComputedStyle(n)
}
class Z7 extends _I {
    readValueFromInstance(e, t) {
        if (hl.has(t)) {
            const i = aw(t);
            return i && i.default || 0
        } else {
            const i = Y7(e),
                r = (gR(t) ? i.getPropertyValue(t) : i[t]) || 0;
            return typeof r == "string" ? r.trim() : r
        }
    }
    measureInstanceViewportBox(e, {
        transformPagePoint: t
    }) {
        return uI(e, t)
    }
    build(e, t, i, r) {
        K_(e, t, i, r.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t) {
        return ew(e, t)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(), delete this.childSubscription);
        const {
            children: e
        } = this.props;
        Ei(e) && (this.childSubscription = e.on("change", t => {
            this.current && (this.current.textContent = `${t}`)
        }))
    }
    renderInstance(e, t, i, r) {
        _R(e, t, i, r)
    }
}
class q7 extends _I {
    constructor() {
        super(...arguments), this.isSVGTag = !1
    }
    getBaseTargetFromProps(e, t) {
        return e[t]
    }
    readValueFromInstance(e, t) {
        if (hl.has(t)) {
            const i = aw(t);
            return i && i.default || 0
        }
        return t = wR.has(t) ? t : $_(t), e.getAttribute(t)
    }
    measureInstanceViewportBox() {
        return xn()
    }
    scrapeMotionValuesFromProps(e, t) {
        return MR(e, t)
    }
    build(e, t, i, r) {
        Z_(e, t, i, this.isSVGTag, r.transformTemplate)
    }
    renderInstance(e, t, i, r) {
        SR(e, t, i, r)
    }
    mount(e) {
        this.isSVGTag = q_(e.tagName), super.mount(e)
    }
}
const $7 = (n, e) => Q_(n) ? new q7(e, {
        enableHardwareAcceleration: !1
    }) : new Z7(e, {
        enableHardwareAcceleration: !0
    }),
    ej = {
        layout: {
            ProjectionNode: yI,
            MeasureLayout: fI
        }
    },
    tj = {
        ...IW,
        ...W8,
        ...F7,
        ...ej
    },
    bi = i8((n, e) => R8(n, e, tj, $7)),
    nj = "/assets/3D-hero-image-bec8bbfc.png",
    pr = {
        paddingX: "sm:px-16 px-6",
        paddingY: "sm:py-16 py-6",
        padding: "sm:px-16 px-6 sm:py-16 py-10",
        heroHeadText: "font-black text-white lg:text-[54px] sm:text-[48px] xs:text-[34px] text-[26px] lg:leading-[64px] sm:leading-[60px] xs:leading-[46px] leading-[36px] mt-20",
        heroSubText: "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
        sectionHeadText: "text-white font-black md:text-[48px] sm:text-[42px] xs:text-[36x] text-[24px]",
        sectionSubText: "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider",
    },
    ij = () => it("section", {
        className: "main-banner relative w-full mx-auto",
        children: [it("div", {
            className: `inset-0 padding-top-[120px] max-w-7xl mx-auto ${pr.paddingX} flex flex-row items-start gap-5`,
            children: [it("div", {
                className: "flex flex-col justify-center items-center mt-5",
                children: [le("div", {
                    className: "w-5 h-5 rounded-full bg-[#D0B870]"
                }), le("div", {
                    className: "w-1 sm:h-80 h-40 violet-gradient"
                })]
            }), it("div", {
                className: "w-full",
                children: [it("h1", {
                    className: `${pr.heroHeadText} text-white`,
                    children: ["Ihr Erfolgreicher Partner für Websolutions - ", le("span", {
                        className: "text-[#D0B870] ",
                        children: "Jan is fucked"
                    })]
                }), le("h2", {
                    className: `${pr.heroSubText} text-white-100`,
                    children: "HIGH PERFORMANCE WEB DESIGN"
                }), le("p", {
                    className: "mt-2 text-white-100 mb-10",
                    children: "For Businesses | Start-ups | Blogers | Influencers"
                }), le("img", {
                    src: nj
                })]
            })]
        }), le("div", {
            className: "absolute xl:bottom-8 lg:bottom-10 xs:bottom-2 bottom-0 w-full flex justify-center items-center hidden",
            children: le("a", {
                href: "#about",
                children: le("div", {
                    className: "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
                    children: le(bi.div, {
                        animate: {
                            y: [0, 24, 0]
                        },
                        transition: {
                            duration: 1.5,
                            repeat: 1 / 0,
                            repeatType: "loop"
                        },
                        className: "w-3 h-3 rounded-full bg-secondary mb-1"
                    })
                })
            })
        })]
    }),
    rj = "/assets/logo-faac24c2.svg",
    sj = "/assets/web-development-ac9bb461.png",
    oj = "/assets/software-development-8da583cf.png",
    aj = "/assets/performance-2fa60a88.png",
    lj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANAAAADQCAYAAAB2pO90AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA3sSURBVHgB7d1biGXZXcfx/76fS5269I2xccZOQBAEDQMSJNEMKIIIGpAxyjxEEBFBhDzpgyCo5NFHX3wIYkyML4IP+iAhD4HMS17ykoSQTDKZTLo7famu6qpz3Zf8/+tUDzPpru5zap19zq6zvx8ounumquvS57fXf/3XXmuLAAAAAAAAAAAAYBsFcgl86//+9lYZVN+XFjo5vC3FbCLtEkgnCm+9+sYX3paGCwXAhREgwAMBAjwQIMADAQI8ECDAAwECPBAgwAMBAjwQIMADAQI8ECDAAwECPBAgwAMBAjwQIMADAWqoIAgkzfoSRan7PZqJADVQknZlsP9z0tu9JmEUS5INJIoTgtRAsaAxoiSTTndXkqQrQfj+a1ulAepomCop8omUxUzQDASoAcIglKy3J2lnR8IwOvf9bASKk45UcerOSSjLXLBZBGiDAg1OkvWk09vV0UVLtAXPeLGPizRIQZHraDSRqqoEm0GANkFHEivTOjrqRPHFmgT2MTYvsjlSVRWSz8Za6RGkdSNAa2aBcfOcTn/hEed5LEhBoI2GtO9KusKChLUhQGsS6Nwm0+BkL5jnXPjvtxFJW96h/mqjEWXdejx1CXzz3z/1L9IwUdK90t+/8Ueu9rlkrEGQdgaSdnf0BW7Xq+W+hTs/+IbOc5ZrFtgcKde5UTm7nPMj+/p/8M7tL01GkyNpmD/9xzf/4v1/fmoE0p/3X0rDFPlUqtKu4nKpWMes2z/QC0C6knJtUZX+sKIwkShLpCiml/Jk07IsPiVhI8P//ADBn5VS3f6+C9AH13M287WE+lZMR7S9a0CAVijSVrQ1B+a34CTSFDb2Wbtcr+oapLGU2rXDahCgFXhvPUebBNZlayKbC9nXGWfdeZBoNKwEAfLgFjR1pOm4ci1zf26+QLuAsYTZjuSUdd4I0AVZcKwtnerIE9TQll6HWL926xrl06EblbA8ArQku3pbW7qjbenLGpz3nJVwcWpBKt36EUFaDgFago022ZPbby7Hs8kW5+ZxfRciWzbAYgjQC8zvOcvcfWuuLb3Fe3KsqWDfq72Vun6UW5BoNDwXATqHBcXKtfk8p7/x9Zx1s7WjRL9/23vEiHQ+AvQM1k3LugPJdK4TRu39EbkuY9xxc71iNnV3feODvF4deV7I3fv1365kHa+dKzd11lHvpP3Jeo7d8GllDFuoTeVG4qiTru3+ukobGfcfjWQyrb/FfmU3lTi6eHXhF6Ail//+8nfkdFzvNzroJfKZD93SechA6mKNAbtvLU4729cgWIEn99eFmZZ1ea5lXX3bJkr9XF//5gM5Pq23dEyTUH7r117SAMmFtb6EC902gz1927kkC6GbZReX+Ua+aL5touVt79YGyMJizQHrrlmNT7m2HFfupr2zTXwTN0K1UTsDpP/YNup0dw4Efmx+FCSBFNqta+NpQa2sWcqylEf33pbT43utvXKuRiWz6ViOD++637dRa0s4q92P7v1Qhkf3ZKAdPlvvadtajw87n250eiTj0YnryvWlnaN565sIs+lIHt75nmS9XdnZf8mt/+B8ZVHIaHgo4+FjN5K3HQupZybDY5nq1bS3e9UFqan7ejbFSt3J6LEbdfKck1GfIEDvYy+SUy3pxieHbuG2N7ja+ta2lWe5lmvDxw/dfIdNeB9EgJ6h0AViNz86vi+Dg5vS6e9JG1l7enj6SCbjIc2WcxCg55hNhjo/+q6bF+1df8Xdjd0G1pKeark21LLW5jw4HwFagNX+9370benv3ZCBzo+2tVtno8xULxpDLWHzGXdgL4IALcja3ieHt7Xt/RPX9u4Nrm1NkGxeM5sOXYOAec5yCNCSbMvz0f135OToruxfv3Xp29526unp4/tn8xyCsywCdEG2P+bBj7/jTuTZvXpT50dduUxsRB0NH+l6zolrmuBiCJCnsXWpdLLd37vu1o+avgHPzXPGp9pdO5ofmcyo44UArYC9KE8e3XVhsueaWrOhaetH9jXmOr8ZDY+0UTAiOCtCgFYo13WT4wfvyujkkRzc+AWJ082XdRYU23IwGR1rk+Axx1atGAGqwWxy6tre1mDYvfayO7V0E2zUGemoONY2fJEzz6kDAaqJvXjHWi6N3zmWHS3prLRb10Lsk/vWxjo3m7GeUysCVDctodz8SMO0e8VuC6r3tv8in2lb+oFbEGWeUz8CtCY2gX945y1JO30ZHLwkWW9fVsk6atYgmIxO2GawRgRozayFbEGyAM3Xjy5e1tkIY+s5k7FtMzhmPWcDCNAG2At/fHroOmMWou7OFXe2wLJ/h91+M9SOn91+g80gQBs031b+jtuDZIuwtv/ohR9j+3Nmtp5z7EYz5jmbRYAawOZHTw452T246baXP4udejPSkWs0PGV/TkMQoKawkkxHlAe3v+uO29q79vMSnj1n1cJi/+/k8UPmOQ1DgBqnktHJQy3PTlzL29ZyRieHup4zoVxrIALUUNaWPr7/thw9vC1oLg5CAzwQIMADAQI8ECDAAwECPBAgwAMBAjwQIMADAQI8ECDAAwECPBAgwAMBAjwQIMADAQI8ECDAAwECPBAgwAMBAjwQIMADAQI8ECDAAwECPBAgwEMrA2QPAA7jRLAaURS19tmrrTyZNAhDSbs7Us6m7kluwpG5FxIEgWSdHUmzrLU/w9Ye7WujUJR2pJOkkk/GUrizp3niwaIyvQClSfLeAfht1fqzsS1ISdaVKNYgTUdS5jOphBHpPPbE8azTk0QvPBx2T4DmtBQJ41jSeKBl3URmk1Fra/rzWLnW29mXOH7yyBXCYwjQzwj1CptqWVLkE1fatb2ss+AkVup2+260xgcRoGewJkOczsu6QhsNVtq18YqbamlrwdGfiAsSnkaAniMII4n1RWQt79nkVOdH7Xg6nI04Ns8J9fsnOM9HgBYQRrF7bqmNRrPxcGvLOvs+O52+NgoSyrUFEaCFBRLp/CjS7tPM2t7T7ZkfWVhsxLGSjRFnOQRoaYFre1s7N9eyLtdR6TKL9YLQ1dHVgkN4lkeALsgaDUl3oIuxhZZ1J1JesqdnRzqvswZBrI0SXBwB8hRG0Xx+lFu3btz4INl9a5mb56TMc1aAAK1CMJ8fWbeumE4a2fa2sNiIk2Qda0oLVoMArZC9SGNtAVuYrO1dNGB+5O75c+VaT0cf7kBfNQK0ameT8bSzI2Wau7b3psq6yNrvZ/McGgT1IEB1sfvr9Iqf9fdcWTeb6vpRuZ62ty0Ad3sDSXQkFG6MrRUBWoMonc+PrMlg86M6Jfq5LDzzBgHhqRsBWhPX9tbFyji1bROTs/1Hq3uBz9dzBhKGFhzKtXUhQGsWhLEGKdZ5SSbTqf/9dTa/ybRBMN9mQHDWjQBtSBDrBD/enY9Gtn605P4jK9HSTlcyd/sN6zmbQoA2KnC3BNnbTOdGhe0/esG8xe2g1TLQziLg9pvNI0CbdhaAJOudbSufn8/wLFam2a7Q+YcRnCYgQA1i2wncaUG6GDsb6ULsk/9+1paOaUs3DgFqILf/qL/rzmnoDo/dNoM5wtM0zD6bys4i6PSle1ayoZkIEOCBAAEeCBDggQABHggQ4IEAAR4IEOCBAAEeCBDggQABHggQ4IEAAR4IEOCBAAEeCBDgwWtDnW0qvn6QyV5e75Gxg15y9rS09uXdzrG2771N7LivfieyB8lIndLE//XkFaA0TeUPf+eXpW4WnNnoWPLxibTNnTu3ZTJr14OO7QTXV3/piqxDHPudLeE3AgXB2p4vk8/G0kanw1OZTJc78mobrGJ0WAfmQIAHAgR4IECABwIEeCBAgAcCBHggQIAHAgR4IECAh6fuRIiTjqA5siyTspoJmumpAPUPXhI0x8tBIEVOgJqKx5s0XFmVUpZ+z1FFfZgDAR4IEOCBAAEeCBDggQABHggQ4IEAAR4IEOCBAAEeCBDggQABHggQ4IEAAR4IEOCBAAEeCBDggQABHggQ4IEAAR4IEOCBAAEeCBDg4VnHWnEI2QKqsqr3CbjvfZ7SPXS3TkEg+gnCej/Jlnr6ZNI4/Zjg+fJJcHj47hf1pfdhqdndu7dlNJ5KncIweuva1Rt/3e12jwRL8XtEcUu9+bk/vlVF1Vuyhp/fuz++LaejegOkI1AZx+GH3/i7r70tWApzoAso4/LTskUXH60QQymCjwuWRoAuIKrkI7JlyqB6VbA0AnQBpQSflK1T/ZVgaQRoSV/7wuufkC1UFFX6pc/+Bg2kJRGgJQVF8LuypWaz4jXBUgjQkqoq+KhsqbKqXhMshQAt4av/9vor2nr7FdlSupL6iS/+02++LFgYAVpCFMiH9EV2RbZUJVUymUxfESyMAC1By7fXZJtVdieKvCZYGAFaQhBueYBUUQW/L1gYAVrQVz73yf2q3L4F1KdVNz7/9x/dFSyEAC0olvgjQSD7sv1eiaL4VwULIUALCqLwD6QF7L64mVRbuVhcBwK0gP/9/Bu7URD8nrRFVf32f33m17uCFyJACziYFVf0yvyL0hK61vWx46vBDcELxdJC3/v/v9k7muYLz2emR/f/RIp69+ScJwwDiaO1X+fiQZy+/pV/feM/F/2AJHx89PE/+5/H0jKtDNC4KP+5E8WfXvT90/3rGxupb2rnophNZN2CMPpsEOT/sOj7V1X3P/SXP5eWaWWAdEE00jolWvT99cUkmxJGsVRlIRuQnL0txAZKaSHmQIAHAgR4IECABwIEeCBAgAcCBHggQIAHAgR4IECABwIEePgp+MB7kr3kxjUAAAAASUVORK5CYII=",
    uj = "/assets/github-154515ac.png",
    cj = "/assets/menu-b5599218.svg",
    fj = "/assets/close-54702a70.svg",
    dj = "/assets/SEO-16e2b4f2.png",
    hj = "/assets/digital-marketing-44c48588.png",
    pj = "/assets/wordpress-d20d5635.png",
    mj = "/assets/safety-standards-6b2c8316.png",
    gj = "/assets/responsive-d598c3b7.png",
    yj = "/assets/css-79a7f026.png",
    vj = "/assets/docker-602a695a.png",
    Aj = "/assets/figma-184a11e6.png",
    xj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANG0lEQVR4nO2dX6xcRR2AD9QYgpYElEDv3fltqdUSHtSISNWIiIE09vbuzMKa+GBq4p/4hoIGEx/qSxOiL1T62Adj4kN90gegSXnQxAdCIiYkloQKSKKQpo3c7szeikrXzPZCW3r39uzdc2bOzPm+5Jc0t7t7dn4z386cc+bMFAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFs415cdVqtHrJZjzqgTToudhFEn/N/8//nXxP6eAHAJIy13Oi3HnZFxqdBy3L+HJAJEZLy/e5016og1cr60vGvh3+Pf6z+DSgQIzGhZLVgjz80q7hUia/XC6mCHUIEAgfDCWS2vzCvvJRK/zrkxQILyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMbSe1OVFYmgtuciLxNBKnJE/xJaucomNeu1cr7s9dm4Baie3HpieGFoHEgMkDhIDJA4SAyQOEgMkDhIDNASn5YDV8vis70NigMg4LT++eFsFibnFBMngjPzoynujSIzE0Hhsv/vo9AkOSIzE0Fj8vrtXn6WExEgMjcMa9cPyUw2RGImhMVijfjD7fGEkRmKIjtXq4c1P+kdiJIZojLR8z+9wP9+TO0iMxBAcp+W788qLxDyKCBFwRr5TlbxIjMQQENeTb1st71QpLxIjMSQ2bJ4qsVE/m/V7+SVs/FI2l/8YqDeslmecVof9ebYPp9Uhq9VTTqtTdZahwlywPA80v+etSmJn5EVn5Aln5DPjorhm2mvHB4prR8uLd1stB61Wb8YWFYmhVlxPfSuUvPNcnd4M46Vt1zsjjzmj3oot6/RcqNfP9WVHiHxAZjit9oeWN7TEntGgs2i1PB9bViSGynB9+WYseecZTs/ZGx+NLesGueCcGMphtfq6NfLfRjTcgD3xeFBssUY9HbvM03PBcBqugjUyaIq8MSRe2Ss3Oi0vxy4zEsPMDI081DR5Y0g87KkvxS4vEkOyw+ZpMdTdfqhqndxHbkCZp/6gcU4MKfS8lzTYf9t9t90SqtZGpnNX7DIjMVwV36tZrf7T/MYqvwtdnc7IycbnRXNhq7WMTNekIK+PkVbfD50fp9UvY5e73I+b4hZT2xhp1bNavR278ZUWeHnx7tA5clqWYpcbieEKRj21LyV5fQwHt94cuipX9nV2xi43EsNlONPZY7U6F7uxzRrjwR0fDF2Vp5d3bY1d7pkl1pwTZ4vrd7/mr+bGbmSbEnhp2/Wh8+VnZsUu96YkNpwTZ4fT6oEUe953Y7W3oELn7MyenTfELvemJdb0xNmQurwTgXX386Hz5h/ji13uuSQ29MTJY42632pZjd2Y5m6MWj0S42Jf7HIjcYuxPflqDvJeEFh+Hzx/Wv0idrmRuKXYfvcr1sgoduOpTmD1dsiplH5ZnhRmYrmy+WM4nQ621703J3nfC61+GvJ2W/TyInH7GPbli06Ljd1Y6gl11hnZFiKPq4MdYrW8Er/M1Ybl6nRzmTzHmq28a6HVb0Llc70la3MIy3C6eZztyRecUcPYjSNIA9Tq4VB5pSeG2mmTvBcElv9Z3flGqKZFTwy1MTLd3WvnhtHFCiqx3yVCq59stIh7lSAxVI7fhcAZ+VdsmaKGlj8Ol+WOEM2L4TRUvORLc3cUCH6PWKtfj3Tnc3U3MXpimJvRg+qzyLu+zGVz6Iz81hn1Vy/krPlHYtg0rtf9tDNyJnav19Qoncc59x5iOA0zg7zVC4zEst4pCRuqVY0z2z9Fz1uPwEgsSFwn9sHFTzojp2MPT3MWGIkFietg2O/e3vSNqHMRGIkFiZE3bYGRWJC4Cs4ub99ltXojdo/WRoGRWJAYedMWGIkFiTfV8+qFT1gj/4zdk6UaVQqMxILEM8nbX/w48jZLYCQWJEbedHvgeR+CX2/apb+2Mdl/WKvDfuNyH06rQ1arp5xWp2KPYlyN+cgSvweP1fKP2JWSQ5TNechG69/jjLzojDzhnyDb6BHI8YHiWr+Rm9VysOm3Dy0SF8Vqf3s3x2VbchQ49DRDv52MM/JYkx9csW2edom86Qkco9GOBp1Fq+X52LK6huSjEZzbJ7f5gsdOfm5RNv+pDR/XeuOjsfPrGpKPqIyW1QLD5rQFjiLxl4sPOC3HY8vqNsiHb9tFzoz3d6+zRp6Lnexco2w9pDp8XNkrNzotL8fOs5uejz/H2Ao2GNaoI7GTnHOUrYdKG23gntjvvBE7z27jfBwpcn0g32p5J3aCc47SdVF1ow3cE0/uIzcg3269XBg5P9JyZ5EbTT5/ySVK10Utx+/sKYIuahg/31NDy/EiJ1LfLDqVKFsfNRz7ZKg1qt/FGvVq7HxvFFndWrL97qOxE9qGKFsfVR/XGvXzelvQOmXQ6lDsfDdtU/basFqOxU5oG6JsfVR93FFP7au3Ba1TBi1LsfO9Ufg2X+SC0+ql2AltQ5SujwyGi34OvWtAzqeGVi8VudCmzcdiRvn6qPa4p5d3bS0C44/pGpDz6aGGRS4gcN4CjwfFliIw/pguuqRtEZghdN4C33/Lh4rAJNADnyhygYtYeQvMObDkfRHLX1KP/4uYf5StjxqOvbfeFpTiVWiVz22ktVUZoic19yhbH5UfW6tD9bag9cqgnoyd79ZM5PAwlTJfgf2sqCIwjZ6JpTObSunxE7z9RO/oyc04ytZFHcf285OLQDR5LrTN9WEGD48T5iuwf0KoCESzn0ZSeT5O6OGB/nwFXut97qt/w7vOPbEldW19oN/Dkjr5CuyfSloZdG6qq+34z3ZG/hZbVNfWJXXeZXWwQ6yWV2InPbcom/96v4d61q9fVcfMK2vU07Fz7NaJdq5Muc6q/UQOAk/iaJVDySavSmnbtCLl+6EnrrYxlc17oIb9F7/2d87rQts29rzvB4nzFHgSWqzf++jMnp03zNou/PzqJu/MYJH3IgynMxX4YmN/0+93NDLd3X7/ow33RjLd3U3fG8m2edg8DSTOV+DLQqtTk4tRl+9OeHjtb43fndAi73QYTrdA4ITDMmy+OkiMwLFFdcg7H0hMDxxbWEfPi8ShG1rZjMcWIqWwDJvpiRE4vogOeePAcJoeGHkTB4kZQtPzJg4Scw7MsDlxkJiLWJzzJg4ScxWaC1aJw7TL99/qkHesVk+VzZ9/LZuty8X8MT0yPEh8YQE1a+RXK1p9bNb8+ff497Z9oUGLvPFos8RWq7/bXvfeeXPoP8N/VuzyIG9LaeM58eQB90H31qpyOFza9lGn1Z/alUPFw/hNoU09sV/p4tTg5g9XnUP/mf6zW5LD13iet2G0QWL/kPtqb0HVlUP/2U1+kB55Myf34fTQyEN159AaGWQrr2bY3Hiy7YkD7reT4z5WlmFzOuTYE1uj7g+VP6fVA1nlTtPzJkdmPfHJcVFcEyp3/lj+mFnIa7hglSwZ9cRPhM6d3/M3eXk1PW/y5CDxsCcPhs6bv2AWu9zIC1kMp4f97u2hq9IfM3a5NxuWYXN+pNwTn9ULHwmdr8nsrBTl1QybsyXVnriO3f6uhj9mcvIaLlhlT4o9sd8nKHSeTi/v2pqUvJqetzWk1hPH2AFvZV9nZzLyGnre1pGYxHtD58dpWWpAuZEXMhhOa3UodD06o56MXu6rhGXYDClI7B+4D11T1qhXY5cbeSGb4fTIdO4KVZ3+WI2Wl3NeSK0ntlqeCVVrVsux5uaBq82QqsRG7qu78ob9zj2xy4m8kKXE/rzUz5Cqq3pXBp2bmvoUEj0vZCGxM+rZOmZmjQfFFmvU0/HLh7yQ/4Wto+OlbddXVdH+s/xnNqBcVwQXrCDLntivILna396dt3pHg87iZJnaJpaRC1aQs8ROi7VaHj+zZ+cNs5bLz692Rh5zRr0VvRzICy0eTk+Wm7VaDo5Md/f4QHHttHL4//Ov8a9t8vKxDJuhdRK/F1qdmlyM0uqw7519TP594W+non8/5IVYNHo4nUFwzgu1g8TIC4mDxPS8kDhIzLAZEgeJOeeFxEFiLlhB4iAxV5shcZCYW0WQOEjMfV5IHCRmkgYkDhIzwwoSB4mZHgmJ03aJmdsMydNWiZEXsqFtEiMvZEdbJEZeyJbcJUZeyJ5cJUZeaA25SYy80DpykRh5obWkLjHyQutJVWLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFCMxoWS1YI89VIO8L/geBCgQIzHh/9zpr1BFr5PzM4ho579/rP4OKA4jISMudTsvx0gJrOe7fQ6UBNIhzfdlhtXrEajnmjDrhtNhJGHXC/83/n39N7O8JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFCE4v/t8177cNMPugAAAABJRU5ErkJggg==",
    _j = "/assets/html-92b76a73.png",
    wj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOgElEQVR4nO2dCdCVZRXHz8Pnwi4groElmijuK6m4YCqJpZmJqJla40qGWjgYZZQL5p4GJZlboKKTGzoouWSAiQsuqONY42Q1LVrZYlpZnebcy51B6uO7977LeZ/7/H4z/wGGmfve5zznf577vu+ziAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtIW+JIqIQafkgKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyB/Sp+yKQJHwmlft+3l4kumiN62dmixx8WdJ9dg246LOjggUH79A4aQv3v79sg6Oab1P//pAlBL50iev9s0b8tq3bBkdTwDnjsisHA7zwj+v1viB62f9C+vbN9395rBx03JuhV00TfXFrF/kgM74DHriob+A8/EZ16YtChg7N9x+40oF/QyccGfXVhlfojMbwDHruqaOB3l4teMkV00IBijLuq1loz6PRJov94rgr9kRjeAY9dVTPwy/eJ7rZtOcZdVVtvHvSp2737IzG8DRC7qmTghdeWN+p2p769g94zEwNj4AqYMyYDz7tcdI0uX/PKCtn3mP01r/5IDG8DxK4qGPjumdUxr6yQvY6aezEGxsAVMGmVDWz3vAP7+xtWunnltGRu2f2RGN4GiF2eBranvttu4W9UWY3WHxL0tYcwMAaugFmrZuDzJ2e/fhkaN6a82WaSGt4GiF1eBv79Y6L9+/qbs1ndcCEGxsAVMGxVDDztZH9TtqIh64Ra0Sm+PxLD2wCxy8PANtNqw6H+pmxWgwcGvWZ6Wf2RGN4GiF0eBr732/nd+24/MugVU0WfuUP09cX11Ub259J5oldPE917l/oroXY//9hDgr6xpMz+SAxvA8QuDwNPOjq7cfv1qd+X/ufFnq9nr4J22LK1z990WKgtPyy/PxLD2wCxy8PANuc46/vZR29qfR3xxPE9f3ZXV9Azjwv61tNe/ZEY3gaIXWUb+O/PSs0kWa553ufba+u/losefuDqf44/eZt3fySGtwFiV9kGfnF+tmvarht/far99trIOmqz//3MGWeK/vP5KvRHYngHPHaVbeAHr8t2zQP2yD6pwh54NeZejx0d9JUFVeqPxPAOeOwq28C2cCHL9T57eD6zor46SfTa85p7CKal9kdieAc8dpVt4NuvzHZN28ius/sjMbwDHrvKNnDWd8AH7omBOwpvA8Susg38yA2S+f2v7VLZuf2RGN4Bj11lG9geGGW95qxzO7k/EsM74LGrbAPb6NmrV7Zrrjso6E/v79T+SAzvgMeusg1s2nJEtmuaRgwPtd08Oq8/EsM74LHLw8C2QCDrdU22Fc+NM6r3Kkgz9UdieAc8dnkY+KaL8t2Jw1YcPXZzp/RHYngHPHZ5GNiOTFlzjfwM3JAdZLZgduz9kRjeAY9dHgY2fXI1iwqyasetgt5yaTXmNmvL/ZEY3gGPXV4GtuWARRm4ITti1FYu/XZRTP2RGN4Bj11eBjbZrKqiTWxae62gnz406LN3xtAfieEd8NjlaeDn75LayYBlmHjl1UwPfLe6T64lNbwDHrs8DWz6+uk+e0NvNzLozZeI/vsF/z54b38khnfAY5e3gc1AB+9TvoEbsu19bruiSv2RGN4Bj13eBja9uVRqI6KXiUWCfvhD/mcDY+AKGCI2VcHApt8tzr7ZXVZ1dQX94gm+q50kNbwNELuqYmDTHx+X2mQMTxOLBN1qRNAnnDa3k9TwNkDsqpKBGycW2iiYdcVSVq3RFfSCM8p/Wi2p4W2A2FU1Azf0w+9JbSKG92h81MGhthUuBsbA7maNycAmO0zshMP8R+OD9irvvlhSw9sAsavKBl55G9j9Rvua+JCxobYxPAbGwO6mjc3ADc2fJbrLNn4mPuv44tsqqeFtgNgVk4EbWjRH9KP7Zjt1sB2FEGq7ahbbH4nhbYDYFaOBG3ruzvo9sh12VpaJN14/29EuPfdHYngbIHbFbOCVZ3JdeY7o+zcux8TnnlZcmyU1vJMndnWCgRt6d7norZeJ7jSqWAMP7B/0z08U1R+J4Z00sauTDLyyFl4rtfnNRZn4m18qqj8SwztRYlenGrghO+93/93zN/Do7Yppt6SGd4LErk43cEN3Xi26wbr5GbhXr6C/frSI/kgM78SIXakY2GR7Y+21c34mnnd5Ef2RGN5JEbtSMrDpradF99gxHwN/4YT82y6p4Z0QMcvm96ZmYNNrD0ntlMOsbT94HwyMgR0T+fXF1TSwLWIouu02LTJr27f5IAbGwE0m3M8flNrWqLboPa8kthP+sibxkQeFXN/jXnhGfXRcOq9YAy+Zm73t6w3BwBi4h0Sz0wVmnCnat3c9aU6ekF/S3Ped7El83Mfz+T7L737vQoVRmxW7DtemQ2Zte78+GBgD93CavW3vsuqE+rtn5pPENtplTeJTJ4bMo+75k6W2+fqqn33OScXeX2e9D+7qwsAYuJvXHXYEZ3erbQYPDPri/OwJvOdO2e8Dp3wm28buq5v2aNva2ESMIsxra3vt87O0vX9fDIyBV9kjeda5UjNoT8lj281kOaX+hXvy2VDdFhG0c1tgG7o3cyrDpsOCvrEkfwO/ujB7+zdaDwNj4BUJZXsS79riYvWhg4P+6Mb2Rp8xOYy+pjuuau3adj6RnR7YyjXGjs7/fvjqadkNvN1IDJy8gf+0VPRzx9Tvp9qd0jfp6FA7c7eZxH17mdQ2asvDvCZbk9vsqDt9UvvnAo/fO799qexzNt8ke9uPGIeBkzbw3ItFNxyaj5HsKfVJE0LtyfJfnnzvdWxr1JfvE71iqtR+kuZlXrumPYTqqZ3LfiC6fQ4nL9i+WLYBfNa4n35MddcFS2p4m7Bd/eyB7A9RVie7jx4xPOjwDetGK+Ia9hCsmbbuvkN+17T7zgWz24u5/QyffGx+3+XB6/LPC0kNbyNmkY2YRRm4DH3l1OYMvHiO5L5/1d671I8JbWanSNss/pZLpfZuOa/r9+1dzHtqSQ1vE2aRLUfLY06ul1o5DGzi+OJ+adi9qE12ue4CqW06d89M0RtnSO1khUP3C7ruoPyvO3E864GTN7Al9mVn+5yPm1X287yVY0dsAYFtReP9vfPSw9cXU9QlNbxH0awyE4wb45+QrcoKT6tttZ+x3t87D+00qrXihYE72MCm3/xYdP0h/onZrGwktddf7bT1xCP8v38VH17pCklqeJsvz3nPZe5vnEUXndV+O+09dB6vlLw0oeD1z5Ia3sbLU3d9q9hXS3nIJkBkffpqvzi2+IB/W1rVsA3yXc6JgTvMwCZ7elr2kSHNymZR5bVO95cP5zuppGj171vOod+SGt6GK0L2sKdPQZMvsuiqafkvKLCn2d7tkh5kSx3vb3PyCAZO0MAmq/Z2Do938jY07eRi7v1spZFNyvBun3SjQQPaWzCCgRMegRv61SP5rNnNIvs5bxMiimynzaf+8intL+goStuPDPrSveX2uaSGt8nKWCN8zfTm1gjnLZvBZBuil9XWx28t/lyjZrTWmkGnnljslj4YOBEDr7xLx6c+Vl8+WMaoa69L7Jplt9PmNl9/gc+9ca9eQT9xQNBXFvj1s6SGt7HKlu2kYdvt/L89pLLKfsIeMra1Oc5FydYP28O8Mu6P1xkQ9JQjQ23JpXe7JTW8A+4l2zvZTsjbd7f63lFZRh3bCcS2uPnFw/7t6u5p9SVT6mbOa7KLvdO1bXptR5F3ctooIA9JangHvAqyA65tIf9XJ4kefmDQnbcOtamZNrJYstpobffQm2xUX8NrezmbYefPqm/u7v39W5GZbdGc+t5hpx1VPx1hhy1DbWMEa2OjmA3oV//3ZsNDbfsgWz1kC/Bvv7K+Ftu7HdqNJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBBoiiMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEg+/BceiofdqS/+vQAAAABJRU5ErkJggg==",
    Sj = "/assets/mongodb-54000b2b.png",
    Mj = "/assets/nodejs-d83eb6dd.png",
    Cj = "/assets/reactjs-966214a8.png",
    Ej = "/assets/redux-171787ca.png",
    bj = "/assets/tailwind-6ece120d.png",
    Tj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANMUlEQVR4nO2d+48V9RXAv//Gtw/balttayOpjVZr06TPqLRJ09Q+09Yaa01sapNWKqiAqCiU+MJXfSGC+ADxQa1AK0WMogJW2L3syrIvdpcL+95ln7B7mu8Y7GaD9N7ZmXvuzPl8kvOLMXsvZ87nnLkz852vcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsfDX7BaCHOSlBpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPAIjMI2ARuCZwBQBjSDbNeCsoZ1wghx4BEZgGgGNwDOBKQIaQbZrwFlDO+EEOfAIjMA0AhqBZwJTBDSCbNeAs4Z2wgly4BEYgWkENALPBKYIaATZrgFnDe2EE+TAIzAC0whoBJ4JTBHQCLJdA84a2gknyIFHYASmEdAIPBOYIqARZLsGnDW0E06QA4/ACEwjoBF4JjBFQCPIdg04a2gnnCAHHoERmEZAI/BMYIqARpDtGnDW0E44QQ48AiMwjYBG4JnAFAGNINs14KyhnXCCHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMALTCGgEnglMEdAIsl0DzhraCSfIgUdgBKYR0Ag8E5gioBFkuwacNbQTTpADj8AITCOgEXgmMEVAI8h2DThraCecIAcegRGYRkAj8ExgioBGkO0acNbQTjhBDjwCIzCNgEbgmcAUAY0g2zXgrKGdcIIceARGYBoBjcAzgSkCGkG2a8BZQzvhBDnwCIzANAIagWcCUwQ0gmzXgLOGdsIJcuARGIFpBDQCzwSmCGgE2a4BZw3thBPkwCMwAtMIaASeCUwR0AiyXQPOGtoJJ8iBR2AEphHQCDwTmCKgEWS7Bpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPALnW+Dm7jEBkYUbOiqW81mLCvKjBxrl6qcPyF83FeXJt3tk275BebdtWJq6xqJj0jt0TPqG34+uI0ej/7bv8Gj0/2ypH5BndvbKfVs7ZcGLHXLlE61y0d0N8vkFtUzgJNGWE4GrQ+ALltbL3Ofa5eXafin2j6faL/uGj8nOliFZub1b5jzbJrOXN8ip82oS+Xc4a2jLicB6Ap97a100XeuLo6LNsYnJaHqv3dUrf17XJucsrkNgBM4XSQl88fIG+fue/kiaamXVm90IjMD5YqYCn3dbnWzY3SeT1evtBzz0WhcCI3C+iCvwR+bsjk5Lh8YmJCvc9cphBEbgfBFH4NOuq4kuTGWNpZuKCIzAtgU+a1FB9rQPSxa5MebZhrOG9hXmUoL7wOULfPoNtZmVN3Dt+nYERmCbAn/8L3vk9f1HJMtc/fQBBEZgmwIv23xIss4Vq1sQGIHtCXzhXfuq+v5uqfxqRTMCI7A9gbc1DEoeuOTBRgRGYFsC/+zhJskL37unAYER2JbAm/cOVOy7tHSPyT9q+qNHHu/d2im3bSxGz1U/uK0zWoUUvktrT/xVZN++Yx8CI7Adgc++ZW+qv33D395U6JdLH2uWMxcWSpbrjPm10bLEIPiOliEp9SuG1VHcB87JfeCfPNQol61sTiX+8NSBxIo8rKZJ63uGCM8yf1iOwprbtAjPT4cGkcSxPHNhQf74zAF5s+nkt7m+HPPznDW05dSOLywsJFbobzUNqf070jh9Hj82Kb9/sjW173zB0nr527ZOOXKCZ7TDcYnzN501tAXSjjwIHB7cGBxNdqFCONX93er05PXTTrPDKXb/8LEPPj/uAn9nDW2BtCMPAn9tab0kzYo34i3n8zMUOVwQC5P/o3Pi/Q1nDW2BtCMPAoeHHpIknNKWc6HKJxxxL2CFcNbQFkg78iBwuDqdJC/u7lM/Lj5mOGtoJ1w78iDwPf8+LEnyp7Vt6sfFxwxnDe2Ea0ceBH709S5JknDbTvu4+JjhrKGdcO3Ig8BP7eiRJJkd8zFGXwXhrKGdcO3Ig8DPvtMrSfLrmCuBfBWEs4Z2wrUjDwKvfrNbkiQ8XKF9XHzMcNbQTrh25EHgIFzSOyeEV/JoHxsfI5w1tBOuHXkQOOnbSIGwF5L2sfExwllDO+HakQeBw0KHNAgbk2kfH19mOGtoJ1w78iBwWKWUFkHi8Ky19nHyJYazhnbCtSMPAoc4NHBU0mJX69BJlzL6KgpnDe2Ea0deBF6f8K2k6QyMTERrjk+5trqnsbOGdsK1Iy8Cp/U7eDphc+/wWWG/Je1j5xEYgfMi8Kfm1UjP0P/W06bN7rbhaBVUtYnsrKGdcO3Ii8Ah7t6S7KKGUgjbt1y2sjn2+l0ERmAEnrKZ2YleT1MJ6oujctWaVvUr1s4a2h1TO/I0gUOEV7tq0tw9Fu1FrHWxy1lDu+C0I28Cf3LunujtmNp09I3L9S90yCfmVlZkZw3tgtOOvAkc4uLlDdF7paqBtt7xaKfBj1Xo1NpZQ7vYtCOPAoeY+1y7VBP1xVH56UNNCIzACFyqxPe/muwqpSR4/t0+mXVTMi+JP1E4a2hPCu3I6wQ+HmGvompjYGRC5jybznu3nDW0C0w78i5weNDikYTfmZXk2y9PT3jdsbOGdoFpR94FnrpmuBo3/m7qGpPv3BlvJ0IERmAzAof4wX37pXMwvVVLcRken4i9off0cNbQLirtsCRwiHMW18n2xpPvDKjByPiE/PzhmV+ldtbQLijtsCZwiPDc8rzn22VI6bHLDyPcu/7lozOT2FlDu5i0w6LAx+PcW+vklbrktyWdCeFZ7m/e/h4CIzAClypy+P1ZODgi1UJz95h85nq2F2UCM4FLljisIpq7vj3VV/OUw+Pbu2NNYWcN7dM47bB8Cn2iCIsPwmqiorLIE5MiF91d/hYvzhraBaMdCHzivJx2XY3c/NLBir7lYzqvNRxBYARG4Jk0uPBbdMnGovQP64h84V3lPeThrKE9AbWDCVxank6fXyu3//OQDI5W9tbTk2XuEOGsoS2QdiBw+fkKq5wqtd64f/hYWS8FcNbQFkg7EDhe3r66pF42FSpzD/mSMh6zdNbQFkg7EHhm+fvNymbpPpLuFetlmw8hMAIjcFpNcNaigrz63mBqAoenxZjATGAmcIpnMqdcu0c27O5LReDGzlEERmAErsTTXBtr+xMXOFwwK3UHCGcN7d+g2sFv4GTz+bkFtan8Jj51XmnPRjtraAukHQicfE6XbT6UuMBfvLGAwAiMwJV6L3XShEbLBGYCM4ErIPCXbt6buMBh90UERmAEroDA5y+pT1Te8DK+Uj/bWaMSB7SaIw+/gc+7rS5662Slti/5fzH7nobEH6cs9bOdNbQPtnbkQeCvL3t/4r3dPDSj19EkFQs3dEiS1HaMlPzZzhraB1s78iTw8dPN8CL3M0u86JNGvHNgWJIkPCBS6mc7a2gLpB15E3jqy+Hu/Neh6L5sJb/LLx5pkqRZvuVwyZ/vrKEtkHbkVeCp+xA98GpndGEp7e9x1qKCtPeOS9L8dlULAiOwTYGnvmMqLAq49LHmkm/JlBPnL6lPZWPxycnSH+II4ayhUXDVFFYEnn56Hbb5vGJVi3z6uppE3p01mNKbOuqKpV/AQuAqEAqB0xd4KuGiV6FjRNa81RNt+fndO/eddMfAcKsqbM9y5ROt0etuwil6moTX+CAwE5gJXCZh25XwgvW9B0fk3bbhaBK29oxV7FU6x0+fwz1uBEZgBM4gbzTyWll+A/MbOLNcEmPLUWcN7d+g2mHxIlZep69HYH2hEBiBx45OyjdiPhLqrKEtkHYwgauPhRs6Yh9PZw1tgbQDgauLTYX+aANyBEZgBM4YO1uGogdDZtKQnTW0J6B2MIGrg+2NR+SM+TNfeOGsoS2QdiCwPuvf6S1r/yMERmAErgIGRiaizcSTbMjOGtoTUDvyMIG/cmtd9OhjVpiYFFm7q1fOvmVv4rlw1tAWSDvyIHCIcAr64wcb5d6tnbKjZaiizyyXSvhOz/+nT751R3qv/XHW0BZIO/Ii8PQIOxn88P79smRjUbbUD1R8Y+6p1LSPyOKXizLrpuQnLgJXQbEhcPo5CPdWw6L7yx9viXZOeGlPv9QXR2X06GTiK4hausdk3a5euWZdW9mriRCYCVxWEeR1Ape7Pej3722Qq9a0yvwXO6I1uCve6IpOd7e+NxhtHTo9Nu8diNYDh/duXf9CR7Q+ePbyBvnsDcm/7aOccNbQLh6CHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4bf4LtvMh68AvCz8AAAAASUVORK5CYII=",
    Bj = "/assets/threejs-fe160e71.svg",
    Pj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAPOSURBVHgB7d3RbdRAFAXQt4gC6IClA0oIHdABoQLoAFIBogLoADqADiiBUAGhgmFMDIpASQDN2H7jc6TIP1F2P3L17tovkwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGD7DsFulFJOo5/3h8PhIoD2anhflL7uB4szgXeghutYL5+jr2OdwF+CRd0J9uBDMCQBHtxUnevlGAxJhR5YDe/DevkUy1ChV2ACD6qG9169vAuGJsDjehWq8/AEeEDz897TYHgCPJj5kdGLYBcEeDyq844I8EDq9H1WL4+D3fAYaRALbVvdxGOkFZjA47BttUMCPADbVvulQie38LbVTVToFZjAidm2QoBz88ho5wQ4KdtWTAQ4IdtW/CTAObnrzA8CnMy8bXUaEAKcylydXwbMBDiXadvqXrRxHqQnwEl02LZ6FKQnwAl0qM5nh8PhPEjPKuXGzdtW06rkMdo4r+F9MP/sEu1YpVyBCbx9qjPXEuANm7etnkc7qvNgVOiNmj/3Tnedj9HGr+p85TVU6ORM4O1SnbmVAG9Qh20r1XlQKvTGzNV5uuvcbGHj9+p85bVU6ORM4O1puW01UZ0HJsAb0mHbSnUenAq9ER2Ohb22Ol95TRU6ORN4A+Ztq9bHwqrOOyDA26A6Q0bTtlVp669reGnrfrA4E3hFpc/ZVqrzjgjwulpX59eqMyygTt9npa3P5fJm2L+8h5ZU6BWYwCsofc62elqn70WwKwK8jtbbVlN1/hjsjgAvrLTftjoPJ1Xulk2sBZU+/4T70f9O3+mDa7RjE2sFJvBCSp9tK9V55wR4OaozzQnwAkr7s60mZ+46Q2fT5975GW1Lb6KB0pbnwCswgfvrUZ3PAkKAuyp9/pOgvzSC3spldf5a2mpSna+8x5ZU6BXcDXppvW01+VIub4ht0eP63r7d9k21PbwNmrHI0UG53LZ6GfyhBtjvXEM+A/dxErAAAYbEBBgSE2BITIAhMQGGxAQYEhNgSEyAITEBhsQEGBITYEhMgCExAYbEBBgSE2BIzB9Xd1BKOYm2B9m1dlK/nkRb07G5TuSA3qZjeUp7zsRagQoNiQkwJCbAkJgAQ2ICDIkJMCQmwJCYAENiAgyJCTAkJsCQmABDYgIMiQkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMC+fQf3zR5POa3VsQAAAABJRU5ErkJggg==",
    Rj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAY/SURBVHgB7d3xcRQ3FAfg50z+h1SQpQJIBRwVBCqIUwFJBeAKEiqwqQBSgY8OTAVeKoBUoEjs3pgwxtg+rfb2/H0zmvMQJjlm+OVpJT1tBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwCwOgsVLKXX541Ee9/MoP98bf/7ahzw+5dGXcXBwcBYsmgAvTA5rCeYqj8fjZxeXh/W6zsbxLo91DnUfQF05uE/zOM3jY5rWaR6H4/8ogNsqIcrjRYPQXuY8j+M0TM+Bm8jBeT5TcL9WvsOLAL4vh6VLwzR215wn1Ri+LQfkt7QbVfcqfwTwf2l41l0KU2rYSMsK74YQQ1pmeDeEeGYOcswoB2CVP05j2Z4cHBysg1kI8EzSsKJbwtvFsvV5/JJD/Clo7odgLmX62cXydTH8WZiBCjyDsfqex3554Bx1eyrwPP6K/WN/eAYqcGN7Wn2L8gz8wLNwWypwe/v6vFi6lw6DplTgxnIF/hjb9e9+T6mA67ho3i8exrDY9CimVfqJnwTsozT09E7lfPz337/iv18aJU7SdD4G7Ks09NdOoYTy2lU9/95HaQj8FKau8nzBM3BbU/zlfpunrYc3WTwa78J6FtMQ4IYEuJGxQtb+y93n8Wfcwhjio6ivC5oR4HamqExHWx6e+DsuFrpqcZdWQwLcThf1rWML47S79tWy94JmBLidLuqqdQXsP8FiCXA7XdT1PuqoPYX+N2hGgNupPbWsNfWtHWBHKRv6MWjl97jlivE31ApK7UWnPmhGgBsZF4x2sToJ8IKZQvM46vLCtIYE+A5LFy9Kq2WtnbAtAb7bnkfdKbQtKWhhbGiorQtgWjloq1T/FS7HAUwnDf3Ax2kaXdCcbaQ9li46oMr4NeouWH3pxI2U83ClzoKN09bukn9Ufu1+tOkM6mN4O0MfNCfAC5YDXG637GJez3J43wazsI3ENo6Ed14CzG2V8L4MZmURi5sqJ63+zOE9CWYnwNzE58vwLFjtDlNormNTdX8R3t2iAnOVUnFfx7DPq0lhB6nAXOVzD7Pw7i77wAvWcB+4z+Mkj9em0FBJmu71KN9ynsdhsDNMobmJLo/jHOJTzQu7QYC5jVUeJcTegzQzAea2uhhCvApmI8Bso3Q7vVGJ5yPAbGsT4i5ozkGOZesv+bVWfcBf6vIovclPgqbsA++p8TaOLoYwlynu4/Gzi+mUxv51ANPIwX46bgNNsk8cwPTKgYw0zUGQVQDTS8MtlbWvlz0NoI003BFdW+tFtDvLNtIdNy46raOup0ETAkxxFHU52NGIbSQ+y9Pej1Fv//is3N4RTE4FZqOPerqgCSexGsjV7a+oO608zBXuQ9T1Pup9x/tlIctNHtMT4DZKMFZRz0951A5wbfdiuJKHCZlCt1E7bF1ACHArtSvRFKu8PweLI8Bt9FHX46jP1s8CCXAbfdS1qnnaKQ0N+U5PLZAAt3EW9b2Iep5HZROsknMJBzkaqXxQYmPr/ts03KRRuw2wz9/rQTA5FbidddR3nLa/yuZN1NcHTQhwO++ivi5ueb1reYYeW/+mWLx6H7BPxsBM6fg61Xj8HlM182+sgiY8AzeUhoq3immdjaNUwS/3n8vz98MYWv2mXHEuL0P7KWjCUcq2XsX0AX4U8+7pvg2aUYEbS9OsRu8SN1M2ZBGrvdrN87ukF962VOAZpHbv9W3t9xzgk6AZAZ7BuEq7b7c3uoVjBqbQMxinma9ivzwLmhPgmeQQ/xHTnJGew1H+8/RBcwI8r1K1+li2Vzm8L4NZeAae2Xh6qjwPd7E8r3N4D4PZCPAOWGiIhXcHmELvgPL8OLbfLWVh60h44RINGg22cZ40KsDV0vDWwL/Tbinfx7U7cF1pCPJJmrciH6ftLw2Auy0NU+s3qY3zPF4mFXfnWYVemDFUq3E8jDrtiaVveB3DrSFvHcpYDgHeA+niWtjN5+aS9u6r39qPnx/Gn0twzwQWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2N5/m1Zxa74fzuYAAAAASUVORK5CYII=",
    Ij = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAHfSURBVHgB7dzBiQJBEEDRmmXzWjNZUzADzdAMTMEM2klBEPTje1D0pa8f6lQzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDX2IaPstY67M//vNd927bTAM/ZAz6u97sNCT8DZAkYwgQMYQKGMAFDmIAhTMAQJmAIEzCECRjCBAxhAoYwAUOYgCFMwBAmYAgTMIT9Dp/mus/lif9/+xwG6FlrndfrOakTYYWGMAFDmIAhTMAQJmAIEzCECRjCBAxhAoYwAUOYgCFMwBAmYAgTMIQJGMIEDGEChjABQ5iAIUzAECZgCBMwhAkYwgQMYQKGMAFDmIAhTMAQJmAIEzCECRjCBAxhAoYwAUOYgCFMwBAmYAgTMIQJGMIEDGEChjABQ5iAIUzAECZgCBMwhAkYwgQMYQKGMAFDmIAhTMAQJmAIEzCECRjCBAxhAoYwAUOYgCFMwBAmYAgTMIQJGMIEDGEChjABQ5iAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+2wMt5uVAuWwRYQAAAABJRU5ErkJggg==",
    Lj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAATMSURBVHgB7d3hcRs3EAbQZcb/k3RAVxB3ELqDdGB2YHdgdeCkAiUVOB2IrkDqgHQFUirY4HzUjMZjWbIE4HjkezMYNqBPAPYWQAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAkFsHRyMxl+XlVxi93xtd2Zdzsx9VisbgJZkuAZ6qEdQjnqozf97/L+HZgH/IlyGV8KmNTAr0JoL4htGWsy7jIdrZlnJexCuD59sF9X8Z19rUtYx3Aj5swuF/bpiDD45XArPbBOSTnORbKgPvkOOseqm0K8cFQhT4wJRzn5Wcdh22oXL8uFeurYFICfCBy/Cx0EeN33DkQ4gPwU3Aohpl3LuEdfPmHYzk9LQE+ACUEH8rPHzE/tyF+SgMJFQjwxMof/9vy8y7ma1nG+2AS9sAT2i8/L+NpLZCH5rU2zP7MwNMals7Hsvw0C09AgCeSY2fTHPe99xkaT1ZBV5bQExkaImLcPx6T4TTT66AbM/AE9rPvMo7PSkW6LwGexptobxfjOd/N/reXdcCxGirP2c5waunsvlkwxwMSf2dbFwHHqvyBv8s2hmA+avma4z+RbbZxnZbRHKtsc5vGWfygbBviObWEwuPkeEC/tm08UY5L6hbWQReKWH2tor4nf7bZd05toj4zcCcC3Ncq6hq+u+7ief6J+n4OuhDgvn6LumqE79+obxl0IcB91a7ObuKZ9he774JZEuC+au4Nryosn2/Vfp1hGXQhwJ1k/ZsrPkc9tQPsuZZOBLifZdS1i8MlwJ0I8HwJCfEi6GkX9dQMcO3i2i7oQoA72TdNvIzDVLvxoub+nO+whD5x2eYWDXdFdyLAtLjWZxd04UqdE5f1r/a5KduFX4MuzMAnLMdjf8uo61PQjQCftrdRX4veau5hCX2i9p1hTz5L/B0vK7Z48gAz8OlqcRH7RnihsWx3sd46gLZK0C6zvhbLcR5gCX1icnwNscWVNy1u9uABilgnJNu+hqh4NQEz8GkZLl1vEd6/hBcaKrPv+2xjm/UvKwBuDfvebOddAG2UgL3K8bmTFlSeoZVs+3zKwAXu0EKH8P4ZQH05vsHUolnj1ja9QAj1dQjvYBlAfSVcH7OtswDqK+E6z7bse6G2HJfNF9nWNu17oa7ss+fdpn0v1NUpvNfCC5Vl+++8t1pcOwunq2N41wHUk217m+9ySAFqKqF60ym8ZwHUk+3O8wovtFRC9SH7WAdQR46fiVq3Rg6uhRcqyn6V5iG8zvVCLTlWmrfZ3jY1aUA92a/SfCm8UFH2qzQP+2oHE6CGHItV59nHWQB1ZN9ile4qqKUEapX9ilUqzVBLtr1s/a6LVKyCerJfZ5UrcI6c1wk7yrHy+7GMVfSxi2mtFovF56CZF0EX+/AOT3suo59lcNQ8L9rPEOBlQEUCDDMmwDBjAgwzJsAwYwIMMybAMGMCDDMmwDBjAgwzJsAwYwIMMybAMGMCDDPmOGFfmzgt/wUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANDM/xzvV0XtAeJqAAAAAElFTkSuQmCC",
    Dj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAUMSURBVHgB7d2NbRRHGAbgb6MU4A5yVABUEKggdMBRAe4AUwGkAo4KSCqwqcDuwJsK4g4ms9pFtqxDQWZmd2f9PNKns6yzJUv3embnNwIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeDS6YFYppX1+eR3b9bnrukMwi1+Due1yvYjt+hrM5pcAmiXA0DABhoYJMDRMgKFhAgwNE2BomABDwwQYGibA0DABhoYJMDRMgKFhAgwNE2BomABDw2zob9ubXH2sSx/MRoDbdt513T/Bo6ULDQ0TYGiYAEPDBBgaJsDQMAGGhgkwNEyAoWEWcjxCKaXd/e91XdcHzRHgDctBPckvr3I9jfE+pl2uk++8d3jpp7qK8Y6jK8GGO3JQzlI5vx35/Se5TnOdpzIuc+3TkVYbHp1UKcBpDO67XP+mej4lQV4Vg1gbkEP1Ir9c5jqL73SRC9nnuh7+UQSrIMCNm8J0HuPz7VyGXsS11nh5Aty2s6mWsIuxNT4NFiPAbdvH8j7oUi9HgCnhTEu8DAGmlA/TYBozEmBK+mJga14CTEnDFNanYDYCTGkvciv8KpiFAFPD8Dxcc0EJEwGmhl2sY4pr8wSYWt4G1QkwtexMK9VnP/B23eT6HLd7fG+m7+9yPYvbPcI1vc51EbAVqex2wmPOf7TlG+Zscx1SPcPWRoNZFelCb8v7rute5rr4kTcPp23k2ucvn0SdS8mG8D4LqhHg7RjCexYPMB2b8zLqhNiccEUCvA2Hh4b3mynEb6K8p0E1ArwN76OAqev9OcrSha5IgNt3KHxy5CHKGs7q+i2owjTS/C6irL+ioKEVzoHro+wRPc9zuYgc5pAD/DGVtQ+q0IXmmKsoaxdUIcAccxM0QYA5pnSADWJVIsDQMAGGhgkwczCFVIkAc4zVU40QYI7ZRVlGtSsR4Bml8Z7dks6jjt+jrD6oQoDb9iwV3jCfxoPZS3eh+6AKAZ5X6RVOQ3j3UVaNw+j6oAoBnlcf5b0t1QpPrW/pDfhXXdd5Bq5EgGc0fZD7KGuXq9T1nu+i/ACWKaSKBHh+X6O80/STd/ROP7+P8opud4RF5aCcpnoeFOLh51I9u4CtyB/ok1TXdRqnq/73uTi/Z7iI7DLVcxlU1QWzS+P87Yuo7yLGke/hOfTuwe7fDnWvfWbzm/zcfwiqEeAFpPH6zS+xfU8Kn9fFPQaxFpA/1MPATh/bdhDe+gR4OUWOgl2xrf99qyDAC5meDUuvzFoLre9MPAMvKI2XkNXakLCUPtdLAZ6HFnhB000IW+tqvhfe+WiBV2DGaaXa/szhPQ1mI8ArMC26GBY97KJdfa7nNi7MSxd6BaYPfa3rPefQx/jcK7wzE+CVuHNHb2sj030YtFqMAK/IEIJcw0VgrQxsXcTYbe4DuDVtSLhO6/UxgO/LIdml8jcF/qzzNM5fAz8ijUE+pGVdJ9eEwsOlMchD17rmHt77ztO4e4oVMg/cqHR7AN0fMR4DW2pv7zAVNIyE/x3jmmZTQysmwBuRAz2EeBdjmIcN+ydxuzBkd+/tN3eqj3HD/xDa4QTJrW6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACO+w/L23L1ab7KMgAAAABJRU5ErkJggg==",
    Fj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAasSURBVHgB7d3vcRvHGQfgV5kUoFRgqAKrA0MV2KrAdAW2KxBdQeQKRFeguALSFYiuAJcKyFSw2fUdE5pDyRL57h4APc/MDkYz4gEf8MO7t7d/IgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFbxJDgqpZRNfXla283rXddLm548eTIFB02AD9gS1m9q+7K25/H+0H7I5dJ+q+1CqKGjGtrntb2qbVf6eFfbyfLjAGSogdrWdl7GeiPI8AgtQCsE965XtX1q1xw+bzU039d2VfbDrrbnAXxYDcrTsn7VfZ9XAdyvzF3mXdlvQrwnPEbaI2UeMDqP+XHQvjurj5y+C1b1t2AvHFh4mxOVeH0q8J6oYWjh3cbh+bFW4tfBKlTgPbBUsm0cplfFs+LVqMArW778uzhsbQrmi2A4FXh953H42iyxk2A4AV7R8qXfxHEwoLUCAV7XMX3pN6rweAK8kiOrvje+DYYyiLWSGuA2cLWJfG2x/i/x/3W+7d9Pl/Z8aV/Hp68b/lgv6oDWRcCxKvPSwGy7dt2PfP/W3T0tfXgmzHEr8zrbTGflAcv9yrw5QPZqp6uAY5YcmrfxCKVPb+CLYAiDWIOVuZubdf851faoBQXL/erPketlMIQAj5c5UvtTDeB1PN5p5PoyGEKAx9tGjjZ98SwSLD8CF5HHzh2DCPBAZZ73vIkcv0SuzOttgiEEeKysyjRlVd9b/hV52pZANsEb4O/BSNvIcRHJlm60iT0HRgUeK2tw59eAEODRsrrQlwEhwMOUeU/ljPtCh5LxPwI8Ttagzu8BCwEeJ20EOmBhFHqcTeSY4hGWxzu3ewPXSbO5WIEAj5M1wf+jB7CWedet8n+1vN4N783/ay/T0m7OCr50rw2LknfW0fO/eJ+2uuifJWfF03lxVjDMO3CUHF+85/q9zw9+UwSZz1VJWgN8z3XbtMW3ZZxW3U2T3BOmzg1yX/geot6XPrl1zW19eRPjFw9Mtb2sH8WEkpV5jDRAYsW6vnXNtq54rcPQNrW9Kw43W50Aj5Ea4CW8Z7G+UyFelwAfmDIPJJ3F/hDiFQnwGJvIs49nKbUQ/xAMJ8CHZRP7u9tFG522lc5gAkymtx4xjSXAZNrUpis9kACT7XtVeBwBJlsLryo8iADTgyo8iADTQwvvSdCd9cDHp83Wans8/7GmN25Nv4w5WJvavol5jfAm+mlnEL8OOHRlPo+3t12bTPEpXdcyr/XdlX50ozl8pX+AH3Q+8PLZei5HPAm6cg98+NoJhScP3deq/V1t7TjQ7LOWGjOzOA6lj0cd7n3n87VKvCu53gVdWdA/SPs2R75nmRvPlXmDgMzFEq26/yPoRhd6nClynWXvGlmvdxG5B6e1qp61Gyf3EOBxsvde/jn6+C1yPQu6EeBxpsgzddyPKvOc4GYTdCPA4/wn8kzRzxQcDAEeZ4o8U3SyPI6aIs8m6EaAx5kiz78DQoBHsocy6QR4nCnyeDTDHwR4kOR7y96TIzaRx9GlHQnwWFnPWL+KTkr+zpJT0I0Aj5V1H/x0mfbYQ3aAVeCOBHiszIGsbfTxbeTaBd1YzDBYrZxXkXNWUqtszx66jPA+ZT62JTNwFjN0pgKPl9aNri37TKK05YkLj846E+Dxfo08bQudlBAv18m+//094JgsC+ezPSrE7e9LH9uAY1O/2OclXztwe/OJn2Pb6bM0V0F3tpVdR+tGbyNX6/7uanAuluu3+8/Lu4NcS8jbtrJfR7+R7CZ7WSL3MAq9gjLvINlGe0dtuzot7zVym9eX9cdDiDsziLWCpSr22lHjPpsYG95JeMcQ4PW0UwuOdZbST8EQArySFarwKK36ngVDCPC6WhWe4riovgMJ8IqWKvxdHI8z1XcsAV7ZshfzMXSlp1B9h/MYaQ8sj5XaiQiHfJbQi+XHiIFU4D2wdKXbAWNTHKYfhZfPXpmPId2Vw3IawKwcVoh/CODPyhzid2V/7YqVRvBhNSSnZf+8LfOgG/BXylyNz8r6dkXVhYcp89rdNYJ8XttJAI9X5orcttLpeY98VdvrouLuPRM5DliZF+dvl9aOW2kTQR5yfzrFvAFA23j+0jPdwyHAR2YJdWtP77Qb17faFPPqIZuvAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/0X9oIYFYBj0U+AAAAAElFTkSuQmCC",
    kj = "/assets/boxa-travel-ba1dffe3.jpg",
    Nj = "/assets/farmateket-ba7d11f7.jpg",
    Oj = "/assets/valley-of-health-7851a5f2.jpg",
    Uj = "/assets/earlybirdsproperties-dae2ee3f.jpg",
    zj = "/assets/carhelpline-6dd841ae.jpg",
    Gj = "/assets/photoboost-74699aff.jpg",
    mT = [{
        id: "about",
        title: "Über Uns"
    }, {
        id: "services",
        title: "Dienstleistungen"
    }, {
        id: "sequence",
        title: "Ablauf"
    }, {
        id: "examples",
        title: "Portofolio"
    }, {
        id: "price",
        title: "Preise"
    }, {
        id: "contact",
        title: "Kontakt"
    }],
    Hj = [{
        title: "Individuelles Design",
        icon: lj,
        text: "Professionelles individuelles Webseitendesign, Logos, Social Media-Beiträge und vieles mehr."
    }, {
        title: "Höchstleistung",
        icon: aj,
        text: "Spürbare Webseiten-Exzellenz und blitzschnelle Ladezeiten – unsere Unternehmensmission."
    }, {
        title: "Webentwicklung",
        icon: sj,
        text: "Professionelle statische Websites, perfekt für Markenbildung, lokale Unternehmen, Blogger und Influencer."
    }, {
        title: "Softwareentwicklung",
        icon: oj,
        text: "Wir entwickeln Webanwendungen jeder Art sowie mobile Anwendungen, Serverseitige Optimierungen."
    }, {
        title: "Suchmaschinenoptimierung",
        icon: dj,
        text: "Machen Sie sich in der digitalen Welt mit der besten SEO-Konfiguration bemerkbar."
    }, {
        title: "Digitales Marketing",
        icon: hj,
        text: "Google, Social Media oder sogar E-Mail-Marketing – unser Team kann Ihnen bei der Geschäftsverwaltung helfen."
    }, {
        title: "Wordpress-Spezialisten",
        icon: pj,
        text: "Alles rund um Wordpress. Unser Team unterstützt Sie bei Ihren Anforderungen."
    }, {
        title: "Felsenfeste Sicherheitsstandards",
        icon: mj,
        text: "Alle unsere Websites sind gut vor Hackern und Datenverlust geschützt."
    }, {
        title: "Vollständige Reaktionsfähigkeit",
        icon: gj,
        text: "Alle unsere Websites und Anwendungen sind auf allen Geräten vollständig reaktionsschnell: Desktop, Tablet oder Mobilgerät."
    }],
    Vj = [{
        name: "HTML 5",
        icon: _j
    }, {
        name: "CSS 3",
        icon: yj
    }, {
        name: "JavaScript",
        icon: wj
    }, {
        name: "TypeScript",
        icon: Tj
    }, {
        name: "React JS",
        icon: Cj
    }, {
        name: "Redux Toolkit",
        icon: Ej
    }, {
        name: "Tailwind CSS",
        icon: bj
    }, {
        name: "Node JS",
        icon: Mj
    }, {
        name: "MongoDB",
        icon: Sj
    }, {
        name: "Three JS",
        icon: Bj
    }, {
        name: "git",
        icon: xj
    }, {
        name: "figma",
        icon: Aj
    }, {
        name: "docker",
        icon: vj
    }],
    Wj = [{
        title: "Unsere kostenfreie Strategieberatung",
        text: "Wir bieten Ihnen eine persönliche Erstberatung per Telefon, Zoom, Skype oder vor Ort an, in der wir Ihre Projektanforderungen ermitteln und gemeinsam erste Konzepte entwickeln. ",
        company_name: "Starbucks",
        icon: Ij,
        iconBg: "#A08449",
        date: "Step 01"
    }, {
        title: "Ihre individuelle modulare Kostenschätzung",
        text: "Innerhalb von 3 Werktagen erhalten Sie basierend auf Ihren spezifischen Anforderungen eine individuelle Kostenschätzung für Ihr Projekt. Unsere Angebote können modular gestaltet werden, um Ihnen die Möglichkeit zu geben, den Umfang des Projekts nach Ihren Bedürfnissen anzupassen.",
        company_name: "Tesla",
        icon: Lj,
        iconBg: "#A08449",
        date: "Step 02"
    }, {
        title: "Initiierung Ihres Webprojekts",
        text: "Nach Zustimmung zum Angebot beginnen wir das Projekt mit einem Kick-Off-Meeting. Wir halten Sie kontinuierlich auf dem Laufenden und gewähren Ihnen regelmäßige Einblicke in den Projektverlauf.",
        company_name: "Shopify",
        icon: Rj,
        iconBg: "#A08449",
        date: "Step 03"
    }, {
        title: "Gestaltung des Webseitendesigns",
        text: "Während dieser Phase erstellen unsere erfahrenen Designer Ihr individuelles Webseitendesign oder passen bei unseren Vorlagen-Webseitenpaketen ein Design anhand einer Vorlage an. Ihre Vorstellungen sind dabei maßgeblich, und Sie werden kontinuierlich in den Designentwicklungsprozess einbezogen.",
        company_name: "Meta",
        icon: Pj,
        iconBg: "#A08449",
        date: "Step 04"
    }, {
        title: "Realisierung des Online-Auftritts",
        text: "Nach Festlegung des Webseitendesigns beginnt die Umsetzung und Entwicklung. Unsere Webdesigner programmieren Ihre responsive Webseite oder Ihren responsiven Onlineshop gemäß Ihren Anforderungen und führen parallel dazu unsere Qualitätssicherungsprozesse durch. Auf diese Weise gewährleisten wir, dass Ihr Online-Auftritt höchsten Leistungsansprüchen genügt und Sie mit dem Ergebnis vollkommen zufrieden sind.",
        company_name: "Meta",
        icon: Dj,
        iconBg: "#A08449",
        date: "Step 05"
    }, {
        title: "Überführung auf Ihren Server",
        text: "Zum Abschluss des Projekts überprüfen wir gemeinsam das Ergebnis und setzen gegebenenfalls letzte Änderungswünsche um. Mit der Überführung von unserem Entwicklungsserver auf Ihren Live-Server beginnt die Erfolgsgeschichte Ihrer Webseite. Wir begleiten Sie selbstverständlich weiterhin mit höchstem Engagement auf Ihrem Weg.",
        company_name: "Meta",
        icon: Fj,
        iconBg: "#A08449",
        date: "Step 06"
    }],
    jj = [{
        name: "Boxa Travel",
        description: "Boxatravel ist eine auf Web 3.0 basierende Reisebuchungsmaschine, die Krypto-Zahlungen sowie ein Empfehlungssystem zum Sammeln von Punkten unterstützt.",
        tags: [{
            name: "PHP",
            color: "blue-text-gradient"
        }, {
            name: "MYSQL",
            color: "green-text-gradient"
        }, {
            name: "tailwind",
            color: "pink-text-gradient"
        }],
        image: kj,
        source_code_link: "https://www.boxatravel.com/"
    }, {
        name: "Farmateket",
        description: "Farmateket ist der norwegische Online-Shop Nr. 1 für Nahrungsergänzungsmittel mit fast allen verfügbaren Zahlungsoptionen, darunter Paypal, Klarna, Swrill usw.",
        tags: [{
            name: "PHP",
            color: "blue-text-gradient"
        }, {
            name: "MYSQL",
            color: "green-text-gradient"
        }, {
            name: "Bootstrap",
            color: "pink-text-gradient"
        }],
        image: Nj,
        source_code_link: "https://www.farmateket.no/nettbutikk/Give/"
    }, {
        name: "Valley of Health",
        description: "Valley of Health ist ein einzigartiger Superstore für Nahrungsergänzungsmittel mit Sitz in den USA. Die komplette E-Commerce-Lösung wird in WordPress entwickelt und in alle wichtigen Zahlungsgateways integriert.",
        tags: [{
            name: "WordPress",
            color: "blue-text-gradient"
        }, {
            name: "WooCommerce",
            color: "green-text-gradient"
        }, {
            name: "Elementor",
            color: "pink-text-gradient"
        }],
        image: Oj,
        source_code_link: "https://valleyofhealth.net/"
    }, {
        name: "Early Birds Properties",
        description: "Ein umfassendes Immobilienportal auf Basis von WordPress, das alle Bedürfnisse von Immobilieneigentümern und Kunden abdeckt. Es handelt sich um ein in Dubai ansässiges Unternehmen.",
        tags: [{
            name: "WordPress",
            color: "blue-text-gradient"
        }, {
            name: "MYSQL",
            color: "green-text-gradient"
        }, {
            name: "Elementor",
            color: "pink-text-gradient"
        }],
        image: Uj,
        source_code_link: "https://earlybirdsproperties.com/"
    }, {
        name: "Car Help Line",
        description: "Ein einzigartiges Konzept für Pannenhilfe und Autoreparaturen. Zusammen mit den iPhone- und Andriod-Anwendungen wird eine umfassende Laravel-basierte Web-App entwickelt.",
        tags: [{
            name: "PHP",
            color: "blue-text-gradient"
        }, {
            name: "MYSQL",
            color: "green-text-gradient"
        }, {
            name: "Bootstrap",
            color: "pink-text-gradient"
        }],
        image: zj,
        source_code_link: "https://www.carhelpline.pk/"
    }, {
        name: "Photo Boost",
        description: "Ein Snippet, mit dem Sie die Fotos bearbeiten können, ohne die Qualität zu beeinträchtigen. Wir haben die Software auf Basis von Laravel und Python entwickelt.",
        tags: [{
            name: "WordPress",
            color: "blue-text-gradient"
        }, {
            name: "Ocean Wp Theme",
            color: "green-text-gradient"
        }, {
            name: "Elementor",
            color: "pink-text-gradient"
        }],
        image: Gj,
        source_code_link: "https://photoboost.co/"
    }],
    Jj = [{
        name: "Individuelles Design",
        description: "Logos, Social-Media-Banner, Poster usw.",
        package_01: "ab ",
        package_01_price: "€99",
        package_02: "",
        package_02_price: "",
        points_heading: "",
        points: []
    }, {
        name: "Webdesign – Basic",
        description: "Webseite gestaltet auf Basis vorhandener Themes",
        package_01: "Standard-Einseiten-Website in Wordpress ab",
        package_01_price: "€1,550",
        package_02: "Jede weitere zusätzliche Seite",
        package_02_price: "+ €500 /Seite",
        points_heading: "Enthält:",
        points: ["Vorlagendesign", "Sicherheitsoptimierungen", "DSGVO-Optimierungen", "Grundlegende SEO-Optimierung", "1 Überarbeitung", "1 Woche Support"]
    }, {
        name: "Individuell gestaltete Webseite",
        description: "Professionell von unserem Team gestaltete und entwickelte Webseite.",
        package_01: "Einseiten-Website ab",
        package_01_price: "€2,750",
        package_02: "Jede weitere zusätzliche Seite",
        package_02_price: "+ €850 /Seite",
        points_heading: "Enthält:",
        points: ["Individuelles Design", "SEO-Pro-Optimierung", "Sicherheitsoptimierungen", "DSGVO-Optimierungen", "1 Jahr kostenlose Domain und Hosting", "1 Jahr kostenlose geschäftliche E-Mail-Adresse @ihredomain.at", "2 Überarbeitungen", "2 Wochen Support"]
    }, {
        name: "Komplettpaket Webseite",
        description: "Professionell gestaltete und entwickelte Webseite in der von Ihnen gewählten Programmiersprache, z.B. Java, Python, Ruby usw.",
        package_01: "Einseiten-Website ab",
        package_01_price: "€ 4,750 ",
        package_02: "Jede weitere zusätzliche Seite ",
        package_02_price: "+ € 1,050 /Seite",
        points_heading: "Enthält:",
        points: ["Individuelles Design", "SEO-Pro-Optimierung", "Sicherheitsoptimierungen", "DSGVO-Optimierungen", "Integration von Live-Chat", "1 Jahr kostenlose Domain und Hosting", "1 Jahr kostenlose geschäftliche E-Mail-Adresse @ihredomain.com", "4 Überarbeitungen", "3 Wochen Support"]
    }, {
        name: "App-Entwicklung",
        description: "Professionell gestaltete und entwickelte Web - oder Mobilanwendung.",
        package_01: "Grundlegende App ab ",
        package_01_price: "€ 15,750 ",
        package_02: "",
        package_02_price: "",
        points_heading: "Enthält:",
        points: ["Individuelles Design", "Einrichtung von Servern", "Administrationspanel", "Einrichtung von Arbeits-E-Mails", "SEO-Pro-Optimierung", "Sicherheitsoptimierungen", "DSGVO-Optimierungen", "5 Überarbeitungen", "4 Wochen kostenloser Support"]
    }, {
        name: "Weitere Dienstleistungen",
        description: "Alles, was Sie in der digitalen Welt benötigen.",
        package_01: "ab",
        package_01_price: "€ 100/Woche ",
        package_02: "",
        package_02_price: "",
        points_heading: "",
        points: ["*Social-Media-Management", "*SEO-Management", "*Digitales Marketing", "*Live-Chat-Support-Mitarbeiter", "*Website-Management", "*Server- und Backup-Management."]
    }],
    Xj = () => {
        const [n, e] = U.useState(""), [t, i] = U.useState(!1), [r, s] = U.useState(!1);
        return U.useEffect(() => {
            const o = () => {
                window.scrollY > 100 ? s(!0) : s(!1)
            };
            return window.addEventListener("scroll", o), () => window.removeEventListener("scroll", o)
        }, []), le("nav", {
            className: `${pr.paddingX} w-full flex items-center py-5 fixed top-0 z-20 ${r?"bg-primary":"bg-transparent"}`,
            children: it("div", {
                className: "w-full flex justify-between items-center max-w-7xl mx-auto",
                children: [le(Ck, {
                    to: "/",
                    className: "flex items-center gap-2",
                    onClick: () => {
                        e(""), window.scrollTo(0, 0)
                    },
                    children: le("img", {
                        src: rj,
                        alt: "logo",
                        className: "object-contain"
                    })
                }), le("ul", {
                    className: "list-none hidden lg:flex flex-row sm:gap-6 gap-8",
                    children: mT.map(o => le("li", {
                        className: `${n===o.title?"text-secondary":"text-white"} hover:text-secondary text-[16px] font-medium cursor-pointer`,
                        onClick: () => e(o.title),
                        children: le("a", {
                            href: `#${o.id}`,
                            children: o.title
                        })
                    }, o.id))
                }), it("div", {
                    className: "lg:hidden flex flex-1 justify-end items-center",
                    children: [le("img", {
                        src: t ? fj : cj,
                        alt: "menu",
                        className: "w-[28px] h-[28px] object-contain",
                        onClick: () => i(!t)
                    }), le("div", {
                        className: `${t?"flex":"hidden"} p-6 black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`,
                        children: le("ul", {
                            className: "list-none flex justify-end items-start flex-1 flex-col gap-4",
                            children: mT.map(o => le("li", {
                                className: `font-poppins font-medium cursor-pointer text-[16px] ${n===o.title?"text-white":"text-secondary"}`,
                                onClick: () => {
                                    i(!t), e(o.title)
                                },
                                children: le("a", {
                                    href: `#${o.id}`,
                                    children: o.title
                                })
                            }, o.id))
                        })
                    })]
                })]
            })
        })
    };
var wI = {};
Object.defineProperty(wI, "__esModule", {
    value: !0
});
var Zc = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    },
    Qj = function() {
        function n(e, t) {
            for (var i = 0; i < t.length; i++) {
                var r = t[i];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
            }
        }
        return function(e, t, i) {
            return t && n(e.prototype, t), i && n(e, i), e
        }
    }(),
    SI = U,
    Kj = Zj(SI),
    Yj = gm;

function Zj(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}

function qj(n, e) {
    if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function $j(n, e) {
    if (!n) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}

function eJ(n, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var tJ = function(n) {
        eJ(e, n);

        function e(t) {
            qj(this, e);
            var i = $j(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
            i.state = {
                style: {}
            };
            var r = {
                reverse: !1,
                max: 35,
                perspective: 1e3,
                easing: "cubic-bezier(.03,.98,.52,.99)",
                scale: "1.1",
                speed: "1000",
                transition: !0,
                axis: null,
                reset: !0
            };
            return i.width = null, i.height = null, i.left = null, i.top = null, i.transitionTimeout = null, i.updateCall = null, i.element = null, i.settings = Object.assign({}, r, i.props.options), i.reverse = i.settings.reverse ? -1 : 1, i.onMouseEnter = i.onMouseEnter.bind(i, i.props.onMouseEnter), i.onMouseMove = i.onMouseMove.bind(i, i.props.onMouseMove), i.onMouseLeave = i.onMouseLeave.bind(i, i.props.onMouseLeave), i
        }
        return Qj(e, [{
            key: "componentDidMount",
            value: function() {
                this.element = (0, Yj.findDOMNode)(this)
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                clearTimeout(this.transitionTimeout), cancelAnimationFrame(this.updateCall)
            }
        }, {
            key: "onMouseEnter",
            value: function() {
                var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {},
                    r = arguments[1];
                return this.updateElementPosition(), this.setState(Object.assign({}, this.state, {
                    style: Zc({}, this.state.style, {
                        willChange: "transform"
                    })
                })), this.setTransition(), i(r)
            }
        }, {
            key: "reset",
            value: function() {
                var i = this;
                window.requestAnimationFrame(function() {
                    i.setState(Object.assign({}, i.state, {
                        style: Zc({}, i.state.style, {
                            transform: "perspective(" + i.settings.perspective + "px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)"
                        })
                    }))
                })
            }
        }, {
            key: "onMouseMove",
            value: function() {
                var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {},
                    r = arguments[1];
                return r.persist(), this.updateCall !== null && window.cancelAnimationFrame(this.updateCall), this.event = r, this.updateCall = requestAnimationFrame(this.update.bind(this, r)), i(r)
            }
        }, {
            key: "setTransition",
            value: function() {
                var i = this;
                clearTimeout(this.transitionTimeout), this.setState(Object.assign({}, this.state, {
                    style: Zc({}, this.state.style, {
                        transition: this.settings.speed + "ms " + this.settings.easing
                    })
                })), this.transitionTimeout = setTimeout(function() {
                    i.setState(Object.assign({}, i.state, {
                        style: Zc({}, i.state.style, {
                            transition: ""
                        })
                    }))
                }, this.settings.speed)
            }
        }, {
            key: "onMouseLeave",
            value: function() {
                var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {},
                    r = arguments[1];
                return this.setTransition(), this.settings.reset && this.reset(), i(r)
            }
        }, {
            key: "getValues",
            value: function(i) {
                var r = (i.nativeEvent.clientX - this.left) / this.width,
                    s = (i.nativeEvent.clientY - this.top) / this.height,
                    o = Math.min(Math.max(r, 0), 1),
                    a = Math.min(Math.max(s, 0), 1),
                    l = (this.reverse * (this.settings.max / 2 - o * this.settings.max)).toFixed(2),
                    c = (this.reverse * (a * this.settings.max - this.settings.max / 2)).toFixed(2),
                    d = o * 100,
                    h = a * 100;
                return {
                    tiltX: l,
                    tiltY: c,
                    percentageX: d,
                    percentageY: h
                }
            }
        }, {
            key: "updateElementPosition",
            value: function() {
                var i = this.element.getBoundingClientRect();
                this.width = this.element.offsetWidth, this.height = this.element.offsetHeight, this.left = i.left, this.top = i.top
            }
        }, {
            key: "update",
            value: function(i) {
                var r = this.getValues(i);
                this.setState(Object.assign({}, this.state, {
                    style: Zc({}, this.state.style, {
                        transform: "perspective(" + this.settings.perspective + "px) rotateX(" + (this.settings.axis === "x" ? 0 : r.tiltY) + "deg) rotateY(" + (this.settings.axis === "y" ? 0 : r.tiltX) + "deg) scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")"
                    })
                })), this.updateCall = null
            }
        }, {
            key: "render",
            value: function() {
                var i = Object.assign({}, this.props.style, this.state.style);
                return Kj.default.createElement("div", {
                    style: i,
                    className: this.props.className,
                    onMouseEnter: this.onMouseEnter,
                    onMouseMove: this.onMouseMove,
                    onMouseLeave: this.onMouseLeave
                }, this.props.children)
            }
        }]), e
    }(SI.Component),
    nJ = wI.default = tJ;
const gw = n => ({
        hidden: {
            y: -50,
            opacity: 0
        },
        show: {
            y: 0,
            opacity: 1,
            transition: {
                type: "spring",
                duration: 1.25,
                delay: n
            }
        }
    }),
    Qg = (n, e, t, i) => ({
        hidden: {
            x: n === "left" ? 100 : n === "right" ? -100 : 0,
            y: n === "up" ? 100 : n === "down" ? -100 : 0,
            opacity: 0
        },
        show: {
            x: 0,
            y: 0,
            opacity: 1,
            transition: {
                type: e,
                delay: t,
                duration: i,
                ease: "easeOut"
            }
        }
    }),
    gT = (n, e, t, i) => ({
        hidden: {
            x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
            y: n === "up" || n === "down" ? "100%" : 0
        },
        show: {
            x: 0,
            y: 0,
            transition: {
                type: e,
                delay: t,
                duration: i,
                ease: "easeOut"
            }
        }
    }),
    iJ = (n, e) => ({
        hidden: {},
        show: {
            transition: {
                staggerChildren: n,
                delayChildren: e || 0
            }
        }
    }),
    tc = (n, e) => function() {
        return le(bi.section, {
            variants: iJ(),
            initial: "hidden",
            whileInView: "show",
            viewport: {
                once: !0,
                amount: .25
            },
            className: `${pr.padding} max-w-7xl mx-auto relative z-0`,
            children: le(n, {})
        })
    },
    rJ = ({
        index: n,
        title: e,
        icon: t,
        text: i
    }) => it(nJ, {
        className: "xl:w-1/3 lg:w-1/3 md:w-2/4 sm:w-full md:px-4 p-0 w-full",
        children: [le("span", {
            className: "hash-span",
            id: "services",
            children: " "
        }), le(bi.div, {
            className: "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card",
            children: it("div", {
                className: "bg-tertiary rounded-[20px] py-4 px-4 min-h-[280px] flex justify-evenly items-center flex-col",
                children: [le("img", {
                    src: t,
                    alt: "web-development",
                    className: "w-16 h-16 object-contain"
                }), le("h3", {
                    className: "text-white text-[20px] font-bold text-center",
                    children: e
                }), le("p", {
                    className: " text-center",
                    children: i
                })]
            })
        })]
    }),
    sJ = () => it(og, {
        children: [it(bi.div, {
            children: [le("span", {
                className: "hash-span",
                id: "about",
                children: " "
            }), le("p", {
                className: pr.sectionSubText,
                children: "Über Diginex: Ihre Pforte zur digitalen Exzellenz"
            }), le("h2", {
                className: pr.sectionHeadText,
                children: "Webdesign und Softwareentwicklung"
            })]
        }), le(bi.p, {
            className: "mt-4 text-secondary text-[16px] max-w-3xl leading-[30px]",
            children: "Bei Diginex widmen wir uns der Verbesserung Ihrer digitalen Präsenz durch eine Kombination von Fachkompetenz: Professionelles Webdesign, maßgeschneiderte Softwarelösungen und zuverlässiges Cloud-Hosting. Unser Engagement besteht darin, Ihre Marke zu fördern und Ihr digitales Potenzial zu entfesseln. Mit unserem integrierten Ansatz ermöglichen wir Unternehmen, in der dynamischen Online-Landschaft erfolgreich zu sein. Entdecken Sie, wie Diginex Ihr Partner sein kann, um digitale Exzellenz zu erreichen."
        }), le("div", {
            className: "mt-20 flex flex-wrap",
            children: Hj.map((n, e) => le(rJ, {
                index: e,
                ...n
            }, n.title))
        })]
    }),
    oJ = tc(sJ),
    aJ = () => le("div", {
        className: "flex flex-row flex-wrap justify-center gap-10",
        children: Vj.map(n => le("div", {
            className: "w-28 h-28",
            children: le(VV, {
                icon: n.icon
            })
        }, n.name))
    }),
    lJ = tc(aJ);
var Kg = {},
    ig = {},
    uJ = {
        get exports() {
            return ig
        },
        set exports(n) {
            ig = n
        }
    };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
    (function() {
        var e = {}.hasOwnProperty;

        function t() {
            for (var i = [], r = 0; r < arguments.length; r++) {
                var s = arguments[r];
                if (s) {
                    var o = typeof s;
                    if (o === "string" || o === "number") i.push(s);
                    else if (Array.isArray(s)) {
                        if (s.length) {
                            var a = t.apply(null, s);
                            a && i.push(a)
                        }
                    } else if (o === "object") {
                        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
                            i.push(s.toString());
                            continue
                        }
                        for (var l in s) e.call(s, l) && s[l] && i.push(l)
                    }
                }
            }
            return i.join(" ")
        }
        n.exports ? (t.default = t, n.exports = t) : window.classNames = t
    })()
})(uJ);
Kg.__esModule = !0;
Kg.default = void 0;
var cJ = yw(U),
    fo = yw(Qm),
    fJ = yw(ig);

function yw(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const MI = ({
    animate: n = !0,
    className: e = "",
    layout: t = "2-columns",
    lineColor: i = "#FFF",
    children: r
}) => (typeof window == "object" && document.documentElement.style.setProperty("--line-color", i), cJ.default.createElement("div", {
    className: (0, fJ.default)(e, "vertical-timeline", {
        "vertical-timeline--animate": n,
        "vertical-timeline--two-columns": t === "2-columns",
        "vertical-timeline--one-column-left": t === "1-column" || t === "1-column-left",
        "vertical-timeline--one-column-right": t === "1-column-right"
    })
}, r));
MI.propTypes = {
    children: fo.default.oneOfType([fo.default.arrayOf(fo.default.node), fo.default.node]).isRequired,
    className: fo.default.string,
    animate: fo.default.bool,
    layout: fo.default.oneOf(["1-column-left", "1-column", "2-columns", "1-column-right"]),
    lineColor: fo.default.string
};
var dJ = MI;
Kg.default = dJ;
var Yg = {};

function Xx() {
    return Xx = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
        }
        return n
    }, Xx.apply(this, arguments)
}

function hJ(n, e) {
    n.prototype = Object.create(e.prototype), n.prototype.constructor = n, Qx(n, e)
}

function Qx(n, e) {
    return Qx = Object.setPrototypeOf || function(i, r) {
        return i.__proto__ = r, i
    }, Qx(n, e)
}

function pJ(n, e) {
    if (n == null) return {};
    var t = {},
        i = Object.keys(n),
        r, s;
    for (s = 0; s < i.length; s++) r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]);
    return t
}
var Kx = new Map,
    jp = new WeakMap,
    yT = 0,
    CI = void 0;

function mJ(n) {
    CI = n
}

function gJ(n) {
    return n ? (jp.has(n) || (yT += 1, jp.set(n, yT.toString())), jp.get(n)) : "0"
}

function yJ(n) {
    return Object.keys(n).sort().filter(function(e) {
        return n[e] !== void 0
    }).map(function(e) {
        return e + "_" + (e === "root" ? gJ(n.root) : n[e])
    }).toString()
}

function vJ(n) {
    var e = yJ(n),
        t = Kx.get(e);
    if (!t) {
        var i = new Map,
            r, s = new IntersectionObserver(function(o) {
                o.forEach(function(a) {
                    var l, c = a.isIntersecting && r.some(function(d) {
                        return a.intersectionRatio >= d
                    });
                    n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = c), (l = i.get(a.target)) == null || l.forEach(function(d) {
                        d(c, a)
                    })
                })
            }, n);
        r = s.thresholds || (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0]), t = {
            id: e,
            observer: s,
            elements: i
        }, Kx.set(e, t)
    }
    return t
}

function vw(n, e, t, i) {
    if (t === void 0 && (t = {}), i === void 0 && (i = CI), typeof window.IntersectionObserver > "u" && i !== void 0) {
        var r = n.getBoundingClientRect();
        return e(i, {
                isIntersecting: i,
                target: n,
                intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0,
                time: 0,
                boundingClientRect: r,
                intersectionRect: r,
                rootBounds: r
            }),
            function() {}
    }
    var s = vJ(t),
        o = s.id,
        a = s.observer,
        l = s.elements,
        c = l.get(n) || [];
    return l.has(n) || l.set(n, c), c.push(e), a.observe(n),
        function() {
            c.splice(c.indexOf(e), 1), c.length === 0 && (l.delete(n), a.unobserve(n)), l.size === 0 && (a.disconnect(), Kx.delete(o))
        }
}
var AJ = ["children", "as", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"];

function vT(n) {
    return typeof n.children != "function"
}
var rg = function(n) {
    hJ(e, n);

    function e(i) {
        var r;
        return r = n.call(this, i) || this, r.node = null, r._unobserveCb = null, r.handleNode = function(s) {
            r.node && (r.unobserve(), !s && !r.props.triggerOnce && !r.props.skip && r.setState({
                inView: !!r.props.initialInView,
                entry: void 0
            })), r.node = s || null, r.observeNode()
        }, r.handleChange = function(s, o) {
            s && r.props.triggerOnce && r.unobserve(), vT(r.props) || r.setState({
                inView: s,
                entry: o
            }), r.props.onChange && r.props.onChange(s, o)
        }, r.state = {
            inView: !!i.initialInView,
            entry: void 0
        }, r
    }
    var t = e.prototype;
    return t.componentDidUpdate = function(r) {
        (r.rootMargin !== this.props.rootMargin || r.root !== this.props.root || r.threshold !== this.props.threshold || r.skip !== this.props.skip || r.trackVisibility !== this.props.trackVisibility || r.delay !== this.props.delay) && (this.unobserve(), this.observeNode())
    }, t.componentWillUnmount = function() {
        this.unobserve(), this.node = null
    }, t.observeNode = function() {
        if (!(!this.node || this.props.skip)) {
            var r = this.props,
                s = r.threshold,
                o = r.root,
                a = r.rootMargin,
                l = r.trackVisibility,
                c = r.delay,
                d = r.fallbackInView;
            this._unobserveCb = vw(this.node, this.handleChange, {
                threshold: s,
                root: o,
                rootMargin: a,
                trackVisibility: l,
                delay: c
            }, d)
        }
    }, t.unobserve = function() {
        this._unobserveCb && (this._unobserveCb(), this._unobserveCb = null)
    }, t.render = function() {
        if (!vT(this.props)) {
            var r = this.state,
                s = r.inView,
                o = r.entry;
            return this.props.children({
                inView: s,
                entry: o,
                ref: this.handleNode
            })
        }
        var a = this.props,
            l = a.children,
            c = a.as,
            d = pJ(a, AJ);
        return U.createElement(c || "div", Xx({
            ref: this.handleNode
        }, d), l)
    }, e
}(U.Component);
rg.displayName = "InView";
rg.defaultProps = {
    threshold: 0,
    triggerOnce: !1,
    initialInView: !1
};

function xJ(n) {
    var e = n === void 0 ? {} : n,
        t = e.threshold,
        i = e.delay,
        r = e.trackVisibility,
        s = e.rootMargin,
        o = e.root,
        a = e.triggerOnce,
        l = e.skip,
        c = e.initialInView,
        d = e.fallbackInView,
        h = U.useRef(),
        p = U.useState({
            inView: !!c
        }),
        m = p[0],
        v = p[1],
        y = U.useCallback(function(x) {
            h.current !== void 0 && (h.current(), h.current = void 0), !l && x && (h.current = vw(x, function(_, S) {
                v({
                    inView: _,
                    entry: S
                }), S.isIntersecting && a && h.current && (h.current(), h.current = void 0)
            }, {
                root: o,
                rootMargin: s,
                threshold: t,
                trackVisibility: r,
                delay: i
            }, d))
        }, [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, d, i]);
    U.useEffect(function() {
        !h.current && m.entry && !a && !l && v({
            inView: !!c
        })
    });
    var A = [y, m.inView, m.entry];
    return A.ref = A[0], A.inView = A[1], A.entry = A[2], A
}
const _J = Object.freeze(Object.defineProperty({
        __proto__: null,
        InView: rg,
        default: rg,
        defaultFallbackInView: mJ,
        observe: vw,
        useInView: xJ
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    wJ = wL(_J);
Yg.__esModule = !0;
Yg.default = void 0;
var ho = Aw(U),
    Qt = Aw(Qm),
    Jp = Aw(ig),
    SJ = wJ;

function Aw(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
const EI = ({
    children: n = "",
    className: e = "",
    contentArrowStyle: t = null,
    contentStyle: i = null,
    date: r = "",
    dateClassName: s = "",
    icon: o = null,
    iconClassName: a = "",
    iconOnClick: l = null,
    onTimelineElementClick: c = null,
    iconStyle: d = null,
    id: h = "",
    position: p = "",
    style: m = null,
    textClassName: v = "",
    intersectionObserverProps: y = {
        rootMargin: "0px 0px -40px 0px",
        triggerOnce: !0
    },
    visible: A = !1
}) => ho.default.createElement(SJ.InView, y, ({
    inView: x,
    ref: _
}) => ho.default.createElement("div", {
    ref: _,
    id: h,
    className: (0, Jp.default)(e, "vertical-timeline-element", {
        "vertical-timeline-element--left": p === "left",
        "vertical-timeline-element--right": p === "right",
        "vertical-timeline-element--no-children": n === ""
    }),
    style: m
}, ho.default.createElement(ho.default.Fragment, null, ho.default.createElement("span", {
    style: d,
    onClick: l,
    className: (0, Jp.default)(a, "vertical-timeline-element-icon", {
        "bounce-in": x || A,
        "is-hidden": !(x || A)
    })
}, o), ho.default.createElement("div", {
    style: i,
    onClick: c,
    className: (0, Jp.default)(v, "vertical-timeline-element-content", {
        "bounce-in": x || A,
        "is-hidden": !(x || A)
    })
}, ho.default.createElement("div", {
    style: t,
    className: "vertical-timeline-element-content-arrow"
}), n, ho.default.createElement("span", {
    className: (0, Jp.default)(s, "vertical-timeline-element-date")
}, r)))));
EI.propTypes = {
    children: Qt.default.oneOfType([Qt.default.arrayOf(Qt.default.node), Qt.default.node]),
    className: Qt.default.string,
    contentArrowStyle: Qt.default.shape({}),
    contentStyle: Qt.default.shape({}),
    date: Qt.default.node,
    dateClassName: Qt.default.string,
    icon: Qt.default.element,
    iconClassName: Qt.default.string,
    iconStyle: Qt.default.shape({}),
    iconOnClick: Qt.default.func,
    onTimelineElementClick: Qt.default.func,
    id: Qt.default.string,
    position: Qt.default.string,
    style: Qt.default.shape({}),
    textClassName: Qt.default.string,
    visible: Qt.default.bool,
    intersectionObserverProps: Qt.default.shape({
        root: Qt.default.object,
        rootMargin: Qt.default.string,
        threshold: Qt.default.number,
        triggerOnce: Qt.default.bool
    })
};
var MJ = EI;
Yg.default = MJ;
var bI = {
    VerticalTimeline: Kg.default,
    VerticalTimelineElement: Yg.default
};
const CJ = ({
        experience: n
    }) => le(bI.VerticalTimelineElement, {
        contentStyle: {
            background: "#1E4D72",
            color: "#fff"
        },
        contentArrowStyle: {
            borderRight: "7px solid  #1E4D72"
        },
        date: n.date,
        iconStyle: {
            background: n.iconBg
        },
        icon: le("div", {
            className: "flex justify-center items-center w-full h-full",
            children: le("img", {
                src: n.icon,
                alt: n.company_name,
                className: "w-[60%] h-[60%] object-contain"
            })
        }),
        children: it("div", {
            children: [le("h3", {
                className: "text-white text-[20px] font-bold mb-3",
                children: n.title
            }), le("p", {
                className: "text-white text-[14px] font-normal",
                style: {
                    margin: 0
                },
                children: n.text
            })]
        })
    }),
    EJ = () => it(og, {
        children: [it(bi.div, {
            variants: gw(),
            children: [le("span", {
                className: "hash-span",
                id: "sequence",
                children: " "
            }), le("h2", {
                className: `${pr.sectionHeadText} text-center`,
                children: "Der fuck für Ihr neues Webprojekt in Kürze"
            })]
        }), le("div", {
            className: "mt-20 flex flex-col",
            children: le(bI.VerticalTimeline, {
                children: Wj.map((n, e) => le(CJ, {
                    experience: n
                }, `experience-${e}`))
            })
        })]
    }),
    bJ = tc(EJ),
    TJ = ({
        index: n,
        name: e,
        description: t,
        tags: i,
        image: r,
        source_code_link: s
    }) => le(bi.div, {
        variants: Qg("", "spring", n * .5, .75),
        className: "w-full xl:w-1/3 lg:w-1/3 md:w-2/4 sm:w-full md:px-4 p-0 w-full mb-6",
        children: it("div", {
            className: "bg-tertiary rounded-2xl p-5",
            children: [it("div", {
                className: "relative w-full h-[230px]",
                children: [le("img", {
                    src: r,
                    alt: "project_image",
                    className: "w-full h-full object-cover rounded-2xl"
                }), le("div", {
                    className: "absolute inset-0 flex justify-end m-3 card-img_hover",
                    children: le("div", {
                        onClick: () => window.open(s, "_blank"),
                        className: "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                        children: le("img", {
                            src: uj,
                            alt: "source code",
                            className: "w-1/2 h-1/2 object-contain"
                        })
                    })
                })]
            }), it("div", {
                className: "mt-5",
                children: [le("h3", {
                    className: "text-white font-bold text-[24px]",
                    children: e
                }), le("p", {
                    className: "mt-2 text-secondary text-[14px]",
                    children: t
                })]
            }), le("div", {
                className: "mt-4 flex flex-wrap gap-2",
                children: i.map(o => it("p", {
                    className: `text-[14px] ${o.color}`,
                    children: ["#", o.name]
                }, `${e}-${o.name}`))
            })]
        })
    }),
    BJ = () => it(og, {
        children: [it(bi.div, {
            variants: gw(),
            children: [le("span", {
                className: "hash-span",
                id: "examples",
                children: " "
            }), le("h2", {
                className: `${pr.sectionHeadText}`,
                children: "Portofolio."
            })]
        }), le("div", {
            className: "w-full flex",
            children: it(bi.p, {
                variants: Qg("", "", .1, 1),
                className: "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
                children: ["Die folgenden Projekte sind einige frühere Arbeiten unseres Teams. Dies sind nur wenige Beispiele aus unserem umfangreichen Portfolio, in dem wir mit Kunden aus der ganzen Welt zusammengearbeitet haben.", le("br", {}), "Unser Team verfügt über viele Jahre Erfahrung in verschiedenen Programmiersprachen."]
            })
        }), le("div", {
            className: "mt-20 flex flex-wrap",
            children: jj.map((n, e) => le(TJ, {
                index: e,
                ...n
            }, `project-${e}`))
        })]
    }),
    PJ = tc(BJ),
    RJ = ({
        index: n,
        name: e,
        description: t,
        package_01: i,
        package_01_price: r,
        package_02: s,
        package_02_price: o,
        points_heading: a,
        points: l
    }) => le(bi.div, {
        variants: Qg("up", "spring", n * .5, .75),
        className: "w-full xl:w-1/3 lg:w-1/3 md:w-2/4 sm:w-full md:px-4 p-0 w-full mb-6",
        children: it("div", {
            className: "bg-tertiary rounded-2xl p-5",
            children: [it("div", {
                className: "mb-3",
                children: [le("h3", {
                    className: "text-white font-bold text-[24px]",
                    children: e
                }), le("p", {
                    className: "mt-2 text-white text-[14px]",
                    children: t
                })]
            }), it("div", {
                className: "flex justify-between mb-2 pb-2",
                children: [le("p", {
                    className: "font-bold text-[#D0B870] text-[16px] pr-4",
                    children: i
                }), le("span", {
                    className: "text-white text-[14px]",
                    children: r
                })]
            }), le("hr", {}), it("div", {
                className: "flex justify-between mt-2 mb-2 pb-2",
                children: [le("p", {
                    className: "font-bold text-[#D0B870] text-[16px]",
                    children: s
                }), le("span", {
                    className: " text-white text-[14px]",
                    children: o
                })]
            }), le("h3", {
                className: "text-white font-bold text-[20px] mb-4",
                children: a
            }), le("ul", {
                className: "mt-5 list-disc ml-5 packages_options",
                children: l.map((c, d) => le("li", {
                    className: "text-white-100 text-[14px] pl-1 tracking-wider",
                    children: c
                }, `packages-point-${d}`))
            })]
        })
    }),
    IJ = () => it(og, {
        children: [it(bi.div, {
            variants: gw(),
            children: [le("span", {
                className: "hash-span",
                id: "price",
                children: " "
            }), le("h2", {
                className: `${pr.sectionHeadText} text-center`,
                children: "Maßgeschneidertes Webdesign und Entwicklung für unterschiedliche Budgets"
            })]
        }), le("div", {
            className: "mt-20 flex flex-wrap",
            children: Jj.map((n, e) => le(RJ, {
                index: e,
                ...n
            }, `package-${e}`))
        }), le("div", {
            className: "w-full flex mt-5",

        })]
    }),
    LJ = tc(IJ),
    ud = {
        _origin: "https://api.emailjs.com"
    },
    DJ = (n, e = "https://api.emailjs.com") => {
        ud._userID = n, ud._origin = e
    },
    TI = (n, e, t) => {
        if (!n) throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
        if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
        if (!t) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
        return !0
    };
class AT {
    constructor(e) {
        this.status = e ? e.status : 0, this.text = e ? e.responseText : "Network Error"
    }
}
const BI = (n, e, t = {}) => new Promise((i, r) => {
        const s = new XMLHttpRequest;
        s.addEventListener("load", ({
            target: o
        }) => {
            const a = new AT(o);
            a.status === 200 || a.text === "OK" ? i(a) : r(a)
        }), s.addEventListener("error", ({
            target: o
        }) => {
            r(new AT(o))
        }), s.open("POST", ud._origin + n, !0), Object.keys(t).forEach(o => {
            s.setRequestHeader(o, t[o])
        }), s.send(e)
    }),
    FJ = (n, e, t, i) => {
        const r = i || ud._userID;
        return TI(r, n, e), BI("/api/v1.0/email/send", JSON.stringify({
            lib_version: "3.10.0",
            user_id: r,
            service_id: n,
            template_id: e,
            template_params: t
        }), {
            "Content-type": "application/json"
        })
    },
    kJ = n => {
        let e;
        if (typeof n == "string" ? e = document.querySelector(n) : e = n, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form";
        return e
    },
    NJ = (n, e, t, i) => {
        const r = i || ud._userID,
            s = kJ(t);
        TI(r, n, e);
        const o = new FormData(s);
        return o.append("lib_version", "3.10.0"), o.append("service_id", n), o.append("template_id", e), o.append("user_id", r), BI("/api/v1.0/email/send-form", o)
    },
    OJ = {
        init: DJ,
        send: FJ,
        sendForm: NJ
    },
    UJ = () => {
        const n = U.useRef(),
            [e, t] = U.useState({
                name: "",
                email: "",
                message: ""
            }),
            [i, r] = U.useState(!1),
            s = a => {
                const {
                    target: l
                } = a, {
                    name: c,
                    value: d
                } = l;
                t({
                    ...e,
                    [c]: d
                })
            },
            o = a => {
                a.preventDefault(), r(!0), OJ.send("service_ern3d6m", "template_rq30pqc", {
                    from_name: e.name,
                    to_name: "Diginex Web Solution",
                    from_email: e.email,
                    to_email: "hello@diginex.at",
                    message: e.message
                }, "xoH3a2sNsjC3kRs8e").then(() => {
                    r(!1), alert("Danke schön. Ich werde mich so schnell wie möglich bei Ihnen melden."), t({
                        name: "",
                        email: "",
                        message: ""
                    })
                }, l => {
                    r(!1), console.error(l), alert("Ahh, etwas ist schief gelaufen. Bitte versuche es erneut.")
                })
            };
        return it("div", {
            className: "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
            children: [it(bi.div, {
                variants: gT("left", "tween", .2, 1),
                className: "flex-[0.75] bg-tertiary-new p-8 rounded-2xl",
                children: [le("span", {
                    className: "hash-span",
                    id: "contact",
                    children: " "
                }), le("p", {
                    className: pr.sectionSubText,
                    children: "Kontaktieren Sie uns"
                }), le("h3", {
                    className: pr.sectionHeadText,
                    children: "Kontakt."
                }), it("form", {
                    ref: n,
                    onSubmit: o,
                    className: "mt-12 flex flex-col gap-8",
                    children: [it("label", {
                        className: "flex flex-col",
                        children: [le("span", {
                            className: "text-white font-medium mb-4",
                            children: "Ihr Name"
                        }), le("input", {
                            type: "text",
                            name: "name",
                            value: e.name,
                            onChange: s,
                            placeholder: "Wie lautet Ihr Name?",
                            className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                            required: !0
                        })]
                    }), it("label", {
                        className: "flex flex-col",
                        children: [le("span", {
                            className: "text-white font-medium mb-4",
                            children: "Your email"
                        }), le("input", {
                            type: "email",
                            name: "email",
                            value: e.email,
                            onChange: s,
                            placeholder: "Was ist Ihre E-Mail-Adresse?",
                            className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                            required: !0
                        })]
                    }), it("label", {
                        className: "flex flex-col",
                        children: [le("span", {
                            className: "text-white font-medium mb-4",
                            children: "Ihre Nachricht"
                        }), le("textarea", {
                            rows: 7,
                            name: "message",
                            value: e.message,
                            onChange: s,
                            placeholder: "Wie können wir Ihnen helfen?",
                            className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium"
                        })]
                    }), le("button", {
                        type: "submit",
                        className: "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary",
                        children: i ? "Sending..." : "Send"
                    })]
                })]
            }), le(bi.div, {
                variants: gT("right", "tween", .2, 1),
                className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]",
                children: le(GV, {})
            })]
        })
    },
    zJ = tc(UJ),
    GJ = () => it(Sk, {
        children: [it("div", {
            className: "relative z-0 bg-primary",
            children: [it("div", {
                className: "bg-hero-pattern bg-cover bg-no-repeat bg-center",
                children: [le(Xj, {}), le(ij, {})]
            }), le(oJ, {}), le(bJ, {}), le(lJ, {}), le(PJ, {}), le(LJ, {}), le("span", {
                className: "hash-span",
                id: "contact",
                children: " "
            }), it("div", {
                className: "relative z-0",
                children: [le(zJ, {}), le(jV, {})]
            })]
        }), it("div", {
            className: "bg-tertiary-new",
            children: [it("section", {
                className: "footer flex flex-wrap sm:px-16 px-6 sm:py-16 py-6 max-w-7xl mx-auto relative z-0",
                children: [le("div", {
                    className: "w-full xl:w-1/3 lg:w-1/3 md:w-full sm:w-full md:px-3 p-0 w-full mb-6 xl:mb-0 lg:mb-0 md:mb-6",
                    children: le("div", {
                        className: "bg-tertiary rounded-2xl p-5",
                        children: le("a", {
                            href: "mailto:Hello@diginex.at",
                            className: "email",
                            children: "Hello@diginex.at"
                        })
                    })
                }), le("div", {
                    className: "w-full xl:w-1/3 lg:w-1/3 md:w-full sm:w-full md:px-3 p-0 w-full mb-6 xl:mb-0 lg:mb-0 md:mb-6",

                }), le("div", {
                    className: "w-full xl:w-1/3 lg:w-1/3 md:w-full sm:w-full md:px-3 p-0 w-full mb-6 xl:mb-0 lg:mb-0 md:mb-6",

                })]
            }), le("section", {
                className: "pb-6 pl-4 pr-4 text-white text-center text-[14px]",
                children: "Copyright 2023333 Diginex Web Solution, All rights reserved"
            })]
        }), it(NB, {
            location: "bottom",
            buttonText: "Accept All",
            enableDeclineButton: !0,
            declineButtonText: "Decline",
            declineCookieValue: !1,
            cookieName: "DiginexCookie",
            buttonClasses: "",
            style: {
                background: "#2D5D83"
            },
            buttonStyle: {
                background: "#123E61",
                color: "#fff",
                fontSize: "13px",
                margin: "10px",
                padding: "15px",
                borderRadius: "10px",
                fontWeight: "500"
            },
            declineButtonStyle: {
                background: "#fff",
                color: "#123E61",
                fontSize: "13px",
                margin: "10px",
                padding: "15px",
                borderRadius: "10px",
                fontWeight: "500"
            },
            expires: 150,
            contentClasses: "DigiCookies",
            children: [le("h3", {
                className: "text-white font-bold text-[18px]",
                children: "We value your privacy"
            }), le("p", {
                className: "mt-3 text-white text-[14px]",
                children: 'We use cookies to enhance your browsing experience, serve personalized ads or content, and analyze our traffic. By clicking "Accept All", you consent to our use of cookies.'
            })]
        })]
    });
Dv.createRoot(document.getElementById("root")).render(le(ar.StrictMode, {
    children: le(GJ, {})
}));
